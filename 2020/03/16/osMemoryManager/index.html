
<!DOCTYPE html>
<html lang="en" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>存储器（内存）管理 - 李呀呀</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="李紫薇,"> 
    <meta name="description" content="内存管理概念用来对内存进行分配保护和扩充
功能：内存分配与回收、地址变换、内存保护、内存扩充
过程：编译-&amp;gt;链接-&amp;gt;装入

静态链接：在程序运行前，先把各个目标模块及所需库链接成一个完整,"> 
    <meta name="author" content="lesvay"> 
    <link rel="alternative" href="atom.xml" title="李呀呀" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 4.2.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">李呀呀</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://lesvay.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">存储器（内存）管理</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">存储器（内存）管理</h1>
        <div class="stuff">
            <span>三月 16, 2020</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/memoryManager/" rel="tag">memoryManager</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h1><p>用来对内存进行分配保护和扩充</p>
<p>功能：内存分配与回收、地址变换、内存保护、内存扩充</p>
<p>过程：编译-&gt;链接-&gt;装入</p>
<ul>
<li>静态链接：在程序运行前，先把各个目标模块及所需库链接成一个完整的可执行程序，以后不再拆开</li>
<li>装入时动态链接：边装入边链接</li>
<li>运行时动态链接：边运行边链接</li>
<li>绝对装入：在装入时就知道物理地址</li>
<li>可重定位装入：地址变换通常在装入时一次完成</li>
<li>动态运行装入：允许程序运行时在内存中移动位置，物理地址=基址寄存器+逻辑地址（逻辑地址是偏移地址，物理地址是内存中的地址）</li>
</ul>
<p>内存保护：防止一个作业有意无意破坏操作系统或其他作业</p>
<table>
<thead>
<tr>
<th>内存保护方法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>上下界寄存器方法</td>
<td>采用上下界分别存放作业结束地址和开始地址</td>
</tr>
<tr>
<td>基址（重定位寄存器）和限长寄存器（界地址寄存器）方法</td>
<td>限长寄存器与相对地址进行比较，超过则发生中断</td>
</tr>
<tr>
<td>存储保护键方法</td>
<td>给每个存储块分配一个单独的保护键，比较钥匙和锁是否匹配</td>
</tr>
</tbody></table>
<h1 id="交换与覆盖"><a href="#交换与覆盖" class="headerlink" title="交换与覆盖"></a>交换与覆盖</h1><table>
<thead>
<tr>
<th>技术</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>覆盖技术</td>
<td>解决程序不能全部装入内存中</td>
</tr>
<tr>
<td>交换技术</td>
<td>把暂时不用的程序或数据移入外存</td>
</tr>
</tbody></table>
<h1 id="分配管理方式"><a href="#分配管理方式" class="headerlink" title="分配管理方式"></a>分配管理方式</h1><h2 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h2><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><ul>
<li>将内存分为两个连续存储区域，一个给操作系统，一个给用户</li>
<li>采用静态分配，适合单道程序</li>
</ul>
<h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><ul>
<li>每个分区可以装入一道程序，分区大小事先固定</li>
<li>缺乏灵活性，以产生碎片</li>
</ul>
<h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><table>
<thead>
<tr>
<th>分区分配中的数据结构</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>空闲分区表</td>
<td>每个空闲分区表对应一个表项</td>
</tr>
<tr>
<td>空闲分区链</td>
<td>指向下一个 空闲分区的指针</td>
</tr>
</tbody></table>
<ul>
<li>空闲分区表：每个空闲分区表对应一个表项</li>
<li>空闲分区链：指向下一个 空闲分区的指针</li>
</ul>
<table>
<thead>
<tr>
<th>分区分配中的算法</th>
<th>解释</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>首次适应算法FF</td>
<td>按地址来，每次都从队头开始</td>
<td>保留了高位地址大的空闲区，无内部碎片</td>
<td>地位地址被划分，产生很多小的空闲区，无外部碎片</td>
</tr>
<tr>
<td>下次适应算法NF</td>
<td>按地址，循环，从上次空闲区下一个区开始</td>
<td>使空闲分区分布更加均匀</td>
<td>导致缺乏大的空闲分区</td>
</tr>
<tr>
<td>最佳适应算法BF</td>
<td>按容量大小从大开始，找到一个可以满足的最小区</td>
<td>总能分到最恰当的分区，并保留最大的</td>
<td>产生很多碎片</td>
</tr>
<tr>
<td>最差适应算法WF</td>
<td>按容量大小从小开始，找到按要求最大的</td>
<td>使分给作业后剩的空闲分区比较大</td>
<td>无法满足大作业的申请</td>
</tr>
</tbody></table>
<p>分区回收：合并上面，合并下面，合并上下</p>
<table>
<thead>
<tr>
<th>分区分配的动态管理</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>拼接技术</td>
<td>把已分配的移动到一端，碎片集中到一起</td>
</tr>
<tr>
<td>动态重定位分区分配技术</td>
<td>与上面的分配算法相同，并增加了拼接技术</td>
</tr>
</tbody></table>
<h2 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h2><h3 id="基本分页管理方式"><a href="#基本分页管理方式" class="headerlink" title="基本分页管理方式"></a>基本分页管理方式</h3><ul>
<li>页：用户作业地址空间被划分成若干大小相同区域，成为页或页面</li>
<li>页表：将页面与物理地址一一对应形成一张表</li>
</ul>
<p><img src="/2020/03/16/osMemoryManager/jibenfenyeguanli.png" alt="图片-基本分页管理方式"></p>
<ul>
<li>两级页表和多级页表<ul>
<li>页表大小计算</li>
<li>两级页表：外层页号，外层内页地址，页内地址</li>
<li>多级页表：增加级数，减小页表的大小</li>
</ul>
</li>
<li>页的保护与共享<ul>
<li>地址越界保护：用地址和长度来保护信息安全</li>
<li>访问控制信息保护</li>
</ul>
</li>
<li>有效访问时间计算<ul>
<li>没有快表EAT=2t（t访存一次消耗时间）</li>
<li>有快表EAT=a<em>b+(t+a)</em>(1-b)+t，（a访问快表时间，b快表命中率）</li>
</ul>
</li>
<li>优点：利用率高，实现了离散分配，便于存储访问控制，无外部碎片</li>
<li>缺点：硬件支持，内存访问效率下降，共享困难，内部碎片</li>
</ul>
<h3 id="基本分段管理方式"><a href="#基本分段管理方式" class="headerlink" title="基本分段管理方式"></a>基本分段管理方式</h3><ul>
<li><p>段：一组逻辑意义上相对完整的信息集合，逻辑地址结构由段号和段内位移组成</p>
</li>
<li><p>段表及地址变换：</p>
<ul>
<li>从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W。</li>
<li>比较段号S和段表长度M，若S多M，则产生越界中断，否则继续执行。</li>
<li>段表中段号S对应的段表项地址 = 段表起始地址F + 段号S * 段表项长度，取出该段表项的前几位得到段长C。若段内偏移量&gt;=C，则产生越界中断，否则继续执行。</li>
<li>取出段表项中该段的起始地址b，计算 E = b + W，用得到的物理地址E去访问内存。</li>
</ul>
</li>
<li><p>段的共享与保护：与页相同</p>
</li>
<li><p>优点：便于模块化、程序化处理数据结构，便于动态链接和共享、无内部碎片，方便编程、信息共享、信息保护</p>
</li>
<li><p>缺点：需要硬件支持、为满足动态增长减少外部碎片需要拼接技术、分段最大尺寸受主存可用空间限制、有外部碎片</p>
</li>
<li><p>段与页区别</p>
<p><img src="/2020/03/16/osMemoryManager/duanyequbie.jpg" alt="图片-段页的区别"></p>
</li>
<li><p>基本段页式管理方式</p>
<p>页式存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享。如果将这两种存储管理方法结合起来，就形成了段页式存储管理方式。</p>
<p>在段页式系统中，作业的地址空间首先被分成若干个逻辑段，每段都有自己的段号，然后再将每一段分成若干个大小固定的页。对内存空间的管理仍然和分页存储管理一样，将其分成若干个和页面大小相同的存储块，对内存的分配以存储块为单位</p>
<p>结合了两者的优点，但内部碎片不是和页式一样少</p>
</li>
</ul>
<h1 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h1><p>可以让作业部分装入就可以运行的技术</p>
<table>
<thead>
<tr>
<th>特征</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>部分装入</td>
<td>启动程序，程序一部分装入内存</td>
</tr>
<tr>
<td>请求调入</td>
<td>当信息不在内存时，有操作系统将需要的部分调入</td>
</tr>
<tr>
<td>置换功能</td>
<td>将暂时不使用的调入外存</td>
</tr>
<tr>
<td>虚拟存储器</td>
<td>逻辑上扩充存储器空间</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>局部性原理</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>时间局部</td>
<td>一次或下次访问都集中在一个较短的时期内</td>
</tr>
<tr>
<td>控件局部</td>
<td>访问的内容和邻近的内容都集中在一个较小的区域内</td>
</tr>
</tbody></table>
<p>特点：离散性、多次性、对换性、虚拟性</p>
<p>软硬件支持</p>
<ul>
<li>相当数量的外存</li>
<li>一定容量的内存</li>
<li>中断机构：当访问不在内存中，实行中断</li>
<li>地址变换机构：动态实现虚地址到实地址变换</li>
<li>相关数据结构：段表或页表</li>
</ul>
<h2 id="请求分页存储管理系统"><a href="#请求分页存储管理系统" class="headerlink" title="请求分页存储管理系统"></a>请求分页存储管理系统</h2><h3 id="管理方式"><a href="#管理方式" class="headerlink" title="管理方式"></a>管理方式</h3><ul>
<li><p>请求分页=基本分页+请求调页功能+页面置换功能</p>
</li>
<li><p>页表结构</p>
<ul>
<li>页号和物理块号</li>
<li>状态位（存在位）：是否存在于主存</li>
<li>访问字段一段时间内被访问的次数</li>
<li>修改位：调入内存后是否被修改过</li>
</ul>
</li>
<li><p>缺页中断与地址变换</p>
<p><img src="/2020/03/16/osMemoryManager/queyezhongduan.jpg" alt="图片-缺页中断"></p>
</li>
</ul>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><ul>
<li>最佳置换算法OPT：最先淘汰后面都不使用的</li>
<li>先进先出置换算法FIFO：</li>
<li>最近最少使用置换算法LRU：保留最近使用的</li>
<li>时钟置换算法CLOCK：从上一个被淘汰的页面开始遍历遇到访问位0就淘汰，将经过的访问位为1的都置为0</li>
<li>改进时钟置换算法CLOCK：同为0的页面优先淘汰未修改的。第一遍扫描不对经过的修改遇到访问位和过程位都为0的淘汰，若无第二遍对过程中访问位置0遇到访问位为0修改位为1淘汰，若无回到起始位重新执行1和2</li>
<li>最不常用置换算法LFU</li>
<li>页面缓冲算法PBA</li>
</ul>
<h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><ul>
<li>工作集论：让操作系统监视各进程的工作集，若内存有空，则再调一个进程进入内存。若超过，则选择一个进程对换到磁盘</li>
<li>页面分配策略<ul>
<li>固定分配局部置换：为每个进程分配固定的物理块</li>
<li>可变分配全局置换：维护一个空闲物理块，每当进程缺页时，就分配给它，当空闲物理块不够时，就从任何进程中随机取出一页</li>
<li>可变分配局部置换：为每个进程分配一定的物理块，当缺页中断时且无空闲物理块，只让进程换出自己的某个内存页，平凡缺页时就分配给它适当物理块，缺页率少时，适当减少物理块</li>
</ul>
</li>
<li>页面调入策略<ul>
<li>请求调页策略：只有用到时才被调入内存</li>
<li>预调页策略：预计不久之后会用到的调入内存</li>
</ul>
</li>
<li>从何处调入<ul>
<li>系统拥有足够的兑换空间：从对换区全部调入</li>
<li>系统缺少足够的对换空间：不被修改的从文件区调入，可能被修改的调到对换区调入</li>
<li>UNIX方式：与进程有关的都放入文件区，未运行的都在文件区，运行的且被换出的，由于是在对换区，下次仍从对换区调</li>
</ul>
</li>
</ul>
<h3 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h3><ul>
<li>Belady移除：FIFO随物理块增加缺页率增加</li>
<li>抖动现性：刚被调出又要被调入</li>
<li>缺页率：所需页面调入内存的次数/访问次数</li>
</ul>
<h3 id="有效访问时间计算"><a href="#有效访问时间计算" class="headerlink" title="有效访问时间计算"></a>有效访问时间计算</h3><ul>
<li>访问的页在主存中,且在快表中EAT=a+t</li>
<li>访问的页在主存中,但不在快表中EAT=T+2*(a+t)，（T处理缺页中断时间）</li>
<li>访问的页不在主存中,更不在快表中EAT=T+2*(a+t)</li>
<li>加入缺页率和命中快表的概率：EAT=a+b<em>t+(1-b)</em>[t+f<em>(T+a+t)+(1-f)</em>(a+t)]，（f缺页率）</li>
</ul>
<h2 id="请求分段存储管理系统"><a href="#请求分段存储管理系统" class="headerlink" title="请求分段存储管理系统"></a>请求分段存储管理系统</h2><p>与分页类似</p>
<h2 id="内存管理方式比较"><a href="#内存管理方式比较" class="headerlink" title="内存管理方式比较"></a>内存管理方式比较</h2><p><img src="/2020/03/16/osMemoryManager/neicunguanlibijiao.jpg" alt="图片-内存管理方式比较"></p>
<h2 id="内存管理地址的处理"><a href="#内存管理地址的处理" class="headerlink" title="内存管理地址的处理"></a>内存管理地址的处理</h2><p><img src="/2020/03/16/osMemoryManager/dizhichuli.jpg" alt="图片-内存管理地址的处理"></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤操作系统</p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title='0' data-url='//music/qinjintianxia.jpg'></li>
                        
                    
                </ul>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='false'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#内存管理概念"><span class="toc-number">1.</span> <span class="toc-text">内存管理概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#交换与覆盖"><span class="toc-number">2.</span> <span class="toc-text">交换与覆盖</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#分配管理方式"><span class="toc-number">3.</span> <span class="toc-text">分配管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#连续分配管理方式"><span class="toc-number">3.1.</span> <span class="toc-text">连续分配管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单一连续分配"><span class="toc-number">3.1.1.</span> <span class="toc-text">单一连续分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#固定分区分配"><span class="toc-number">3.1.2.</span> <span class="toc-text">固定分区分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#动态分区分配"><span class="toc-number">3.1.3.</span> <span class="toc-text">动态分区分配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非连续分配管理方式"><span class="toc-number">3.2.</span> <span class="toc-text">非连续分配管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本分页管理方式"><span class="toc-number">3.2.1.</span> <span class="toc-text">基本分页管理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本分段管理方式"><span class="toc-number">3.2.2.</span> <span class="toc-text">基本分段管理方式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#虚拟内存管理"><span class="toc-number">4.</span> <span class="toc-text">虚拟内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#请求分页存储管理系统"><span class="toc-number">4.1.</span> <span class="toc-text">请求分页存储管理系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#管理方式"><span class="toc-number">4.1.1.</span> <span class="toc-text">管理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#页面置换算法"><span class="toc-number">4.1.2.</span> <span class="toc-text">页面置换算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#页面分配策略"><span class="toc-number">4.1.3.</span> <span class="toc-text">页面分配策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抖动"><span class="toc-number">4.1.4.</span> <span class="toc-text">抖动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有效访问时间计算"><span class="toc-number">4.1.5.</span> <span class="toc-text">有效访问时间计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#请求分段存储管理系统"><span class="toc-number">4.2.</span> <span class="toc-text">请求分段存储管理系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存管理方式比较"><span class="toc-number">4.3.</span> <span class="toc-text">内存管理方式比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内存管理地址的处理"><span class="toc-number">4.4.</span> <span class="toc-text">内存管理地址的处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考文献"><span class="toc-number">5.</span> <span class="toc-text">参考文献</span></a></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>

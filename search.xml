<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>README</title>
    <url>/2020/03/15/README/</url>
    <content><![CDATA[<p>用hexo开始写博客，辛辛苦苦写的文章放在这个仓备份一下吧。</p>
<p>如果你对我的博客感兴趣欢迎来访问。</p>
<p>GitHub：<a href="https://lesvay.github.io/">https://lesvay.github.io/</a></p>
<p>Gitee：<a href="https://lesvay.gitee.io/" target="_blank" rel="noopener">https://lesvay.gitee.io/</a></p>
]]></content>
  </entry>
  <entry>
    <title>netApplicationLayer</title>
    <url>/2020/03/15/netApplicationLayer/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>netTransportLayer</title>
    <url>/2020/03/15/netTransportLayer/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>netDataLinkLayer</title>
    <url>/2020/03/15/netDataLinkLayer/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>单位：Frames帧</li>
<li>硬件：交换机、网桥</li>
<li>任务：将网络层传下来的数据报封装成帧</li>
<li>协议：PHP、HDLC</li>
<li>功能</li>
</ul>
<table>
<thead>
<tr>
<th>功能</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>链路管理</td>
<td>链路连接的建立、拆除、分离</td>
</tr>
<tr>
<td>帧定界和帧同步</td>
<td>接收方确定收到的比特流中一帧的开始位置与结束位置</td>
</tr>
<tr>
<td>差错检测</td>
<td>使接收方确定收到的数据就是发送方发送的数据</td>
</tr>
<tr>
<td>透明传输</td>
<td>不管什么样的比特组合都应当在链路中传送</td>
</tr>
</tbody></table>
<h1 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h1><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符计数法</td>
<td>用一个字符表示帧的开始，一个计数字段表示该帧包含的字节数，从而推断出帧的结束位和下一个帧开始位</td>
</tr>
<tr>
<td>字节填充的首尾界符法</td>
<td>从128个ASCII码中的33个键盘不能输入的字符中挑出两个作为起始和结束标志。当传输文件不是键盘输入的,文件中会出现起始和结束标志,因此使用字节填充的首尾界符法，SOH–&gt;ESCx,EOT–&gt;ESCy,ESC–&gt;ESCz</td>
</tr>
<tr>
<td>比特填充的首尾标志法</td>
<td>首尾标志为01111110 文件中每连续5个1,则后面加入1个0</td>
</tr>
<tr>
<td>物理编码违例法</td>
<td>利用物理介质上编码违法方式来区分开始和结束</td>
</tr>
</tbody></table>
<h1 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h1><h2 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h2><ul>
<li><p>奇偶校验码</p>
<ul>
<li>奇校验码:添加一位校验码,使得整个码字里面的1个数是奇数</li>
<li>偶校验码:添加一位校验码,使得整个码字里面的1个数是偶数</li>
</ul>
</li>
<li><p>循环冗余码CRC</p>
<p><img src="/2020/03/15/netDataLinkLayer/crc.jpg" alt="图片-CRC计算过程"></p>
</li>
</ul>
<h2 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h2><p>海明码（Hamming Code）是一个可以有多个校验位，具有检测并纠正一位错误代码的纠错码，所以它也仅用于信道特性比较好的环境中，如以太局域网中，因为如果信道特性不好的情况下，出现的错误通常不是一位。<br>海明码的基本思想是将有效信息按某种规律分成若干组，每组安排一个校验位进行奇偶性测试，然后产生多位检测信息，并从中得出具体的出错位置，最后通过对错误位取反来将其纠正。<br>要采用海明码纠错，需要按以下步骤来进行：计算校验位数→确定校验码位置→确定校验码→实现校验和纠错。</p>
<h1 id="传输机制"><a href="#传输机制" class="headerlink" title="传输机制"></a>传输机制</h1><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><table>
<thead>
<tr>
<th>流量控制</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>停止-等待流量控制</td>
<td>发送方发送一个帧,得到应答后再发送下一个帧,否则一直等待</td>
</tr>
<tr>
<td>滑动窗口流量控制</td>
<td>允许发送多个帧,得到一个应答窗口向前滑动一个帧。当窗口满了,发送方会强行关闭网络层,直到有一个空闲缓冲区出来</td>
</tr>
</tbody></table>
<h2 id="可靠传输机制"><a href="#可靠传输机制" class="headerlink" title="可靠传输机制"></a>可靠传输机制</h2><p>利用传输层TCP</p>
<h2 id="滑动窗口机制"><a href="#滑动窗口机制" class="headerlink" title="滑动窗口机制"></a>滑动窗口机制</h2><table>
<thead>
<tr>
<th>协议</th>
<th>窗口状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>停止-等待协议</td>
<td>发送窗口=1,接收窗口=1</td>
<td>可靠传输（确认：发送确认帧超时，重传：一段时间没有响应就会重新发送）；数据帧破坏（如果帧正确则接收，不正确则丢弃，发送方未收到确认帧等待一段时间后再次发送）；确认帧被破坏（发送方在帧中加入标识，接收方判断是新帧还是旧帧）</td>
</tr>
<tr>
<td>后退N帧协议(GBN)</td>
<td>发送窗口&gt;1,接收窗口=1</td>
<td>滑动窗口中，某帧出错，则其及后续帧丢弃，发送方重传</td>
</tr>
<tr>
<td>选择重传协议(SR)</td>
<td>发送窗口&gt;1,接收窗口&gt;1</td>
<td>某帧出错，其后续帧存入接收方缓存中，发送方重发出错帧</td>
</tr>
</tbody></table>
<h1 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h1><p>介质访问控制(medium access control)简称MAC。 是解决当局域网中共用信道的使用产生竞争时，如何分配信道的使用权问题。</p>
<h2 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h2><ul>
<li>频分多路复用：道路变宽</li>
<li>时分多路复用：时间分割</li>
<li>波分多路复用：波段分割</li>
<li>码分多路复用：碎片数据✖码片向量，-1表示比特0，1表示比特1，0表示没有数据</li>
</ul>
<h2 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h2><ul>
<li><p>随机接入(争用型)</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ALOHA</td>
<td>不经过任何检测就发送数据，没有收到确认则继续发送</td>
</tr>
<tr>
<td>CSMA</td>
<td>1-坚持CSMA：发送节点监听到空闲时，立即发送数据，否则继续监听；p-坚持CSMA：发送节点监听到空闲时，依概率p发送数据，以概率（1-p）延迟一段时间并重新监听；非坚持CSMA：发送节点一旦监听到空闲时，就立即发送数据，否则延迟一段时间重新监听。</td>
</tr>
<tr>
<td>CSMA/CD</td>
<td>过程：发送数据之前检测总线是否有其他计算机发送数据，若无则发送数据，发送时继续监听，若出现冲突则随机时间后继续发送，适合有线网络，是被动型。</td>
</tr>
<tr>
<td>CSMA/CA</td>
<td>过程：发送数据之前检测总线是否有其他计算机发送数据，若无则发送数据，一段时间后检查对方是否发回帧确认，若没有继续重发，适合无线型网络，是主动型。</td>
</tr>
</tbody></table>
</li>
<li><p>受控接入：不能随便发送某数据，得到某种东西才能发送</p>
</li>
</ul>
<h2 id="轮询访问介质访问控制"><a href="#轮询访问介质访问控制" class="headerlink" title="轮询访问介质访问控制"></a>轮询访问介质访问控制</h2><ul>
<li>过程：用户不能随机发送数据，通过一个集中控制的监控站经过轮询过程后再决定信道的分配</li>
<li>令牌环局域网</li>
<li>令牌传递协议</li>
</ul>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p>工作原理：采用总线拓扑结构，无连接工作方式，不对发送的数据进行编号，也不要求对方发送确认。</p>
<p>MAC帧如下：</p>
<p><img src="/2020/03/15/netDataLinkLayer/2020-03-15-netDataLinkLayer%5Cmaczhen" alt="图片-MAC帧"></p>
<ul>
<li><p>前导码：前同步符、帧开始定界符</p>
</li>
<li><p>目的地址、源地址：目的地址前八位最后一位为0，发给某一工作站；最后一位为1，其余不全为1，发给一组工作站；全为1，广播地址，发给所有工作站。</p>
</li>
</ul>
<p>传输介质，其中10指10Mbit/s，base基带信号</p>
<p><img src="/2020/03/15/netDataLinkLayer/10base.jpg" alt="图片-各种以太网"></p>
<p>高速以太网：100Base-T以太网、吉比特以太网、10吉比特以太网</p>
<p>无线局域网</p>
<ul>
<li>有固定基础设施的无线局域网（BSS基站）</li>
<li>无固定基础设施的无线局域网（自主网络）</li>
</ul>
<p>IEEE802.11</p>
<ul>
<li>物理层：跳频扩频（FHSS）、直接序列扩频（DSS）、红外线（IR）</li>
<li>MAC层：分布协调功能（DCF）、点协调功能（PCF）、CSMA/CD、确认机制</li>
</ul>
<h3 id="令牌环网"><a href="#令牌环网" class="headerlink" title="令牌环网"></a>令牌环网</h3><ul>
<li>当网络空闲时，环路中只有令牌在网络中循环传递</li>
<li>令牌传递到数据要发送的节点，修改令牌标志位，附加要传输的数据</li>
<li>数据延环路继续传输，直到遇到接收节点</li>
<li>接收节点复制数据，令牌继续传，传回发送节点</li>
<li>发送节点检查数据是否出错，出错重传，没有就产生一个新令牌，继续在令牌环上游荡</li>
</ul>
<h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><h3 id="PPP"><a href="#PPP" class="headerlink" title="PPP"></a>PPP</h3><p>是面向字节的协议，只负责检错、是不可靠传输、点对点通讯、全双工链路。</p>
<p>过程：用户拨号接入ISP，调制解调器对拨号做出确认，并建立一条物理连接，计算机向路由器发送一系列LCP分组，网络控制协议NCP给个人计算机分配一个临时IP，接入网络成功。</p>
<p><img src="/2020/03/15/netDataLinkLayer/ppp.jpg" alt="图片-PPP"></p>
<h3 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h3><p>是面向比特的协议</p>
<p>基本配置</p>
<ul>
<li>非平衡配置：由一个主机控制整个链路</li>
<li>平衡配置：链路两端的两个站是复合站，每个复合站可以平等的发起数据，不需要得到对方复合站的允许</li>
</ul>
<p><img src="/2020/03/15/netDataLinkLayer/HDCL.jpg" alt="图片-HDCL"></p>
<h1 id="物理设备"><a href="#物理设备" class="headerlink" title="物理设备"></a>物理设备</h1><h2 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h2><p>网桥至少有两个端口，每个端口与一个网段相连，接收到数据存储到缓存中，若为出错，则查找转发表从别的端口转发出去</p>
<ul>
<li>优点：过滤通信量、扩大物理范围、提高可靠性、可连接至不同物理层、不同MAC层和不同速率的以太网上</li>
<li>缺点：存储转发增加了时延、在MAC子层并没有流量控制功能、具有不同MAC子层的网段桥接在一起时时延更大、适合用户数量不多，通信量小的局域网</li>
</ul>
<table>
<thead>
<tr>
<th>分类</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>透明网桥</td>
<td>指不知道要经过哪几个网桥，自主学习转发表，新增或更新（源地址、进入的接口和时间）</td>
</tr>
<tr>
<td>源选径网桥</td>
<td>对外广播，选择最佳路由</td>
</tr>
</tbody></table>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><ul>
<li>实质：多端口网桥</li>
<li>直通式交换：只检查帧的目的地址，收到后立马被转发出去</li>
<li>存储转发式交换：先存储在高速缓存中，检查数据是否正确，查找转发表，转发</li>
</ul>
<h2 id="网桥与交换机对比"><a href="#网桥与交换机对比" class="headerlink" title="网桥与交换机对比"></a>网桥与交换机对比</h2><ul>
<li>网桥有两个端口，交换机多个</li>
<li>网桥连接到局域网网段，交换机连接主机或HUB</li>
<li>网桥一对计算机同时通讯，交换机允许多对</li>
<li>网桥存储转发，以太网有直通转发和存储转发</li>
</ul>
<h2 id="冲突域与广播域总结"><a href="#冲突域与广播域总结" class="headerlink" title="冲突域与广播域总结"></a>冲突域与广播域总结</h2><p><img src="/2020/03/15/netDataLinkLayer/chongtu.jpg" alt="图片-冲突域与广播域"></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤计算机网络</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>dataLinkLayer</tag>
      </tags>
  </entry>
  <entry>
    <title>netNetworkLayer</title>
    <url>/2020/03/15/netNetworkLayer/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>物理层的相关知识点</title>
    <url>/2020/03/15/netPhysicalLayer/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>单位：Bits比特</li>
<li>硬件：集线器、中继器</li>
<li>任务：透明的传输比特流</li>
<li>功能：为数据端设备提供传输数据的通路</li>
</ul>
<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><table>
<thead>
<tr>
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>信号</td>
<td>数据的电气或电磁表现（基带信号：数字信号0和1；宽带信号：模拟信号）</td>
</tr>
<tr>
<td>信源</td>
<td>信息的源泉</td>
</tr>
<tr>
<td>信道</td>
<td>信息传送的道路</td>
</tr>
<tr>
<td>信宿</td>
<td>信息的归宿地</td>
</tr>
<tr>
<td>带宽</td>
<td>通信线路允许通过的信号频带范围Hz、 网络通信线路所能传输数据的能力bit/s</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>通信方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>同步</td>
<td>接收端和发送端时钟频率相同</td>
</tr>
<tr>
<td>异步</td>
<td>以字节为单位 增加一个起始比特和终止比特 可以任意间隔发送下一个字节</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>通信模式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>单工</td>
<td>只有一个方向</td>
</tr>
<tr>
<td>半双工</td>
<td>两个方向但不能同时进行</td>
</tr>
<tr>
<td>全双工</td>
<td>两个方向可以同时进行</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>速率</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>波特率（码元传输速率）</td>
<td>脉冲个数哦或信号变化的次数 表示单位时间内数字通信系统所传输的码元个数</td>
</tr>
<tr>
<td>比特率（信息传输速率）</td>
<td>单位时间内数字通信系统所传输的二进制码元个数 一码元通过变化表示0和1，后来可以携带4比特</td>
</tr>
</tbody></table>
<h1 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h1><h2 id="奈奎斯特定理"><a href="#奈奎斯特定理" class="headerlink" title="奈奎斯特定理"></a>奈奎斯特定理</h2><p>奈奎斯特定律是一种信息速率，根据奈奎斯特定律，信道的极限速率（码元速率）等于信道带宽（低通信道）等于信道带宽（理论状态）。</p>
<p>在理想低通的条件下(没有噪声)，带宽有限的信道，极限码元速率是2W 波特。<br>W是信道带宽，单位是Hz。每个码元离散状态的数目用V表示，则极限传输速率 = 2Wlog2V</p>
<h2 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h2><p>香农定理是指在带宽受限且有高斯白噪声干扰的信道极限传输速率。</p>
<p>信道的极限传输速率 = Wlog2(1+S/N)Wlog2(1+S/N)<br>具体来说，香农定理主要围绕的是S/N的计算考察，S表示信道传输信号的平均功率。</p>
<h1 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h1><h2 id="编码-模拟变数字"><a href="#编码-模拟变数字" class="headerlink" title="编码(模拟变数字)"></a>编码(模拟变数字)</h2><p>数字数据编码为数字信号</p>
<p>模拟数据编码为数字信号：采样-&gt;量化-&gt;编码</p>
<p><img src="/2020/03/15/netPhysicalLayer/bianma.jpg" alt="图片-编码方式"></p>
<table>
<thead>
<tr>
<th>编码方式</th>
<th>规则</th>
</tr>
</thead>
<tbody><tr>
<td>非归零码(NRZ)</td>
<td>低电平0，高电平1</td>
</tr>
<tr>
<td>曼彻斯特编码</td>
<td>中间跳变，从高到低跳变表示“1”，从低到高跳变表示“0”</td>
</tr>
<tr>
<td>差分曼彻斯特编码</td>
<td>开始时跳变为“0”，无跳变为“1”。中间跳变，初始为1</td>
</tr>
</tbody></table>
<h2 id="调制-数字变模拟"><a href="#调制-数字变模拟" class="headerlink" title="调制(数字变模拟)"></a>调制(数字变模拟)</h2><p>数字数据编码为模拟信号</p>
<p>模拟数据编码为模拟信号</p>
<table>
<thead>
<tr>
<th>调制名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>带通调制(载波调制)</td>
<td>改变频率范围，调幅、调频、调相</td>
</tr>
<tr>
<td>基带调制</td>
<td>改变波形</td>
</tr>
</tbody></table>
<h1 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h1><p><img src="/2020/03/15/netPhysicalLayer/shujuchuanshu.jpg" alt="图片-数据传输方式"></p>
<table>
<thead>
<tr>
<th>传输方式</th>
<th>描述</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>电路交换</td>
<td>建立一条被双方占有的物理通路</td>
<td>通信时延小、实时性强、有序传输、使用范围广、控制简单、避免冲突</td>
<td>建立连接时间长、信道利用率低、缺乏统一标准、灵活性差</td>
</tr>
<tr>
<td>报文交换</td>
<td>数据交换单位是报文，报文携带有目的地址和源地址等信息，采用存储转发方式</td>
<td>无需建立连接、动态分配线路、提高可靠性、提高线路利用率、提供多目标服务</td>
<td>有转发时延 要求网络节点有较大的存储缓存空间</td>
</tr>
<tr>
<td>分组交换</td>
<td>仍采用存储转发方式，将较长的报文分割为若干个较短的分组，逐个的转发出去</td>
<td>加速传输 简化存储管理 减少出错率和重发数据量</td>
<td>存在传输时延 可能出现失序、丢失、重复分组等现象</td>
</tr>
</tbody></table>
<h1 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h1><table>
<thead>
<tr>
<th>报文</th>
<th>过程</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>数据报</td>
<td>主机A先将分组逐个的发往与它相连的交换机1,1将A发来的分组缓存 1查找转发表,不同时刻转发表的内容可能不同,或转发给234 直到分组到达主机B</td>
<td>发送分组前无需建立连接 分组首部包含的是目的地址 尽最大努力交付,不保证可靠性,无序到达 减少延迟,提高了吞吐量 不独占某一链路,资源利用率高</td>
</tr>
<tr>
<td>虚电路</td>
<td>在发送前和主机建立一条虚连接 主机A发出特殊呼叫请求,B发送呼叫应答进行确认,虚电路建立成功 分组走相同路径 传输结束,主机发送释放请求</td>
<td>通讯必须建立连接 走相同路径,按序到达 分组首部包含的是虚电路标识符 路由失效时受影响</td>
</tr>
</tbody></table>
<h1 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h1><p>传输介质在物理层之下,不属于模型中</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>机械特性、电气特性、功能特性</p>
<h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><h3 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h3><p>无屏蔽双绞线</p>
<ul>
<li>标准<ul>
<li>标准568A：绿白-1，绿-2，橙白-3，蓝-4，蓝白-5，橙-6，棕白-7，棕-8。</li>
<li>标准568B：橙白-1，橙-2，绿白-3，蓝-4，蓝白-5，绿-6，棕白-7，棕-8。</li>
</ul>
</li>
<li>平行线：两端相同</li>
<li>交叉线：一端568A,一段568B</li>
</ul>
<p>屏蔽双绞线：加了一层金属网,较硬</p>
<h3 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h3><p>同轴电缆（CoaxialCable）是指有两个同心导体，而导体和屏蔽层又共用同一轴心的电缆。</p>
<h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><p>单模光纤：使用昂贵的半导体激光器,不发生反射,适合远距离传输</p>
<p>多模光纤：使用发光二极管,传输过程中会逐渐展宽失真,适合近距离传输</p>
<h1 id="物理设备"><a href="#物理设备" class="headerlink" title="物理设备"></a>物理设备</h1><h2 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h2><ul>
<li>放大器放大的是模拟信号,中继器放大数字信号</li>
</ul>
<h2 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h2><ul>
<li>计算机连接到集线器上,集线器对信号进行收发广播,每台电脑都会收到,不是发给自己的不予理睬</li>
<li>集线器不能隔离冲突域</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤计算机网络</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>physicalLayer</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络基本概念</title>
    <url>/2020/03/15/netBasicConcept/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>一些互联自治的计算机系统的集合</p>
<h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><h2 id="物理组成"><a href="#物理组成" class="headerlink" title="物理组成"></a>物理组成</h2><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><ul>
<li>主机</li>
<li>通讯处理机（前端处理器）</li>
<li>通讯线路<ul>
<li>有线</li>
<li>无线</li>
</ul>
</li>
<li>交换设备<ul>
<li>交换机</li>
<li>路由器</li>
<li>etc<h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3>实现资源共享的软件和工具，如：QQ</li>
</ul>
</li>
</ul>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>一种规则</p>
<h2 id="工作方式组成"><a href="#工作方式组成" class="headerlink" title="工作方式组成"></a>工作方式组成</h2><h3 id="边缘部分"><a href="#边缘部分" class="headerlink" title="边缘部分"></a>边缘部分</h3><ul>
<li>组成：所有连接在互联网上供用户直接使用的主机</li>
<li>作用：通信、资源共享<h3 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h3></li>
<li>组成大量的网络和连接这些网络的路由器</li>
<li>作用：提供连通性和交换服务</li>
</ul>
<h2 id="功能组成"><a href="#功能组成" class="headerlink" title="功能组成"></a>功能组成</h2><h3 id="通讯子网"><a href="#通讯子网" class="headerlink" title="通讯子网"></a>通讯子网</h3><ul>
<li>组成：传输介质、通信设备、响应的网络协议</li>
<li>作用：提供数据传输、交换和控制能力，实现信息通讯<h3 id="资源子网"><a href="#资源子网" class="headerlink" title="资源子网"></a>资源子网</h3></li>
<li>组成：主机、终端、各类软件资源和信息资源</li>
<li>作用：负责全网的数据处理业务，像网络用户提供各种网络资源与服务</li>
</ul>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ul>
<li>数据通信（最基本，最重要）</li>
<li>资源共享</li>
<li>分布式处理</li>
<li>信息综合处理</li>
<li>负载均衡</li>
<li>提高可靠性</li>
</ul>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><h2 id="分布范围"><a href="#分布范围" class="headerlink" title="分布范围"></a>分布范围</h2><ul>
<li>广域网</li>
<li>城域网</li>
<li>局域网</li>
<li>个人区域网</li>
</ul>
<h2 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h2><ul>
<li><p>星形网络</p>
</li>
<li><p>总线型网络</p>
</li>
<li><p>环形网络</p>
</li>
<li><p>网状形网络</p>
</li>
</ul>
<h2 id="传输技术"><a href="#传输技术" class="headerlink" title="传输技术"></a>传输技术</h2><ul>
<li>广播式网络</li>
<li>点对点网络</li>
</ul>
<h2 id="使用者"><a href="#使用者" class="headerlink" title="使用者"></a>使用者</h2><ul>
<li>公用网</li>
<li>专用网<h2 id="数据交换技术"><a href="#数据交换技术" class="headerlink" title="数据交换技术"></a>数据交换技术</h2></li>
<li>电路交换网</li>
<li>报文交换网</li>
<li>分组交换网</li>
</ul>
<h1 id="相关组织"><a href="#相关组织" class="headerlink" title="相关组织"></a>相关组织</h1><ul>
<li>ISO国际标准化组织</li>
<li>ITU国际电信联盟</li>
<li>IEEE美国电气和电子工程师协会</li>
</ul>
<h1 id="参考模型"><a href="#参考模型" class="headerlink" title="参考模型"></a>参考模型</h1><h2 id="ISO-OSI"><a href="#ISO-OSI" class="headerlink" title="ISO/OSI"></a>ISO/OSI</h2><ul>
<li>应用层</li>
<li>表示层</li>
<li>会话层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
<h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><ul>
<li>应用层</li>
<li>传输层</li>
<li>互联网层</li>
<li>网络接收层</li>
</ul>
<h2 id="5层模型"><a href="#5层模型" class="headerlink" title="5层模型"></a>5层模型</h2><ul>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
<h1 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h1><h2 id="时延（总时延为四者之和）"><a href="#时延（总时延为四者之和）" class="headerlink" title="时延（总时延为四者之和）"></a>时延（总时延为四者之和）</h2><ul>
<li>发送时延（传输时延）<ul>
<li>主机或路由器发送数据所需要的时间，从第一位开始发送到最后一位发送完毕</li>
<li>发送时延=数据帧长度（bit）/发送速率（bit/s）</li>
</ul>
</li>
<li>传播时延<ul>
<li>电磁波在信道中传播一定的距离所需要的时间</li>
<li>传播时延=信道长度（m）/电磁波在信道上的传播速度（m/s）</li>
</ul>
</li>
<li>处理时延<ul>
<li>主机在路由器在接收到分组时进行处理所需要的时间</li>
</ul>
</li>
<li>排队时延<ul>
<li>进入路由器在输入队列排队等待处理</li>
<li>确定转发接口后，在输出队列等待转发</li>
</ul>
</li>
</ul>
<h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><ul>
<li>时延带宽积=传播时延*带宽</li>
</ul>
<h2 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h2><ul>
<li>从发送方开始发送数据，到发送方收到接收方的确认消息</li>
</ul>
<h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><ul>
<li>信道利用率<ul>
<li>某信道有%的时间是被利用的</li>
</ul>
</li>
<li>网络利用率<ul>
<li>全网络信道利用率加权平均值</li>
</ul>
</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤计算网络</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>conception</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络参考模型</title>
    <url>/2020/03/15/networkReferenceModel/</url>
    <content><![CDATA[<p>将网络分层有利于让整个流程更加清晰，复杂的问题简单化。计算机网络参考模型常见的有三种：</p>
<p><img src="/2020/03/15/networkReferenceModel/cankaomoxing.jpg" alt="图片-三个参考模型"></p>
<p><a href="https://wenku.baidu.com/view/f7593b88974bcf84b9d528ea81c758f5f61f29f4.html" target="_blank" rel="noopener">图片改编自百度文库</a></p>
<h1 id="OSI七层参考模型"><a href="#OSI七层参考模型" class="headerlink" title="OSI七层参考模型"></a>OSI七层参考模型</h1><p>OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO组织在1985年研究的网络互联模型。该体系结构标准定义了网络互联的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层和应用层），即OSI开放系统互连参考模型。</p>
<p>OSI 将计算机网络体系结构划分为七层，每层都可以提供抽象良好的接口，能够提供面向连接和无连接两种通信服务机制。是一种使各种不同的计算机和网络在世界范围内实现互联的标准框架。OSI 虽然层级多，由于功能细化，便于排障。不过由于种种原因，没有得以推行，只能作为一种适合学习的模型。</p>
<p><img src="/2020/03/15/networkReferenceModel/OSItujie.jpg" alt="图片-图解OSI"></p>
<p><a href="http://www.colasoft.com.cn/download/document.php" target="_blank" rel="noopener">图片来自科来</a></p>
<h1 id="TCP-IP四层参考模型"><a href="#TCP-IP四层参考模型" class="headerlink" title="TCP/IP四层参考模型"></a>TCP/IP四层参考模型</h1><p>TCP/IP参考模型是计算机网络的祖父ARPANET和其后继的因特网使用的参考模型。ARPANET是由美国国防部DoD（U.S.Department of Defense）赞助的研究网络。逐渐地它通过租用的电话线连结了数百所大学和政府部门。当无线网络和卫星出现以后，现有的协议在和它们相连的时候出现了问题，所以需要一种新的参考体系结构。</p>
<p>这个体系结构在它的两个主要协议出现以后，即先有的TCP和IP协议，后有的模型，被称为TCP/IP参考模型（TCP/IP reference model）。基于TCP/IP的参考模型将协议分成四个层次，它们分别是：网络访问层、网际互联层（主机到主机）、传输层、和应用层，能够提供面向连接和无连接两种通信服务机制。由于出现的早，更为众人所采用，是偏向于实践的模型。</p>
<h1 id="教学五层模型"><a href="#教学五层模型" class="headerlink" title="教学五层模型"></a>教学五层模型</h1><p>为了便于学习，便出现了TCP/IP模型分化出来的模型，即教学五层模型。这个模型在工业界是没有的，主要是方便教学使用。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>对象</th>
<th>单位</th>
<th>功能</th>
<th>协议</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>用户对用户</td>
<td></td>
<td>文件传输、访问和管理、电子邮件服务</td>
<td>FTP 、SMTP、POP3、HTTP、DNS、TFTP、SNMP</td>
</tr>
<tr>
<td>传输层</td>
<td>应用对应用、进程对进程</td>
<td>(segments段)报文段TCP、用户数据报UDP</td>
<td>为端到端连接提供可靠的传输服务，为端到端连接提供流量控制、差错控制、服务质量等管理服务，提供应用进程间的逻辑通信，差错检测，提供无连接和面向连接的服务，复用和分用，TCP:连接管理 流量控制与拥塞控制</td>
<td>TCP、UDP</td>
</tr>
<tr>
<td>网络层</td>
<td>主机对主机</td>
<td>Packets包：数据报</td>
<td>组包和拆包、路由选择、分组转发、拥塞控制、异构网络互连</td>
<td>ICMP、ARP、RARP、IP、IGMP</td>
</tr>
<tr>
<td>数据链路层</td>
<td></td>
<td>Frames帧</td>
<td>链路管理、帧定界和帧同步、差错检测、透明传输</td>
<td>PHP、HDLC</td>
</tr>
<tr>
<td>物理层</td>
<td></td>
<td>Bits比特</td>
<td>提供传输数据的通路</td>
<td></td>
</tr>
</tbody></table>
<p>以前学习的时候参考天勤做了一个思维大纲图，欢迎来看，<a href="https://mubu.com/doc/5PAGbmxGYrg" target="_blank" rel="noopener">计算机网络</a></p>
<h1 id="数据封装拆解过程"><a href="#数据封装拆解过程" class="headerlink" title="数据封装拆解过程"></a>数据封装拆解过程</h1><p>从应用层的数据到物理层的比特率，每向下一层数据都会被进一步封装，就像洋葱一样，只有它的芯才是真正的要表达的数据，那一层一层的是传输时的信息，比如下一步要传递给谁？它的地址是多少？</p>
<p><img src="/2020/03/15/networkReferenceModel/fengzhuang.png" alt="图片-数据封装"></p>
<p><a href="https://wenku.baidu.com/view/f7593b88974bcf84b9d528ea81c758f5f61f29f4.html" target="_blank" rel="noopener">图片改编自百度文库</a></p>
<p>现实生活中，我们不可能一根网线就可把数据发送给对方，中间要经过多个路由器、交换机。</p>
<p><img src="/2020/03/15/networkReferenceModel/2020-03-15-networkReferenceModel%5Cliudongguocheng.png" alt="图片-数据流动过程"></p>
<p><a href="https://wenku.baidu.com/view/f7593b88974bcf84b9d528ea81c758f5f61f29f4.html" target="_blank" rel="noopener">图片改编自百度文库</a></p>
<p>每次需要经过交换机时MAC头部就会被拆解，并被更换为新的MAC头部。每次需要经过路由器时，MAC头部被拆解并向上提交至网络层，IP头部也会被拆解并更换为新的IP头部，然后向下提交加上新的MAC头部。以此类推，最后到达了目标主机。再逐层拆解最后洋葱被拨的只剩芯了，这也是我们真正想要发送的数据。</p>
<p><img src="/2020/03/15/networkReferenceModel/jiefeng.png" alt="图片-数据解封过程"></p>
<p><a href="https://wenku.baidu.com/view/f7593b88974bcf84b9d528ea81c758f5f61f29f4.html" target="_blank" rel="noopener">图片改编自百度文库</a></p>
<p>最后这是一张表述每一层所对应物理设备，当然这并不是绝对的，因为现实生活中也会有网络层交换机。</p>
<p><img src="/2020/03/15/networkReferenceModel/shebei.png" alt="图片-对应设备"></p>
<p><a href="https://wenku.baidu.com/view/f7593b88974bcf84b9d528ea81c758f5f61f29f4.html" target="_blank" rel="noopener">图片改编自百度文库</a></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://wenku.baidu.com/view/f7593b88974bcf84b9d528ea81c758f5f61f29f4.html" target="_blank" rel="noopener">百度文库-01-计算机网络参考模型</a></p>
<p><a href="[https://baike.baidu.com/item/OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B](https://baike.baidu.com/item/OSI参考模型)">百度百科-OSI参考模型</a></p>
<p><a href="https://www.jianshu.com/p/348df1dde9bd" target="_blank" rel="noopener">简书-计算机网络-参考模型</a></p>
<p><a href="https://zhidao.baidu.com/question/573470632.html" target="_blank" rel="noopener">百度知道</a></p>
<p><a href="[https://baike.baidu.com/item/TCP%2FIP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B](https://baike.baidu.com/item/TCP%2FIP参考模型)">百度百科-TCP/IP参考模型</a></p>
<p><a href="https://www.cnblogs.com/lsdb/p/9564094.html" target="_blank" rel="noopener">博客园-努力改个网名</a></p>
<p><a href>天勤计算机网络</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>OSI - TCP/IP</tag>
        <tag>五层模型</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS域名解析过程</title>
    <url>/2020/03/14/dnsProcess/</url>
    <content><![CDATA[<p>DNS域名解析过程大致分为两种：</p>
<h1 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h1><p>所谓迭代查询是指：根域名服务器收到查询请求，要么给出查询结果，要么告诉本地域名服务器下一步向哪个域名服务器进行查询。</p>
<p>主要是本地域名服务器向根域名服务器查询信息时所采用的方式。</p>
<h1 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h1><p>所谓递归查询是指：本地域名服务器只请求一次，后面几次都是在其他几个域名服务器之间进行的。</p>
<p>主要是主机向本地域名服务器查询信息时所采用的方式。当主机需要查询IP时，本地域名服务器不知道域名所对应的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器发送查询请求报文，而不是让主机自己进行下一步查询。</p>
<h1 id="访问度娘的过程"><a href="#访问度娘的过程" class="headerlink" title="访问度娘的过程"></a>访问度娘的过程</h1><pre><code>①本机向local dns请求www.baidu.com
②local dns向根域请求www.baidu.com，根域返回com.域的服务器IP
③向com.域请求www.baidu.com，com.域返回baidu.com域的服务器IP
④向baidu.com请求www.baidu.com，返回cname www.a.shifen.com和a.shifen.com域的服务器IP
⑤向root域请求www.a.shifen.com
⑥向com.域请求www.a.shife.com
⑦向shifen.com请求
⑧向a.shifen.com域请求
⑨拿到www.a.shifen.com的IP
⑩localdns返回本机www.baidu.com cname www.a.shifen.com 以及 www.a.shifen.com的IP</code></pre><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/crazw/article/details/8986504" target="_blank" rel="noopener">CSDN-Crazw_jia</a></p>
<p><a href="https://blog.csdn.net/Daputao_net/article/details/81203531" target="_blank" rel="noopener">CSDN-Daputao_net</a></p>
<p><a href="https://www.cnblogs.com/qingdaofu/p/7399670.html" target="_blank" rel="noopener">博客园-皈依之路</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP的头信息</title>
    <url>/2020/03/14/httpHeads/</url>
    <content><![CDATA[<p>HTTP头信息主要包括通用头、请求头、响应头、实体头。</p>
<p><img src="/2020/03/14/httpHeads/qingqiutou.png" alt="qingqiutou"><br><img src="/2020/03/14/httpHeads/xiangyingtou.png" alt="xiangyingtou"></p>
<h1 id="通用头部"><a href="#通用头部" class="headerlink" title="通用头部"></a>通用头部</h1><p>通用头域包含请求和响应消息都支持的头域，通用头域包含缓存头部Cache-Control、Pragma及信息性头部Connection、Date、Transfer-Encoding、Update、Via。</p>
<table>
<thead>
<tr>
<th align="left">应答头</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Cache-Control</td>
<td align="left">指定请求和响应遵循的缓存机制</td>
</tr>
<tr>
<td align="left">Pragma</td>
<td align="left">用来包含实现特定的指令</td>
</tr>
<tr>
<td align="left">Connection</td>
<td align="left">表示是否需要持久连接</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">指定请求和响应遵循的缓存机制</td>
</tr>
<tr>
<td align="left">Cache-Control</td>
<td align="left">表示消息发送的时间</td>
</tr>
<tr>
<td align="left">Transfer-Encoding</td>
<td align="left">服务器表明自己对本响应消息体作了怎样的编码</td>
</tr>
<tr>
<td align="left">Upgrade</td>
<td align="left">指定另一种可能完全不同的协议</td>
</tr>
<tr>
<td align="left">Via</td>
<td align="left">列出该响应经过了哪些代理服务器，他们用什么协议发送的请求</td>
</tr>
</tbody></table>
<h1 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h1><p>请求头用于说明是谁或什么在发送请求、请求源于何处，或者客户端的喜好及能力。服务器可以根据请求头部给出的客户端信息，试着为客户端提供更好的响应。请求头域可能包含下列字段Accept、Accept-Charset、Accept- Encoding、Accept-Language、Authorization、From、Host、If-Modified-Since、If-Match、If-None-Match、If-Range、If-Range、If-Unmodified-Since、Max-Forwards、Proxy-Authorization、Range、Referer、User-Agent。对请求头域的扩展要求通讯双方都支持，如果存在不支持的请求头域，一般将会作为实体头域处理。</p>
<table>
<thead>
<tr>
<th align="left">应答头</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Accept</td>
<td align="left">告诉WEB服务器自己接受什么介质类型</td>
</tr>
<tr>
<td align="left">Accept-Charset</td>
<td align="left">浏览器告诉服务器自己能接收的字符集</td>
</tr>
<tr>
<td align="left">Accept-Encoding</td>
<td align="left">浏览器申明自己接收的编码方法</td>
</tr>
<tr>
<td align="left">Accept-Language</td>
<td align="left">浏览器申明自己接收的语言</td>
</tr>
<tr>
<td align="left">Authorization</td>
<td align="left">客户端接收到服务器的WWW-Authenticate响应时，用该头部来回应服务器自己的身份验证信息</td>
</tr>
<tr>
<td align="left">If-Match</td>
<td align="left">如果对象的ETag没有改变，即对象没有改变，才执行请求的动作</td>
</tr>
<tr>
<td align="left">If-None-Match</td>
<td align="left">如果对象的ETag改变了，才执行请求的动作</td>
</tr>
<tr>
<td align="left">If-Modified-Since</td>
<td align="left">如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作，否则返回代码304，告诉浏览器该对象没有修改</td>
</tr>
<tr>
<td align="left">If-Unmodified-Since</td>
<td align="left">如果请求的对象在该头部指定的时间之后没修改过，才执行请求的动作</td>
</tr>
<tr>
<td align="left">If-Range</td>
<td align="left">浏览器告诉 WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分给我，如果对象改变了，就把整个对象给我</td>
</tr>
<tr>
<td align="left">Range</td>
<td align="left">浏览器告诉 WEB 服务器自己想取对象的哪部分</td>
</tr>
<tr>
<td align="left">Proxy-Authenticate</td>
<td align="left">代理服务器响应浏览器，要求其提供代理身份验证信息</td>
</tr>
<tr>
<td align="left">Host</td>
<td align="left">客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号</td>
</tr>
<tr>
<td align="left">Referer</td>
<td align="left">浏览器向WEB 服务器表明自己是从哪个网页URL获得点击当前请求中的网址/URL</td>
</tr>
<tr>
<td align="left">User-Agent</td>
<td align="left">浏览器表明自己的身份</td>
</tr>
</tbody></table>
<h1 id="响应头部"><a href="#响应头部" class="headerlink" title="响应头部"></a>响应头部</h1><p>响应头向客户端提供一些额外信息，比如谁在发送响应、响应者的功能，甚至与响应相关的一些特殊指令。这些头部有助于客户端处理响应，并在将来发起更好的请求。响应头域包含Age、Location、Proxy-Authenticate、Public、Retry- After、Server、Vary、Warning、WWW-Authenticate。对响应头域的扩展要求通讯双方都支持，如果存在不支持的响应头域，一般将会作为实体头域处理。</p>
<table>
<thead>
<tr>
<th align="left">应答头</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Age</td>
<td align="left">当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了</td>
</tr>
<tr>
<td align="left">Server</td>
<td align="left">WEB 服务器表明自己是什么软件及版本等信息</td>
</tr>
<tr>
<td align="left">Accept-Ranges</td>
<td align="left">WEB服务器表明自己是否接受获取其某个实体的一部分的请求</td>
</tr>
<tr>
<td align="left">Vary</td>
<td align="left">WEB服务器用该头部的内容告诉 Cache 服务器，在什么条件下才能用本响应所返回的对象响应后续的请求</td>
</tr>
</tbody></table>
<h1 id="实体头部"><a href="#实体头部" class="headerlink" title="实体头部"></a>实体头部</h1><p>实体头部提供了有关实体及其内容的大量信息，从有关对象类型的信息，到能够对资源使用的各种有效的请求方法。总之，实体头部可以告知接收者它在对什么进行处理。请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括信息性头部Allow、Location，内容头部Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type，缓存头部Etag、Expires、Last-Modified、extension-header。</p>
<table>
<thead>
<tr>
<th align="left">应答头</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Allow</td>
<td align="left">服务器支持哪些请求方法</td>
</tr>
<tr>
<td align="left">Location</td>
<td align="left">表示客户应当到哪里去提取文档，用于将接收端定位到资源的位置（URL）上</td>
</tr>
<tr>
<td align="left">Content-Base</td>
<td align="left">解析主体中的相对URL时使用的基础URL</td>
</tr>
<tr>
<td align="left">Content-Encoding</td>
<td align="left">WEB服务器表明自己使用了什么压缩方法压缩响应中的对象</td>
</tr>
<tr>
<td align="left">Content-Language</td>
<td align="left">WEB 服务器告诉浏览器理解主体时最适宜使用的自然语言</td>
</tr>
<tr>
<td align="left">Content-Length</td>
<td align="left">WEB服务器告诉浏览器自己响应的对象的长度或尺寸</td>
</tr>
<tr>
<td align="left">Content-Location</td>
<td align="left">资源实际所处的位置</td>
</tr>
<tr>
<td align="left">Content-MD5</td>
<td align="left">主体的MD5校验和</td>
</tr>
<tr>
<td align="left">Content-Range</td>
<td align="left">传送的范围</td>
</tr>
<tr>
<td align="left">Content-Type</td>
<td align="left">WEB 服务器告诉浏览器自己响应的对象的类型</td>
</tr>
<tr>
<td align="left">Etag</td>
<td align="left">供WEB服务器判断一个对象是否改变了</td>
</tr>
<tr>
<td align="left">Expires</td>
<td align="left">WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB服务器验证了其有效性后，才能用来响应客户请求</td>
</tr>
<tr>
<td align="left">Last-Modified</td>
<td align="left">WEB服务器认为对象的最后修改时间</td>
</tr>
</tbody></table>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/wangzhen_csdn/article/details/80776991" target="_blank" rel="noopener">CSDN-wangzhibo_csdn</a><br><a href="https://segmentfault.com/q/1010000010814115" target="_blank" rel="noopener">segmentfault-某熊猫桑</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>三次握手与四次挥手</title>
    <url>/2020/03/14/tcpConnect/</url>
    <content><![CDATA[<h1 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h1><p>当获取IP之后，客户端就会发送一个报文段给服务器，开启三次握手。</p>
<p><img src="/2020/03/14/tcpConnect/baowenduan.png" alt="baowenduan"></p>
<p>其中确认号下面那个犄角旮旯里：</p>
<blockquote>
<p>URG(urgent)：紧急，为1时表示有紧急数据，应正确传送。<br>ACK(acknowledgement)：确认，为1时确认字号才有效，一旦TCP连接建立，就必须把ACK置为1。<br>PSH(push)：传送，为1时表示尽快交付，不必把整个缓存都填满后再交付。<br>RST(reset)：重置，为1时表示连接中出现严重差错，必须释放连接，重新建立。<br>SYN(synchronous)：建立联机，为1时表示这是一个连接请求或连接接受报文。<br>FIN(finish)：结束，为1时表示此报文段的发送端的数据已发送完毕，要求释放传输连接。</p>
<p>Sequence number(seq)：顺序号码<br>Acknowledge number(ack)：确认号码</p>
</blockquote>
<p><img src="/2020/03/14/tcpConnect/sanciwoshou.png" alt="sanciwoshou"></p>
<p><a href="https://www.bilibili.com/video/av52745283?from=search&seid=12199868811481081570" target="_blank" rel="noopener">图片来源：B站-计算机网络第36讲</a></p>
<p>三次握手功能如下：</p>
<blockquote>
<p>客户端：服大大，我要发数据给你哇，你快来接收啦。<br>服务器：好的，老客你发吧。<br>客户端：嗯嗯，那我发了。</p>
</blockquote>
<p>那为什么是三次握手呢？</p>
<p>这就要考虑到传输时丢包的问题，即当服务器发送给客户端的数据丢包了，如果只有两次握手，服务器是无法确认客户端是否能收到自己的回复。所以第三次握手的作用就是，如果服务器收不到客户端对自己的回复，那么它就会继续发送，直到确认客户端收到了自己的回复。</p>
<blockquote>
<p>客户端：服大大，我要发数据给你哇，你快来接收啦。<br>客户端：（？？？没收到？再来一次）<br>客户端：服大大，我要发数据给你哇，你快来接收啦。<br>服务器：好的，老客你发吧。<br>服务器：（？？？怎么不回我，可能又丢包了，那再发一次吧）<br>服务器：好的，老客你发吧。<br>客户端：嗯嗯，那我发了。<br>服务器：（收到了老客的回复，说明我们的TCP连接已经建立）<br>客户端：（不管服大大有没有收到这条消息，我都认为我们的TCP连接已经建立）</p>
</blockquote>
<p>当然这也只是比较理想的一种情况，现实中这些传递的包可能会卡在路上过了很久之后才传过来，这个时候很有可能客户端与服务器都传输完数据了。如果只有两次握手的话，那么很有可能会再次唤起服务器，造成资源的浪费。  </p>
<p><img src="/2020/03/14/tcpConnect/erciwoshou.png" alt="erciwoshou"></p>
<p><a href="https://www.bilibili.com/video/av52745283?from=search&seid=12199868811481081570" target="_blank" rel="noopener">图片来源：B站-计算机网络第36讲</a></p>
<blockquote>
<p>客户端：服大大，我要发数据给你哇，你快来接收啦。（1）<br>客户端：（？？？没收到？再来一次）<br>客户端：服大大，我要发数据给你哇，你快来接收啦。（2）<br>服务器：好的，老客你发吧。（2）<br>客户端与服务器开心的发完数据，并且关闭了连接。<br>服务器：你怎么又来了？（1）<br>服务器建立连接（1）<br>服务器等待客户端传输请求（1）<br>服务器：我等（1）<br>服务器：我等（1）<br>服务器：我等等等（1）<br>……<br>服务器：？？……？？（1）<br>服务器亡（1）</p>
</blockquote>
<h1 id="传输数据"><a href="#传输数据" class="headerlink" title="传输数据"></a>传输数据</h1><p>握手成功后，开始传输数据，数据被分为多个分节，一次数据的传输需要2个TCP包。数据发送包，接收方应答包。</p>
<p>如果已经建立了连接，客户端突然出现故障。TCP设有一个保活计时器，服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h1 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h1><p><img src="/2020/03/14/tcpConnect/sicihuishou.png" alt="sicihuishou"></p>
<p><a href="https://www.bilibili.com/video/av52745283?from=search&seid=12199868811481081570" target="_blank" rel="noopener">图片来源：B站-计算机网络第36讲</a></p>
<blockquote>
<p>客户端发完数据<br>客户端：服大大，我数据发完了。(停止发送数据，进入终止等待1状态)<br>服务器：好的，我知道了。(进入关闭等待状态)<br>客户端收到回复进入终止等待2状态<br>服务器发完数据<br>服务器：老客啊，我也发完了。(进入最后确认状态)<br>客户端接收完数据：好的。(客户端进入时间等待状态，服务器进入CLOSED状态)<br>2*MSL(最长报文段寿命Maximum Segment Lifetime)时间后，客户端进入CLOSED状态。</p>
</blockquote>
<p>客户端等待2MSL的原因：</p>
<p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p>
<p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.zhihu.com/question/24853633" target="_blank" rel="noopener">知乎-TCP 为什么是三次握手，而不是两次或四次？</a></p>
<p><a href="https://www.bilibili.com/video/av52745283?from=search&seid=12199868811481081570" target="_blank" rel="noopener">B站-计算机网络第36讲</a></p>
<p><a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">CSDN-小书go</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP请求方法</title>
    <url>/2020/03/14/httpMethods/</url>
    <content><![CDATA[<p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。</p>
<p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p>
<p>所以HTTP目前为止一共有九种请求方法。</p>
<h1 id="HEAD-获取报头"><a href="#HEAD-获取报头" class="headerlink" title="HEAD(获取报头)"></a>HEAD(获取报头)</h1><blockquote>
<p>The <strong>HTTP <code>HEAD</code> method</strong> requests the headers that are returned if the specified resource would be requested with an HTTP <code>GET</code> method. Such a request can be done before deciding to download a large resource to save bandwidth, for example.</p>
<p>A response to a <code>HEAD</code> method should not have a body. If so, it must be ignored. Even so, entity headers describing the content of the body, like <code>Content-Length</code> may be included in the response. They don’t relate to the body of the <code>HEAD</code> response, which should be empty, but to the body which a similar request using the <code>GET</code>method would have returned as a response.</p>
</blockquote>
<p>HEAD与GET方法类似，但是它不会返回消息体，用来获取报头，通常用来测试超链接的有效性、可用性。</p>
<h1 id="GET-查询"><a href="#GET-查询" class="headerlink" title="GET(查询)"></a>GET(查询)</h1><blockquote>
<p>The <strong>HTTP <code>GET</code> method</strong> requests a representation of the specified resource. Requests using <code>GET</code> should only retrieve data.</p>
</blockquote>
<p>HTTP协议规定GET是获取资源的方法，通过URL提交，在地址栏中可以看到，其所提交的数据最多只能有1024个字节。GET有利于资源的传播，其请求在Ajax环境下不会被缓存，有利于减轻服务器的压力。</p>
<h1 id="POST-新增"><a href="#POST-新增" class="headerlink" title="POST(新增)"></a>POST(新增)</h1><blockquote>
<p>The <strong>HTTP <code>POST</code> method</strong> sends data to the server. The type of the body of the request is indicated by the Content-Type header.</p>
</blockquote>
<p>HTTP协议规定POST是创建资源的方法，其内容是在HTTP请求的body里实现，POST传输数据时不会在URL里显示，可以传输较为大量的数据，在Ajax环境下会被缓存，非幂等的，多次访问都会产生影响。</p>
<h1 id="PUT-修改"><a href="#PUT-修改" class="headerlink" title="PUT(修改)"></a>PUT(修改)</h1><blockquote>
<p>The <strong>HTTP PUT request method</strong> creates a new resource or replaces a representation of the target resource with the request payload.</p>
<p>The difference between <code>PUT</code> and <code>POST</code> is that <code>PUT</code>is idempotent: calling it once or several times successively has the same effect (that is no side effect), where successive identical <code>POST</code> may have additional effects, like passing an order several times.</p>
</blockquote>
<p>HTTP协议规定PUT是更新资源的方法,<code>PUT</code>是幂等的方法，即调用一次与调用多次是等价的。</p>
<h1 id="PATCH-修改"><a href="#PATCH-修改" class="headerlink" title="PATCH(修改)"></a>PATCH(修改)</h1><blockquote>
<p>The <strong>HTTP PATCH request method</strong> applies partial modifications to a resource.</p>
<p>The HTTP <code>PUT</code>method only allows complete replacement of a document. Unlike <code>PUT</code>, <code>PATCH</code> is not idempotent, meaning successive identical patch requests <em>may</em> have different effects. However, it is possible to issue <code>PATCH</code> requests in such a way as to be idempotent.</p>
<p>PATCH (like PUT) may have side-effects on other resources.</p>
<p>To find out whether a server supports <code>PATCH</code>, a server can advertise its support by adding it to the list in the Allow or Access-Control-Allow-Methods(for CORS) response headers.</p>
</blockquote>
<p>HTTP协议规定PATCH是修改资源的方法，是对PUT方法的补充，用来对已知资源进行局部更新，但PATCH与POST一样是非幂等的。</p>
<h1 id="DELETE-删除"><a href="#DELETE-删除" class="headerlink" title="DELETE(删除)"></a>DELETE(删除)</h1><blockquote>
<p>The <strong>HTTP DELETE request method</strong> deletes the specified resource.</p>
</blockquote>
<p>HTTP协议规定DELETE是删除资源的方法.</p>
<h1 id="CONNECT-代理"><a href="#CONNECT-代理" class="headerlink" title="CONNECT(代理)"></a>CONNECT(代理)</h1><blockquote>
<p>The <strong>HTTP <code>CONNECT</code> method</strong> starts two-way communications with the requested resource. It can be used to open a tunnel.</p>
<p>For example, the <code>CONNECT</code> method can be used to access websites that use SSL (HTTPS). The client asks an HTTP Proxy server to tunnel the TCP connection to the desired destination. The server then proceeds to make the connection on behalf of the client. Once the connection has been established by the server, the Proxy server continues to proxy the TCP stream to and from the client.</p>
</blockquote>
<p><code>CONNECT</code>在网页开发中一般不会被用到，其作用是将服务器作为代理(访问中介)，让服务器代替用户访问别的资源，然后再将该资源返回给用户，这样用户就可以访问到只有服务器才能访问的网站(比如翻墙 )，它直接使用TCP去连接。</p>
<h1 id="TRACE-测试"><a href="#TRACE-测试" class="headerlink" title="TRACE(测试)"></a>TRACE(测试)</h1><blockquote>
<p>The <strong>HTTP <code>TRACE</code> method</strong> performs a message loop-back test along the path to the target resource, providing a useful debugging mechanism.</p>
</blockquote>
<p>回显服务器收到的请求，主要用于测试或诊断。</p>
<h1 id="OPTIONS-测试"><a href="#OPTIONS-测试" class="headerlink" title="OPTIONS(测试)"></a>OPTIONS(测试)</h1><blockquote>
<p>The <strong>HTTP <code>OPTIONS</code> method</strong> is used to describe the communication options for the target resource. The client can specify a URL for the OPTIONS method, or an asterisk (*) to refer to the entire server.</p>
<p> For Example, to find out which request methods a server supports, one can use curl and issue an OPTIONS request.</p>
</blockquote>
<p>通过该方法传回该资源所支持的所有HTTP请求，也可以测试服务器是否可以正常使用。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods" target="_blank" rel="noopener">MDN</a></p>
<p><a href="https://www.runoob.com/http/http-methods.html" target="_blank" rel="noopener">菜鸟联盟</a></p>
<p><a href="https://blog.csdn.net/kobejayandy/article/details/24606521" target="_blank" rel="noopener">CSDN-kobejayandy</a></p>
<p><a href="https://www.jianshu.com/p/93727598b564" target="_blank" rel="noopener">简书-5onghua</a></p>
<p><a href="https://www.zhihu.com/question/31640769" target="_blank" rel="noopener">知乎</a></p>
<p><a href="https://www.cnblogs.com/liuzhenbo/p/11045048.html" target="_blank" rel="noopener">博客园-心田居士</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP状态码</title>
    <url>/2020/03/13/httpStatusCode/</url>
    <content><![CDATA[<h1 id="什么是HTTP状态码？"><a href="#什么是HTTP状态码？" class="headerlink" title="什么是HTTP状态码？"></a>什么是HTTP状态码？</h1><p>所谓的HTTP状态码就是表示网页服务器超文本传输协议(HyperText Transfer protocol)响应状态的3位十进制数字代码，它由<a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">RFC2616</a>规范定义，并由互联网号码分配局(Internet Assigned Numbers Authority)维护。当浏览者访问一个网页时，浏览器会向服务器发送请求，服务器会返回一个包含HTTP状态码的信息头(server head)响应网页请求。</p>
<p>换句话说HTTP状态码就是统一标准被大家都认可的一个表示网页与服务器之间通信状态的一个东西。</p>
<h1 id="常用状态码"><a href="#常用状态码" class="headerlink" title="常用状态码"></a>常用状态码</h1><ul>
<li>200 - 请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL</li>
<li>404 - 请求的资源（网页等）不存在</li>
<li>500 - 内部服务器错误</li>
</ul>
<h1 id="HTTP状态码的分类"><a href="#HTTP状态码的分类" class="headerlink" title="HTTP状态码的分类"></a>HTTP状态码的分类</h1><p>HTTP状态码由三个十进制组成，只有第一个十进制定义了分类，后面两个无分类作用，其具体分类如下：</p>
<h2 id="1-信息"><a href="#1-信息" class="headerlink" title="1** 信息"></a>1** 信息</h2><p>服务器收到请求，需要请求者继续执行操作。</p>
<p>服务器：老客啊，你到底想干啥？？？</p>
<table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">状态码英文名称</th>
<th align="left">中文描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100</td>
<td align="left">Continue</td>
<td align="left">继续。客户端应继续其请求</td>
</tr>
<tr>
<td align="left">101</td>
<td align="left">Switching Protocols</td>
<td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
</tbody></table>
<h2 id="2-成功"><a href="#2-成功" class="headerlink" title="2** 成功"></a>2** 成功</h2><p>操作被成功接收并处理。</p>
<p>服务器：老客啊，不愧是cp，你看这次咱俩配合的多默契。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态码英文名称</th>
<th>中文描述</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK</td>
<td>请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td>已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td>203</td>
<td>Non-Authoritative Information</td>
<td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td>205</td>
<td>Reset Content</td>
<td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content</td>
<td>部分内容。服务器成功处理了部分GET请求</td>
</tr>
</tbody></table>
<h2 id="3-重定向"><a href="#3-重定向" class="headerlink" title="3**  重定向"></a>3**  重定向</h2><p>需要进一步的操作以完成请求。</p>
<p>服务器：老客啊，你要的东西不在这，你换个地方去拿。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态码英文名称</th>
<th>中文描述</th>
</tr>
</thead>
<tbody><tr>
<td>300</td>
<td>Multiple Choices</td>
<td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently</td>
<td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy</td>
<td>使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td>306</td>
<td>Unused</td>
<td>已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect</td>
<td>临时重定向。与302类似。使用GET请求重定向</td>
</tr>
</tbody></table>
<h2 id="4-客户端错误"><a href="#4-客户端错误" class="headerlink" title="4** 客户端错误"></a>4** 客户端错误</h2><p>请求包含语法错误或无法完成请求。</p>
<p>服务器：老客啊，这是你的错，不怨我。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态码英文名称</th>
<th>中文描述</th>
</tr>
</thead>
<tbody><tr>
<td>400</td>
<td>Bad Request</td>
<td>客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>请求要求用户的身份认证</td>
</tr>
<tr>
<td>402</td>
<td>Payment Required</td>
<td>保留，将来使用</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td>客户端请求中的方法被禁止</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required</td>
<td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td>408</td>
<td>Request Time-out</td>
<td>服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td>409</td>
<td>Conflict</td>
<td>服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td>410</td>
<td>Gone</td>
<td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td>411</td>
<td>Length Required</td>
<td>服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed</td>
<td>客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td>413</td>
<td>Request Entity Too Large</td>
<td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td>414</td>
<td>Request-URI Too Large</td>
<td>请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type</td>
<td>服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td>416</td>
<td>Requested range not satisfiable</td>
<td>客户端请求的范围无效</td>
</tr>
<tr>
<td>417</td>
<td>Expectation Failed</td>
<td>服务器无法满足Expect的请求头信息</td>
</tr>
</tbody></table>
<h2 id="5-服务器错误"><a href="#5-服务器错误" class="headerlink" title="5**  服务器错误"></a>5**  服务器错误</h2><p>服务器在处理请求的过程中发生了错误。</p>
<p>服务器：嗯。这次是我的错误。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态码英文名称</th>
<th>中文描述</th>
</tr>
</thead>
<tbody><tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented</td>
<td>服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Time-out</td>
<td>充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version not supported</td>
<td>服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">菜鸟联盟大佬</a></p>
<p><a href="https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660" target="_blank" rel="noopener">度娘</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
</search>

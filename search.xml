<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>设备管理</title>
    <url>/2020/03/16/osDeviceManager/</url>
    <content><![CDATA[<p>对计算机系统内所有设备实施有效管理</p>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ul>
<li>设备分配</li>
<li>设备传输控制</li>
<li>设备独立</li>
</ul>
<h1 id="I-O管理"><a href="#I-O管理" class="headerlink" title="I/O管理"></a>I/O管理</h1><table>
<thead>
<tr>
<th>I/O设备分类</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>按设备的使用特性分类</td>
<td>存储设备、人机交互设备(输入输出设备)、网络通信设备(网络接口、调制解调器)</td>
</tr>
<tr>
<td>按信息交换单位分类</td>
<td>字符设备(键盘、显示器)、块设备(磁盘)</td>
</tr>
<tr>
<td>按传输速率分类</td>
<td>低速设备(键盘、鼠标)、中速设备(打印机)、高速设备(磁带机、磁盘)</td>
</tr>
<tr>
<td>按设备共享属性分类</td>
<td>独占设备、共享设备、虚拟设备</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>I/O设备功能</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>设备分配</td>
<td>将I/O设备分配给哪个进程</td>
</tr>
<tr>
<td>设备处理</td>
<td>启动I/O操作，处理I/O的中断请求</td>
</tr>
<tr>
<td>缓冲管理</td>
<td>缓和CUP与I/O速度不匹配问题</td>
</tr>
<tr>
<td>设备独立性</td>
<td>应用程序独立于物理设备</td>
</tr>
</tbody></table>
<h2 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h2><p>当只有一个I/O时，它只有一个设备地址。当它控制多个I/O时，具有多个设备地址。</p>
<p>功能</p>
<ul>
<li>接收识别CPU的各种指令</li>
<li>实现CPU与设备控制器、设备控制器与设备之间的数据交换</li>
<li>记录设备的状态供CPU查询</li>
<li>识别所控制的每个设备的地址</li>
<li>对CPU输出的数据或设备向CPU输入的数据进行缓冲</li>
<li>对输入\输出数据进行差错控制</li>
</ul>
<h2 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h2><h3 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h3><p>CPU与I/O通信，需要不断测试I/O设备，利用率低，简单</p>
<h3 id="中断控制方式"><a href="#中断控制方式" class="headerlink" title="中断控制方式"></a>中断控制方式</h3><p>输入完成，向CPU发送中断信号，CPU执行中断处理程序，提高了CPU利用率，中断次数多，耗费大量CPU处理时间。</p>
<ul>
<li>唤醒被阻塞的驱动进程：signal操作</li>
<li>保护被中断进程的CPU环境：将处理器状态字PSW和程序计数器PC压入栈中加以保存，CPU寄存器也压入栈中</li>
<li>转入想要的设备处理程序</li>
<li>中断处理</li>
<li>恢复被中断进程的现场</li>
</ul>
<h3 id="DMA控制方式"><a href="#DMA控制方式" class="headerlink" title="DMA控制方式"></a>DMA控制方式</h3><ul>
<li>数据传输的基本单位是数据块</li>
<li>数据是单向传输</li>
<li>仅在传送一个或多个数据块的开始和结束时才需要CPU干预，传送一批数据后才中断CPU</li>
<li>组成：<ul>
<li>命令/状态寄存器（CR）接收从CPU发来的I/O命令或有关控制信息</li>
<li>内存地址寄存器（MAR）用于存放数据从设备传送到内存或从内存到设备的内存地址</li>
<li>数据寄存器（DR）用于暂存从设备到内存或从内存到设备的数据</li>
<li>数据计数器（DC）存放本次要传送的字数</li>
</ul>
</li>
<li>优点：与CPU并行</li>
<li>缺点：起始地址，传送数据长度等都由CPU控制，每台设备需要DMA控制器，设备增加，不经济</li>
</ul>
<h3 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h3><ul>
<li>起始地址，传送数据长度等都由通道管理，一个通道可以控制多台设备</li>
<li>字节多路通道：以字节为单位，交叉轮流为多个设备服务</li>
<li>数组选择通道：可以连接多台高速设备，只含有一个分配型子通道，利用率低</li>
<li>数组多路通道：广泛连接中高低速设备，含有多个非分配型子通道</li>
<li>优点：可以与CPU并行</li>
<li>缺点：成本高</li>
</ul>
<h2 id="软件层次结构"><a href="#软件层次结构" class="headerlink" title="软件层次结构"></a>软件层次结构</h2><ul>
<li>硬件</li>
<li>中断处理程序<ul>
<li>见上面中断控制方式</li>
</ul>
</li>
<li>设备驱动程序<ul>
<li>将参数要求转化为具体要求</li>
<li>检查I/O的合法性</li>
<li>读出和检查设备的状态</li>
<li>传送必要参数</li>
<li>设置必要方式</li>
<li>启动I/O设备</li>
</ul>
</li>
<li>设备独立性软件<ul>
<li>向用户空间软件提供统一的接口</li>
</ul>
</li>
<li>用户层软件</li>
</ul>
<h1 id="高速缓存与缓冲区"><a href="#高速缓存与缓冲区" class="headerlink" title="高速缓存与缓冲区"></a>高速缓存与缓冲区</h1><p>配合CPU的速度</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>单缓冲：等待上一行输出完毕才能继续输出</p>
<p>双缓冲：前一个数据可以装入另一个缓冲区，两个轮换使用</p>
<p>循环缓冲：最后一个缓冲区指向第一个缓冲区构成循环，当需要数据是从缓冲区取出一个装满数据的缓冲区</p>
<p>缓冲池</p>
<ul>
<li>共多个队列共享，既可以输入也可以输出</li>
<li>三种状态<ul>
<li>空缓冲队列</li>
<li>装满输入数据的缓冲队列</li>
<li>装满输出数据的缓冲队列</li>
</ul>
</li>
<li>四个工作缓冲区<ul>
<li>收容输入数据的工作缓冲区</li>
<li>提取输入数据的工作缓冲区</li>
<li>收容输出数据的工作缓冲区</li>
<li>提取输出数据的工作缓冲区</li>
</ul>
</li>
</ul>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>存放数据不同：高速缓存存放低速设备的一个备份，缓冲区则存放低速到高速的一个数据</li>
<li>目的不同：高速缓存存放经常使用的数据，缓冲区解决速度不匹配</li>
</ul>
<h1 id="设备分配与回收"><a href="#设备分配与回收" class="headerlink" title="设备分配与回收"></a>设备分配与回收</h1><h2 id="设备管理中的数据结构"><a href="#设备管理中的数据结构" class="headerlink" title="设备管理中的数据结构"></a>设备管理中的数据结构</h2><ul>
<li>设备控制表DCT：用来指示设备当前状态</li>
<li>设备控制器控制表COCT：反应设备控制器的使用状态</li>
<li>通道控制表CHCT：反应通道的状态</li>
<li>系统设备表SDT：已连接到系统中的所有物理设备</li>
</ul>
<h2 id="设备分配策略"><a href="#设备分配策略" class="headerlink" title="设备分配策略"></a>设备分配策略</h2><ul>
<li>设备的使用性质<ul>
<li>独享设备</li>
<li>共享分配</li>
<li>虚拟分配：针对虚拟设备</li>
</ul>
</li>
<li>设备分配算法<ul>
<li>先来先服务</li>
<li>优先级高者优先</li>
</ul>
</li>
<li>设备分配的安全性<ul>
<li>保证不发生死锁</li>
<li>静态分配：在作业开始前就一次性分配好</li>
<li>动态分配：根据需要进行设备分配</li>
</ul>
</li>
</ul>
<h2 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h2><ul>
<li>指应用程序独立于具体使用的物理设备</li>
<li>通过逻辑设备表来对应逻辑设备和物理设备</li>
</ul>
<h2 id="设备分配程序"><a href="#设备分配程序" class="headerlink" title="设备分配程序"></a>设备分配程序</h2><ul>
<li>单通路I/O系统的设备分配：分配设备-&gt;分配设备控制器-&gt;分配通道</li>
<li>多通路I/O系统的设备分配：一个设备与多个设备控制器相连，设备控制器也与多个通道相连<ul>
<li>根据设备类型检索系统控制表，找到第一个空闲设备，并检测分配的安全性</li>
<li>设备分配后设备控制表，找到第一个与已分配设备相连的空闲设备控制器，若无则返回上面，查找下一个空闲设备</li>
<li>同样方法查找通道，三个都空闲，就启动I/O设备传输信息</li>
</ul>
</li>
</ul>
<h2 id="设备的回收"><a href="#设备的回收" class="headerlink" title="设备的回收"></a>设备的回收</h2><h1 id="SPOOLing假脱机技术"><a href="#SPOOLing假脱机技术" class="headerlink" title="SPOOLing假脱机技术"></a>SPOOLing假脱机技术</h1><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>输入井和输出井</li>
<li>输入缓冲区和输出缓冲区</li>
<li>输入进程和输出进程</li>
</ul>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>提高了I/O速度</li>
<li>设备并没有分配给任何进程</li>
<li>实现虚拟设备功能：设备是逻辑上的设备</li>
<li>既是一种速度匹配技术，也是一种虚拟设备技术</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤操作系统</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>deviceManager</tag>
      </tags>
  </entry>
  <entry>
    <title>文件管理</title>
    <url>/2020/03/16/osFileManager/</url>
    <content><![CDATA[<p>负责信息管理，有效支持文件存储、检索和修改，解决文件共享、保密和保护问题</p>
<p>功能：目录管理、文件操作管理、文件保护</p>
<h1 id="文件的概念"><a href="#文件的概念" class="headerlink" title="文件的概念"></a>文件的概念</h1><p>具有文件名的一组相关元素集合，在文件系统中是一个最大的数据单位</p>
<table>
<thead>
<tr>
<th>组成</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据项</td>
<td>描述某一属性的值</td>
</tr>
<tr>
<td>记录</td>
<td>属性</td>
</tr>
<tr>
<td>文件</td>
<td>一组相关信息的集合</td>
</tr>
</tbody></table>
<p>属性：名称、标识符、文件类型、文件位置、文件大小、建立时间、用户标识。</p>
<h2 id="文件分类"><a href="#文件分类" class="headerlink" title="文件分类"></a>文件分类</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>按用途</td>
<td>系统文件、库文件、用户文件</td>
</tr>
<tr>
<td>按保护级别</td>
<td>只读文件、读写文件、执行文件、不保护文件</td>
</tr>
<tr>
<td>按信息流向分类</td>
<td>输入文件、输出文件、输入输出文件</td>
</tr>
<tr>
<td>按数据形式分类</td>
<td>源文件、目标文件(二进制文件)、可执行文件</td>
</tr>
</tbody></table>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>创建文件</li>
<li>删除文件</li>
<li>读文件</li>
<li>写文件</li>
<li>截断文件</li>
<li>设置文件的读写位置</li>
</ul>
<h2 id="文件打开关闭操作"><a href="#文件打开关闭操作" class="headerlink" title="文件打开关闭操作"></a>文件打开关闭操作</h2><ul>
<li>打开文件<ul>
<li>文件指针</li>
<li>文件打开计数（多个进程可能会同时打开文件）</li>
<li>文件磁盘位置</li>
<li>访问权限</li>
</ul>
</li>
<li>关闭文件</li>
</ul>
<h2 id="文件的结构"><a href="#文件的结构" class="headerlink" title="文件的结构"></a>文件的结构</h2><h3 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h3><p>无结构的流式文件</p>
<p>有结构的记录式文件</p>
<ul>
<li>顺序文件<ul>
<li>最简单的一种结构</li>
<li>按长度分：定长记录顺序文件、变长记录顺序文件</li>
<li>按关键字分：串结构(与关键字顺序无关)、与关键字顺序有关</li>
<li>优点：存取快，随机访问</li>
<li>缺点：不会产生外部碎片</li>
</ul>
</li>
<li>索引文件<ul>
<li>建立一个索引表</li>
<li>优点：随机访问、易于开销</li>
<li>缺点：效率低、空间开销大</li>
</ul>
</li>
<li>索引顺序文件：为顺序结构分组，每组第一个建立索引表</li>
<li>直接文件、散列文件：关键字值决定物理地址</li>
</ul>
<h3 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h3><ul>
<li>连续分配</li>
<li>链接分配</li>
<li>索引分配</li>
</ul>
<h2 id="目录的结构"><a href="#目录的结构" class="headerlink" title="目录的结构"></a>目录的结构</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>实现按名存取</li>
<li>提高检索速度</li>
<li>允许文件同名：通过不同工作目录加以区分</li>
<li>允许文件共享</li>
</ul>
<h3 id="文件控制块"><a href="#文件控制块" class="headerlink" title="文件控制块"></a>文件控制块</h3><ul>
<li>文件名</li>
<li>文件的结构：逻辑结构是记录式（否定长、记录长度、个数）还是流式，物理结构是什么</li>
<li>文件的物理位置</li>
<li>存取控制信息：用户的权限</li>
<li>管理信息</li>
</ul>
<h3 id="索引节点"><a href="#索引节点" class="headerlink" title="索引节点"></a>索引节点</h3><ul>
<li>将文件名与文件描述信息分开</li>
<li>文件目录由文件名和指向具体文件的指针</li>
<li>磁盘索引节点：文件主标识符、文件类型、文件存取权限、文件物理地址、文件长度、文件连接计数、文件存取时间</li>
<li>内存索引节点：磁盘索引节点、索引节点编号、状态、访问计数、逻辑设备号、链接指针</li>
</ul>
<h3 id="单级目录结构"><a href="#单级目录结构" class="headerlink" title="单级目录结构"></a>单级目录结构</h3><ul>
<li>只建立一张用户表</li>
<li>不允许重名</li>
<li>查找效率慢</li>
</ul>
<h3 id="二级目录结构"><a href="#二级目录结构" class="headerlink" title="二级目录结构"></a>二级目录结构</h3><ul>
<li>主文件目录：系统中各个用户文件目录的情况</li>
<li>用户文件目录：每个用户单独一个目录</li>
</ul>
<h3 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h3><ul>
<li>第一级目录为根目录</li>
<li>非叶子节点为目录</li>
<li>叶子节点为文件</li>
<li>引入路径名\，当前目录..表示给的目录的父目录</li>
</ul>
<h3 id="图形结构"><a href="#图形结构" class="headerlink" title="图形结构"></a>图形结构</h3><ul>
<li>方便共享</li>
<li>每增加一个共享链时计数器+1，删除一个共享链计时器-1，当计数器为0时才删除文件</li>
</ul>
<h2 id="文件的共享"><a href="#文件的共享" class="headerlink" title="文件的共享"></a>文件的共享</h2><ul>
<li>节省大量的外存空间和主存空间</li>
<li>共享动机<ul>
<li>相互协作共同完成任务</li>
<li>远程计算机之间需要通信，需要远程文件系统的共享功能</li>
</ul>
</li>
<li>共享方式<ul>
<li>基于索引节点的共享方式（硬链接）：不同目录的文件指针指向同一文件</li>
<li>利用符号链实现文件共享（软连接）：只有所有者才有指针，其他用户只有路径名</li>
</ul>
</li>
</ul>
<h2 id="文件的保护"><a href="#文件的保护" class="headerlink" title="文件的保护"></a>文件的保护</h2><ul>
<li>访问类型（读写增加删除执行等）</li>
<li>访问控制：访问控制矩阵、访问控制表、用户权限表、密码与口令</li>
</ul>
<h1 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h1><h2 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h2><ul>
<li>用户接口（cmd等）</li>
<li>文件目录系统</li>
<li>存取控制验证（权限）</li>
<li>逻辑文件系统与文件信息缓冲区（获取文件的逻辑地址）</li>
<li>物理文件系统（获取文件的物理地址）</li>
</ul>
<h2 id="目录的实现"><a href="#目录的实现" class="headerlink" title="目录的实现"></a>目录的实现</h2><ul>
<li>线性表</li>
<li>散列表</li>
</ul>
<h2 id="文件的实现"><a href="#文件的实现" class="headerlink" title="文件的实现"></a>文件的实现</h2><p>外存分配方式</p>
<ul>
<li><p>连续分配</p>
</li>
<li><p>链接分配</p>
<ul>
<li>隐式分配：指针放在每一个物理块中</li>
<li>显示分配：指针放在内存的一张链接表中</li>
</ul>
</li>
<li><p>索引分配</p>
<ul>
<li>单级索引分配</li>
<li>两级索引分配</li>
<li>混合索引分配：既采用直接地址，也使用单级或两级索引分配</li>
</ul>
</li>
<li><p>文件存储空间管理</p>
<ul>
<li>空闲文件表<ul>
<li>将一个连续空闲区看作一个文件</li>
<li>若请求等于块数则全部分配</li>
<li>请求小于块数则部分留下</li>
</ul>
</li>
<li>空闲块链表：把所有空闲区域链起来，分配时一次从头开始</li>
<li>位示图法：1表示已分配，0表示未分配，分配时按照需要找到一组值为0的二进制</li>
<li>成组链接法：<ul>
<li>所有空闲区按每组100块分成若干组，所有盘号记录到前一组中，形成堆栈</li>
<li>分配空闲盘块的方法<ul>
<li>先查找第一组的盘块数，</li>
<li>若不止一块则将超级盘块中的空闲盘块数减一，将栈顶的盘块分配出去</li>
<li>若只剩一块且盘块号不是标记结束的0，则将该块的内容读入超级块中，将该块分配出去</li>
<li>若是0，则分配失败</li>
</ul>
</li>
<li>回收空闲盘块的方法<ul>
<li>若第一个不满100块，则只要在超级块的栈顶放入该空闲盘块的块号，并将磁盘块数+1</li>
<li>若已经有100块了，则先将第一组的盘块数和盘块号写入该空闲磁盘块中，再将盘块数=1，栈顶块号=该空闲盘口块号写入超级块中，原来第一组变为第二组</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="磁盘组织与管理"><a href="#磁盘组织与管理" class="headerlink" title="磁盘组织与管理"></a>磁盘组织与管理</h1><h2 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h2><p>柱面号、磁头号、扇区号</p>
<h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h2><ul>
<li>引导控制块（分区的第一块，没有操作系统则为空）</li>
<li>分区控制块（分区信息）</li>
<li>目录结构</li>
<li>文件控制块（文件信息）</li>
</ul>
<h2 id="访问时间"><a href="#访问时间" class="headerlink" title="访问时间"></a>访问时间</h2><ul>
<li>访问时间=寻道时间+旋转延迟+传输时间</li>
<li>寻道时间Ts=m*n+s(m:每移动一个磁道所需时间，s启动磁臂的时间、n移动几条磁道)</li>
<li>旋转延迟Tr=（1/r）/2（r旋转速度）</li>
<li>传输时间Tt=b/（rN）</li>
</ul>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><ul>
<li>先来先服务算法FCFS：先来先服务</li>
<li>最短寻道时间优先算法SSTF：离磁头最近</li>
<li>扫描算法SCAN：</li>
<li>循环扫描算法C-SCAN：单向移动</li>
</ul>
<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><ul>
<li>磁盘格式化：空白盘分区并写入基础信息</li>
<li>引导块：计算机启动时需要运行初始化程序（自举程序），找到系统内核装入内存，开始操作系统的运行</li>
<li>坏扇区<ul>
<li>简单磁盘（IDE）手工处理</li>
<li>复杂磁盘（SCSI）维护一个磁盘坏块链表</li>
</ul>
</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤操作系统</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>fileManager</tag>
      </tags>
  </entry>
  <entry>
    <title>存储器（内存）管理</title>
    <url>/2020/03/16/osMemoryManager/</url>
    <content><![CDATA[<h1 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h1><p>用来对内存进行分配保护和扩充</p>
<p>功能：内存分配与回收、地址变换、内存保护、内存扩充</p>
<p>过程：编译-&gt;链接-&gt;装入</p>
<ul>
<li>静态链接：在程序运行前，先把各个目标模块及所需库链接成一个完整的可执行程序，以后不再拆开</li>
<li>装入时动态链接：边装入边链接</li>
<li>运行时动态链接：边运行边链接</li>
<li>绝对装入：在装入时就知道物理地址</li>
<li>可重定位装入：地址变换通常在装入时一次完成</li>
<li>动态运行装入：允许程序运行时在内存中移动位置，物理地址=基址寄存器+逻辑地址（逻辑地址是偏移地址，物理地址是内存中的地址）</li>
</ul>
<p>内存保护：防止一个作业有意无意破坏操作系统或其他作业</p>
<table>
<thead>
<tr>
<th>内存保护方法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>上下界寄存器方法</td>
<td>采用上下界分别存放作业结束地址和开始地址</td>
</tr>
<tr>
<td>基址（重定位寄存器）和限长寄存器（界地址寄存器）方法</td>
<td>限长寄存器与相对地址进行比较，超过则发生中断</td>
</tr>
<tr>
<td>存储保护键方法</td>
<td>给每个存储块分配一个单独的保护键，比较钥匙和锁是否匹配</td>
</tr>
</tbody></table>
<h1 id="交换与覆盖"><a href="#交换与覆盖" class="headerlink" title="交换与覆盖"></a>交换与覆盖</h1><table>
<thead>
<tr>
<th>技术</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>覆盖技术</td>
<td>解决程序不能全部装入内存中</td>
</tr>
<tr>
<td>交换技术</td>
<td>把暂时不用的程序或数据移入外存</td>
</tr>
</tbody></table>
<h1 id="分配管理方式"><a href="#分配管理方式" class="headerlink" title="分配管理方式"></a>分配管理方式</h1><h2 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h2><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><ul>
<li>将内存分为两个连续存储区域，一个给操作系统，一个给用户</li>
<li>采用静态分配，适合单道程序</li>
</ul>
<h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><ul>
<li>每个分区可以装入一道程序，分区大小事先固定</li>
<li>缺乏灵活性，以产生碎片</li>
</ul>
<h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><table>
<thead>
<tr>
<th>分区分配中的数据结构</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>空闲分区表</td>
<td>每个空闲分区表对应一个表项</td>
</tr>
<tr>
<td>空闲分区链</td>
<td>指向下一个 空闲分区的指针</td>
</tr>
</tbody></table>
<ul>
<li>空闲分区表：每个空闲分区表对应一个表项</li>
<li>空闲分区链：指向下一个 空闲分区的指针</li>
</ul>
<table>
<thead>
<tr>
<th>分区分配中的算法</th>
<th>解释</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>首次适应算法FF</td>
<td>按地址来，每次都从队头开始</td>
<td>保留了高位地址大的空闲区，无内部碎片</td>
<td>地位地址被划分，产生很多小的空闲区，无外部碎片</td>
</tr>
<tr>
<td>下次适应算法NF</td>
<td>按地址，循环，从上次空闲区下一个区开始</td>
<td>使空闲分区分布更加均匀</td>
<td>导致缺乏大的空闲分区</td>
</tr>
<tr>
<td>最佳适应算法BF</td>
<td>按容量大小从大开始，找到一个可以满足的最小区</td>
<td>总能分到最恰当的分区，并保留最大的</td>
<td>产生很多碎片</td>
</tr>
<tr>
<td>最差适应算法WF</td>
<td>按容量大小从小开始，找到按要求最大的</td>
<td>使分给作业后剩的空闲分区比较大</td>
<td>无法满足大作业的申请</td>
</tr>
</tbody></table>
<p>分区回收：合并上面，合并下面，合并上下</p>
<table>
<thead>
<tr>
<th>分区分配的动态管理</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>拼接技术</td>
<td>把已分配的移动到一端，碎片集中到一起</td>
</tr>
<tr>
<td>动态重定位分区分配技术</td>
<td>与上面的分配算法相同，并增加了拼接技术</td>
</tr>
</tbody></table>
<h2 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h2><h3 id="基本分页管理方式"><a href="#基本分页管理方式" class="headerlink" title="基本分页管理方式"></a>基本分页管理方式</h3><ul>
<li>页：用户作业地址空间被划分成若干大小相同区域，成为页或页面</li>
<li>页表：将页面与物理地址一一对应形成一张表</li>
</ul>
<p><img src="/2020/03/16/osMemoryManager/jibenfenyeguanli.png" alt="图片-基本分页管理方式"></p>
<ul>
<li>两级页表和多级页表<ul>
<li>页表大小计算</li>
<li>两级页表：外层页号，外层内页地址，页内地址</li>
<li>多级页表：增加级数，减小页表的大小</li>
</ul>
</li>
<li>页的保护与共享<ul>
<li>地址越界保护：用地址和长度来保护信息安全</li>
<li>访问控制信息保护</li>
</ul>
</li>
<li>有效访问时间计算<ul>
<li>没有快表EAT=2t（t访存一次消耗时间）</li>
<li>有快表EAT=a<em>b+(t+a)</em>(1-b)+t，（a访问快表时间，b快表命中率）</li>
</ul>
</li>
<li>优点：利用率高，实现了离散分配，便于存储访问控制，无外部碎片</li>
<li>缺点：硬件支持，内存访问效率下降，共享困难，内部碎片</li>
</ul>
<h3 id="基本分段管理方式"><a href="#基本分段管理方式" class="headerlink" title="基本分段管理方式"></a>基本分段管理方式</h3><ul>
<li><p>段：一组逻辑意义上相对完整的信息集合，逻辑地址结构由段号和段内位移组成</p>
</li>
<li><p>段表及地址变换：</p>
<ul>
<li>从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W。</li>
<li>比较段号S和段表长度M，若S多M，则产生越界中断，否则继续执行。</li>
<li>段表中段号S对应的段表项地址 = 段表起始地址F + 段号S * 段表项长度，取出该段表项的前几位得到段长C。若段内偏移量&gt;=C，则产生越界中断，否则继续执行。</li>
<li>取出段表项中该段的起始地址b，计算 E = b + W，用得到的物理地址E去访问内存。</li>
</ul>
</li>
<li><p>段的共享与保护：与页相同</p>
</li>
<li><p>优点：便于模块化、程序化处理数据结构，便于动态链接和共享、无内部碎片，方便编程、信息共享、信息保护</p>
</li>
<li><p>缺点：需要硬件支持、为满足动态增长减少外部碎片需要拼接技术、分段最大尺寸受主存可用空间限制、有外部碎片</p>
</li>
<li><p>段与页区别</p>
<p><img src="/2020/03/16/osMemoryManager/duanyequbie.jpg" alt="图片-段页的区别"></p>
</li>
<li><p>基本段页式管理方式</p>
<p>页式存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享。如果将这两种存储管理方法结合起来，就形成了段页式存储管理方式。</p>
<p>在段页式系统中，作业的地址空间首先被分成若干个逻辑段，每段都有自己的段号，然后再将每一段分成若干个大小固定的页。对内存空间的管理仍然和分页存储管理一样，将其分成若干个和页面大小相同的存储块，对内存的分配以存储块为单位</p>
<p>结合了两者的优点，但内部碎片不是和页式一样少</p>
</li>
</ul>
<h1 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h1><p>可以让作业部分装入就可以运行的技术</p>
<table>
<thead>
<tr>
<th>特征</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>部分装入</td>
<td>启动程序，程序一部分装入内存</td>
</tr>
<tr>
<td>请求调入</td>
<td>当信息不在内存时，有操作系统将需要的部分调入</td>
</tr>
<tr>
<td>置换功能</td>
<td>将暂时不使用的调入外存</td>
</tr>
<tr>
<td>虚拟存储器</td>
<td>逻辑上扩充存储器空间</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>局部性原理</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>时间局部</td>
<td>一次或下次访问都集中在一个较短的时期内</td>
</tr>
<tr>
<td>控件局部</td>
<td>访问的内容和邻近的内容都集中在一个较小的区域内</td>
</tr>
</tbody></table>
<p>特点：离散性、多次性、对换性、虚拟性</p>
<p>软硬件支持</p>
<ul>
<li>相当数量的外存</li>
<li>一定容量的内存</li>
<li>中断机构：当访问不在内存中，实行中断</li>
<li>地址变换机构：动态实现虚地址到实地址变换</li>
<li>相关数据结构：段表或页表</li>
</ul>
<h2 id="请求分页存储管理系统"><a href="#请求分页存储管理系统" class="headerlink" title="请求分页存储管理系统"></a>请求分页存储管理系统</h2><h3 id="管理方式"><a href="#管理方式" class="headerlink" title="管理方式"></a>管理方式</h3><ul>
<li><p>请求分页=基本分页+请求调页功能+页面置换功能</p>
</li>
<li><p>页表结构</p>
<ul>
<li>页号和物理块号</li>
<li>状态位（存在位）：是否存在于主存</li>
<li>访问字段一段时间内被访问的次数</li>
<li>修改位：调入内存后是否被修改过</li>
</ul>
</li>
<li><p>缺页中断与地址变换</p>
<p><img src="/2020/03/16/osMemoryManager/queyezhongduan.jpg" alt="图片-缺页中断"></p>
</li>
</ul>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><ul>
<li>最佳置换算法OPT：最先淘汰后面都不使用的</li>
<li>先进先出置换算法FIFO：</li>
<li>最近最少使用置换算法LRU：保留最近使用的</li>
<li>时钟置换算法CLOCK：从上一个被淘汰的页面开始遍历遇到访问位0就淘汰，将经过的访问位为1的都置为0</li>
<li>改进时钟置换算法CLOCK：同为0的页面优先淘汰未修改的。第一遍扫描不对经过的修改遇到访问位和过程位都为0的淘汰，若无第二遍对过程中访问位置0遇到访问位为0修改位为1淘汰，若无回到起始位重新执行1和2</li>
<li>最不常用置换算法LFU</li>
<li>页面缓冲算法PBA</li>
</ul>
<h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><ul>
<li>工作集论：让操作系统监视各进程的工作集，若内存有空，则再调一个进程进入内存。若超过，则选择一个进程对换到磁盘</li>
<li>页面分配策略<ul>
<li>固定分配局部置换：为每个进程分配固定的物理块</li>
<li>可变分配全局置换：维护一个空闲物理块，每当进程缺页时，就分配给它，当空闲物理块不够时，就从任何进程中随机取出一页</li>
<li>可变分配局部置换：为每个进程分配一定的物理块，当缺页中断时且无空闲物理块，只让进程换出自己的某个内存页，平凡缺页时就分配给它适当物理块，缺页率少时，适当减少物理块</li>
</ul>
</li>
<li>页面调入策略<ul>
<li>请求调页策略：只有用到时才被调入内存</li>
<li>预调页策略：预计不久之后会用到的调入内存</li>
</ul>
</li>
<li>从何处调入<ul>
<li>系统拥有足够的兑换空间：从对换区全部调入</li>
<li>系统缺少足够的对换空间：不被修改的从文件区调入，可能被修改的调到对换区调入</li>
<li>UNIX方式：与进程有关的都放入文件区，未运行的都在文件区，运行的且被换出的，由于是在对换区，下次仍从对换区调</li>
</ul>
</li>
</ul>
<h3 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h3><ul>
<li>Belady移除：FIFO随物理块增加缺页率增加</li>
<li>抖动现性：刚被调出又要被调入</li>
<li>缺页率：所需页面调入内存的次数/访问次数</li>
</ul>
<h3 id="有效访问时间计算"><a href="#有效访问时间计算" class="headerlink" title="有效访问时间计算"></a>有效访问时间计算</h3><ul>
<li>访问的页在主存中,且在快表中EAT=a+t</li>
<li>访问的页在主存中,但不在快表中EAT=T+2*(a+t)，（T处理缺页中断时间）</li>
<li>访问的页不在主存中,更不在快表中EAT=T+2*(a+t)</li>
<li>加入缺页率和命中快表的概率：EAT=a+b<em>t+(1-b)</em>[t+f<em>(T+a+t)+(1-f)</em>(a+t)]，（f缺页率）</li>
</ul>
<h2 id="请求分段存储管理系统"><a href="#请求分段存储管理系统" class="headerlink" title="请求分段存储管理系统"></a>请求分段存储管理系统</h2><p>与分页类似</p>
<h2 id="内存管理方式比较"><a href="#内存管理方式比较" class="headerlink" title="内存管理方式比较"></a>内存管理方式比较</h2><p><img src="/2020/03/16/osMemoryManager/neicunguanlibijiao.jpg" alt="图片-内存管理方式比较"></p>
<h2 id="内存管理地址的处理"><a href="#内存管理地址的处理" class="headerlink" title="内存管理地址的处理"></a>内存管理地址的处理</h2><p><img src="/2020/03/16/osMemoryManager/dizhichuli.jpg" alt="图片-内存管理地址的处理"></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤操作系统</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>memoryManager</tag>
      </tags>
  </entry>
  <entry>
    <title>处理器（进程）管理</title>
    <url>/2020/03/16/osProcessManager/</url>
    <content><![CDATA[<p>进程管理是对处理器的分配和运行实施有效管理，在多道程序下处理器的分配和运行以进程为单位。</p>
<p>主要功能：进程控制、进程同步、进程通信、进程调度</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>进程是资源分配的基本单位，也是独立运行的基本单位</p>
<h2 id="前驱图"><a href="#前驱图" class="headerlink" title="前驱图"></a>前驱图</h2><p>前驱图是一个有向无循环图，记为DAG。用于这种图可以描述多个程序或进程之间的执行顺序关系。</p>
<ul>
<li>〇 表示一个程序、进程或是语句的结点。</li>
<li>→ 表示结点间的执行顺序。</li>
<li>前驱图中不能存在循环，否则必然会产生不可能实现的前驱关系</li>
</ul>
<p><img src="/2020/03/16/osProcessManager/qianqutu.png" alt="图片-前驱图"></p>
<h2 id="程序的执行"><a href="#程序的执行" class="headerlink" title="程序的执行"></a>程序的执行</h2><table>
<thead>
<tr>
<th>顺序执行</th>
<th>并发执行</th>
</tr>
</thead>
<tbody><tr>
<td>顺序性</td>
<td>间断性：执行-暂停-执行</td>
</tr>
<tr>
<td>封闭性</td>
<td>失去封闭性：一个程序执行时会受其他程序影响</td>
</tr>
<tr>
<td>可再现性</td>
<td>不可再现性：并发执行结果具有再现性需要满足：R(p1)并W(p2)=空，R(p2)并W(p1)=空，W(p1)并W(p2)=空</td>
</tr>
</tbody></table>
<h2 id="进程的定义与描述"><a href="#进程的定义与描述" class="headerlink" title="进程的定义与描述"></a>进程的定义与描述</h2><p>定义</p>
<ul>
<li>进程是程序在处理器上的一次执行过程</li>
<li>进程是可以和别的进程并行执行计算</li>
<li>进程可定义为数据结构及能在其上进行操作的一个程序</li>
<li>进程是一个程序关于某个数据集合在处理器上顺序执行所发生的活动</li>
</ul>
<p>特征</p>
<ul>
<li>动态性</li>
<li>并发性</li>
<li>独立性：独立运行的基本单位、资源分配和调度的基本单位</li>
<li>异步性：以独立的不可预知的速度前进</li>
<li>结构特征：程序段、数据段、进程控制块</li>
</ul>
<h2 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h2><ul>
<li><p>进程控制块（PCB）：为每个进程定义的数据结构，是程序能够独立运行，是进程存在的唯一标志。</p>
<p>进程控制块（PCB）的组成：进程标识标识符(PID)、进程当前状态、进程队列指针、程序与数据地址、进程优先级、CPU现场保护区、通信信息、家族联系、占有资源清单。</p>
</li>
<li><p>程序段</p>
</li>
<li><p>数据段</p>
</li>
</ul>
<h2 id="进程与程序"><a href="#进程与程序" class="headerlink" title="进程与程序"></a>进程与程序</h2><table>
<thead>
<tr>
<th>进程</th>
<th>程序</th>
</tr>
</thead>
<tbody><tr>
<td>动态的</td>
<td>静止的</td>
</tr>
<tr>
<td>程序的执行</td>
<td>代码的集合</td>
</tr>
<tr>
<td>暂时的</td>
<td>永久的</td>
</tr>
<tr>
<td>通过调用，一个进程可以执行多个程序</td>
<td>通过多次执行，程序可以产生多个进程</td>
</tr>
<tr>
<td>并行性</td>
<td>无</td>
</tr>
<tr>
<td>组成不同</td>
<td>组成不同</td>
</tr>
</tbody></table>
<h2 id="进程与作业"><a href="#进程与作业" class="headerlink" title="进程与作业"></a>进程与作业</h2><table>
<thead>
<tr>
<th>进程</th>
<th>作业</th>
</tr>
</thead>
<tbody><tr>
<td>完成用户任务的执行实体</td>
<td>用户向计算机提交任务的任务实体</td>
</tr>
<tr>
<td>一个进程不能构成多个作业</td>
<td>一个作业必须至少一个进程组成</td>
</tr>
<tr>
<td>用在所有多道程序中</td>
<td>出现在批处理系统</td>
</tr>
</tbody></table>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><table>
<thead>
<tr>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td>拥有资源的独立单位</td>
<td>不拥有资源，可以访问资源</td>
</tr>
<tr>
<td>可以被处理器独立调度和分配的单元</td>
<td>独立调度的基本单位</td>
</tr>
<tr>
<td>包含线程</td>
<td>是进程内一个执行单元，是进程内可调度的一个实体，是程序中相对独立的控制流序列，不能单独运行，只能在进程中执行</td>
</tr>
</tbody></table>
<p>线程的实现</p>
<ul>
<li>内核级线程：一个线程被阻塞，不影响其他线程工作</li>
<li>用户级线程：一个线程被阻塞，整个进程都要等待。维护需要应用进程，不需要内核特权</li>
</ul>
<p>多线程模型</p>
<ul>
<li>多对一模型：多个用户级线程映射到一个内核级线程上，用户空间管理效率高，不能并行</li>
<li>一对多模型：内核级线程与用户级线程一一对应，当一个线程被阻塞，不影响其他线程</li>
<li>多对多模型：多用户级线程映射到多内核级线程上，打破对用户级的限制，使多个用户级线程真正意义上并行执行</li>
</ul>
<h2 id="进程状态与转换"><a href="#进程状态与转换" class="headerlink" title="进程状态与转换"></a>进程状态与转换</h2><ul>
<li>就绪状态</li>
<li>执行状态（运行状态）</li>
<li>阻塞状态（等待状态）</li>
<li>创建状态</li>
<li>结束状态</li>
</ul>
<p><img src="/2020/03/16/osProcessManager/zhuangtaizhuanhuan.jpg" alt="图片-状态与转换"></p>
<h2 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h2><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>创建原语</p>
<ul>
<li>用户登录</li>
<li>作业调度</li>
<li>请求服务</li>
<li>先向系统申请一个空闲PCB，并指定唯一的进程标识符</li>
<li>为新进程分配必要的资源</li>
<li>新进程PCB初始化</li>
<li>新进程PCB插入就绪队列</li>
</ul>
<h3 id="进程的撤销"><a href="#进程的撤销" class="headerlink" title="进程的撤销"></a>进程的撤销</h3><ul>
<li>先从PCB集合中找到被撤销的PCB</li>
<li>若该进程正在执行，则立即停止，设置重新调度标志，以便将处理器分配给其他进程</li>
<li>若撤销的进程有子孙进程，将子孙进程也予以撤销</li>
<li>回收撤销进程所占有的资源，归还给父进程或系统，回收它的PCB</li>
</ul>
<h3 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h3><ul>
<li>首先停止当前进程运行，中断处理器</li>
<li>保存该进程CPU现场以便可以重新调用</li>
<li>停止运行该进程，将状态改为阻塞状态</li>
<li>转到进程调度程序，从就绪队列中选一个新的进程投入运行</li>
</ul>
<h3 id="进程的唤醒"><a href="#进程的唤醒" class="headerlink" title="进程的唤醒"></a>进程的唤醒</h3><ul>
<li>将被唤醒的进程从相应的等待队列中移出</li>
<li>将状态改为就绪，并插入相应的就绪队列中</li>
</ul>
<h3 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h3><ul>
<li>保存处理及上下文</li>
<li>更新PCB</li>
<li>把进程PCB移入相应队列</li>
<li>选择另一个进程执行，更新其PCB</li>
<li>更新内存管理的数据结构</li>
<li>恢复处理器上下文</li>
</ul>
<h2 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h2><ul>
<li>共享存储器系统：在存储器中划分一大片区域，多线程可以共享便于信息传输</li>
<li>消息传递系统<ul>
<li>直接通信方式：发送进程把消息发给接收进程，并将消息挂在进程消息缓冲队列上，接收进程从消息缓冲队列中取得消息</li>
<li>间接通信方式：发送进程把消息把消息发到某个中间实体中，接收进程从中取得消息</li>
</ul>
</li>
<li>管道通信系统：连接读进程和写进程以实现他们之间通信的共享文件</li>
</ul>
<h1 id="处理器调度"><a href="#处理器调度" class="headerlink" title="处理器调度"></a>处理器调度</h1><h2 id="三级调度"><a href="#三级调度" class="headerlink" title="三级调度"></a>三级调度</h2><ul>
<li>高级调度（作业调度，宏观，长程）：从外存中选择一个作业进行资源分配，建立相应进程，几分钟一次</li>
<li>中级调度（中程调度或交换调度）：提高内存利用率和系统吞吐量，按照一定原则将处于外存对换区中的具备运行条件的进程调入内存，并修改其状态为就绪</li>
<li>低级调度（进程调度，微观，短程）：从就绪队列中取一个进程分配处理器给它，几十毫秒一次</li>
</ul>
<p><img src="/2020/03/16/osProcessManager/sanjidiaodu.jpg" alt="图片-调度"></p>
<h2 id="调度的基本原则"><a href="#调度的基本原则" class="headerlink" title="调度的基本原则"></a>调度的基本原则</h2><ul>
<li>CPU利用率</li>
<li>系统吞吐量：单位时间CPU完成作业的数量</li>
<li>响应时间</li>
<li>周转时间<ul>
<li>周转时间：作业i完成时间-作业i提交时间</li>
<li>平均周转时间：n个作业，周转时间之和/n</li>
<li>带权周转时间：周转时间/运行时间</li>
<li>平均带权周转时间：带权之和/n</li>
</ul>
</li>
</ul>
<h2 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h2><p>功能</p>
<ul>
<li>记录系统中所有进程的有关情况以及状态特征</li>
<li>选择获取处理器的进程</li>
<li>处理器分配</li>
</ul>
<p>原因</p>
<ul>
<li>进程运行结束</li>
<li>以某种原因，进程进入阻塞</li>
<li>执行完系统调用返回用户进程，准备调用新的用户进程</li>
<li>在抢占调度方式的系统中，更高优先级进程请求使用处理器</li>
<li>分时系统中，分给该进程的时间片以用完</li>
</ul>
<p>不能进行进程调度的情况</p>
<ul>
<li>处理中断的过程中</li>
<li>在操作系统内核程序临界区中</li>
<li>其他需要屏蔽中断程序的原子操作中</li>
</ul>
<p>进程调度方式</p>
<ul>
<li>抢占方式：可以在执行中暂停，分配给其他进程</li>
<li>非抢占方式：必须执行完毕或阻塞才可以分配其他进程</li>
</ul>
<h2 id="常见调度算法"><a href="#常见调度算法" class="headerlink" title="常见调度算法"></a>常见调度算法</h2><ul>
<li>先来先服务调度算法(作业调度，进程调度)</li>
<li>短作业优先调度算法(作业调度，进程调度)</li>
<li>优先级调度算法(作业调度，进程调度)<ul>
<li>按进程类确定</li>
<li>按作业资源确定</li>
<li>按用户类型和要求确定</li>
<li>根据占有CPU时间长短确定</li>
<li>根据就绪进程等待CPU的长度</li>
</ul>
</li>
<li>时间片轮转调度算法(进程调度)<ul>
<li>系统响应时间</li>
<li>就绪队列中的进程数目</li>
<li>系统的处理能力</li>
</ul>
</li>
<li>高响应比优先调度算法(作业调度)：作业响应时间/估计运行时间</li>
<li>多级队列调度算法(进程调度)</li>
<li>多级反馈队列调度算法(进程调度)</li>
</ul>
<h1 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h1><h2 id="制约关系"><a href="#制约关系" class="headerlink" title="制约关系"></a>制约关系</h2><ul>
<li>间接相互制约：多个同种进程互斥的共享某种资源</li>
<li>直接相互制约：进程间的合作</li>
</ul>
<h2 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h2><ul>
<li>同时仅允许一个进程使用</li>
<li>访问过程<ul>
<li>进入区</li>
<li>临界区：用于访问临界资源的代码</li>
<li>退出区：将正在访问的标志清除</li>
<li>剩余区</li>
</ul>
</li>
</ul>
<h2 id="遵循原则"><a href="#遵循原则" class="headerlink" title="遵循原则"></a>遵循原则</h2><ul>
<li>空闲让进：空闲时就可以进入</li>
<li>忙则等待</li>
<li>有限等待：有限时间等待</li>
<li>让权等待：优先进入</li>
</ul>
<h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>互斥是由程序共享资源所引起的，某一个资源不允许同时多个程序访问，那么解决方法是要么访问其他空闲的同种资源，要么等待这一资源。等待这一资源就要在操作系统实现互斥：当一个进程正在使用资源的时候，其他希望使用该资源的程序必须等待，当该进程使用完并释放资源后，才允许其他进程去访问此资源，我们称这种进程之间的互相制约关系叫做互斥。</p>
<h3 id="互斥的实现软件方法"><a href="#互斥的实现软件方法" class="headerlink" title="互斥的实现软件方法"></a>互斥的实现软件方法</h3><p>算法一：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">turn</span> = <span class="number">0</span>;</span><br><span class="line">P0: &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">turn</span> == <span class="number">0</span>)</span><br><span class="line">            P0的临界区代码CS0；</span><br><span class="line">            <span class="built_in">turn</span> = <span class="number">1</span>；</span><br><span class="line">            进程的其他代码codesegment1；</span><br><span class="line">           &#125;</span><br><span class="line">        <span class="keyword">while</span>(ture)；</span><br><span class="line">    &#125;</span><br><span class="line">P1: &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">turn</span> == <span class="number">1</span>)</span><br><span class="line">            P1的临界区代码CS1；</span><br><span class="line">            <span class="built_in">turn</span> = <span class="number">0</span>；</span><br><span class="line">            进程的其他代码codesegment2；</span><br><span class="line">           &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)；</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>算法二：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">boolean</span> &#123;<span class="literal">true</span>, <span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">boolean</span> flag[<span class="number">2</span>] = &#123;<span class="literal">false</span>, <span class="literal">false</span>&#125;;</span><br><span class="line">P0 &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> flag[<span class="number">1</span>];</span><br><span class="line">            flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">            CS0;</span><br><span class="line">            flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">            codesegment1;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">P1: &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> flag[<span class="number">0</span>];</span><br><span class="line">            flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            CS1;</span><br><span class="line">            flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">            codesegment2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>算法三：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">boolean</span>&#123;<span class="literal">false</span>, <span class="literal">true</span>&#125;;</span><br><span class="line"><span class="keyword">boolean</span> flag[<span class="number">2</span>] = &#123;<span class="literal">false</span>, <span class="literal">false</span>&#125;;</span><br><span class="line">P0 &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> flag[<span class="number">1</span>];</span><br><span class="line">        CS0;</span><br><span class="line">        flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">        codesegment1;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">P1: &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span> flag[<span class="number">0</span>]; </span><br><span class="line">            CS1;</span><br><span class="line">            flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">            codesegment2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>算法四：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">boolean</span>&#123;<span class="literal">false</span>, <span class="literal">true</span>&#125;;</span><br><span class="line"><span class="keyword">boolean</span> flag[<span class="number">2</span>] = &#123;<span class="literal">false</span>, <span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">turn</span>;</span><br><span class="line">P0 &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">turn</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> flag[<span class="number">1</span>] &amp;&amp; <span class="built_in">turn</span> == <span class="number">1</span>;</span><br><span class="line">        CS0;</span><br><span class="line">        flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">        codesegment1;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">P1: &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">turn</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> flag[<span class="number">0</span>] &amp;&amp; <span class="built_in">turn</span> == <span class="number">0</span>; </span><br><span class="line">            CS1;</span><br><span class="line">            flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">            codesegment2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="互斥的实现硬件方法"><a href="#互斥的实现硬件方法" class="headerlink" title="互斥的实现硬件方法"></a>互斥的实现硬件方法</h3><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><h3 id="原语的定义"><a href="#原语的定义" class="headerlink" title="原语的定义"></a>原语的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    queueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semWait</span><span class="params">(semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="keyword">if</span>(s.count&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*把当前进程插入阻塞队列*/</span></span><br><span class="line">        <span class="comment">/*阻塞当前进程*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semSignal</span><span class="params">(semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.count++;</span><br><span class="line">    <span class="keyword">if</span>(s.count&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*把进程从阻塞队列中移除*/</span></span><br><span class="line">        <span class="comment">/*把进程插入就绪队列*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>整型信号量</li>
<li>记录型信号量</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>进程同步</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore N=<span class="number">0</span>;			<span class="comment">//设置信号量并设置初值为0</span></span><br><span class="line">P1()&#123;</span><br><span class="line">	……</span><br><span class="line">	S1;</span><br><span class="line">	V(N);</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br><span class="line">P2()&#123;</span><br><span class="line">	……</span><br><span class="line">	P(N);</span><br><span class="line">	S2;</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进程互斥</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore N=<span class="number">1</span>;</span><br><span class="line">P1()&#123;</span><br><span class="line">	……</span><br><span class="line">    P(N);</span><br><span class="line">    P1的临界区代码;</span><br><span class="line">	V(N);</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br><span class="line">P2()&#123;</span><br><span class="line">	……</span><br><span class="line">	P(N);</span><br><span class="line">	P2的临界区代码;</span><br><span class="line">	V(N);</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><p>问题描述</p>
<p>一组生产者进程和一组消费者进程共享一个初始为空、大小为n的缓冲区，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个消费者从中取出消息。</p>
<p>问题分析</p>
<p>1) 关系分析。生产者和消费者对缓冲区互斥访问是互斥关系，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者才能消费，他们也是同步关系。</p>
<p> 2) 整理思路。这里比较简单，只有生产者和消费者两个进程，正好是这两个进程存在着互斥关系和同步关系。那么需要解决的是互斥和同步PV操作的位置。</p>
<p> 3) 信号量设置。信号量mutex作为互斥信号量，它用于控制互斥访问缓冲池，互斥信号量初值为1；信号量full用于记录当前缓冲池中“满”缓冲区数，初值为0。信号量empty 用于记录当前缓冲池中“空”缓冲区数，初值为n。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore mutex=<span class="number">1</span>; <span class="comment">//临界区互斥信号量</span></span><br><span class="line">semaphore empty=n;  <span class="comment">//空闲缓冲区</span></span><br><span class="line">semaphore full=<span class="number">0</span>;  <span class="comment">//缓冲区初始化为空</span></span><br><span class="line">producer ()<span class="comment">//生产者进程 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        produce an item in nextp;  <span class="comment">//生产数据</span></span><br><span class="line">        P(empty);  <span class="comment">//获取空缓冲区单元</span></span><br><span class="line">        P(mutex);  <span class="comment">//进入临界区.</span></span><br><span class="line">        add nextp to <span class="built_in">buffer</span>;  <span class="comment">//将数据放入缓冲区</span></span><br><span class="line">        V(mutex);  <span class="comment">//离开临界区,释放互斥信号量</span></span><br><span class="line">        V(full);  <span class="comment">//满缓冲区数加1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer ()<span class="comment">//消费者进程</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P(full);  <span class="comment">//获取满缓冲区单元</span></span><br><span class="line">        P(mutex);  <span class="comment">// 进入临界区</span></span><br><span class="line">        <span class="built_in">remove</span> an item from <span class="built_in">buffer</span>;  <span class="comment">//从缓冲区中取出数据</span></span><br><span class="line">        V (mutex);  <span class="comment">//离开临界区，释放互斥信号量</span></span><br><span class="line">        V (empty) ;  <span class="comment">//空缓冲区数加1</span></span><br><span class="line">        consume the item;  <span class="comment">//消费数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h3><p>问题描述</p>
<p>有读者和写者两组并发进程，共享一个文件，当两个或以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：①允许多个读者可以同时对文件执行读操作；②只允许一个写者往文件中写信息；③任一写者在完成写操作之前不允许其他读者或写者工作；④写者执行写操作前，应让已有的读者和写者全部退出。</p>
<p>问题分析</p>
<p>1) 关系分析。由题目分析读者和写者是互斥的，写者和写者也是互斥的，而读者和读者不存在互斥问题。</p>
<p> 2) 整理思路。两个进程，即读者和写者。写者是比较简单的，它和任何进程互斥，用互斥信号量的P操作、V操作即可解决。读者的问题比较复杂，它必须实现与写者互斥的同时还要实现与其他读者的同步，因此，仅仅简单的一对P操作、V操作是无法解决的。那么，在这里用到了一个计数器，用它来判断当前是否有读者读文件。当有读者的时候写者是无法写文件的，此时读者会一直占用文件，当没有读者的时候写者才可以写文件。同时这里不同读者对计数器的访问也应该是互斥的。</p>
<p> 3) 信号量设置。首先设置信号量count为计数器，用来记录当前读者数量，初值为0; 设置mutex为互斥信号量，用于保护更新count变量时的互斥；设置互斥信号量rw用于保证读者和写者的互斥访问。</p>
<p>读者优先</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;  <span class="comment">//用于记录当前的读者数量，初值为0</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;  <span class="comment">//用于保护更新count变量时的互斥</span></span><br><span class="line">semaphore rw=<span class="number">1</span>;  <span class="comment">//用于保证读者和写者互斥地访问文件</span></span><br><span class="line">reader () &#123;  <span class="comment">// 读者进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P (mutex) ;  <span class="comment">//互斥访问count变量</span></span><br><span class="line">        <span class="keyword">if</span> (count==<span class="number">0</span>)  <span class="comment">//当第一个读进程读共享文件时</span></span><br><span class="line">            P(rw);  <span class="comment">//阻止写进程写</span></span><br><span class="line">        count++;  <span class="comment">//读者计数器加1</span></span><br><span class="line">        V (mutex) ;  <span class="comment">//释放互斥变量count，允许其他读者使用count</span></span><br><span class="line">        reading;  <span class="comment">//读取</span></span><br><span class="line">        P (mutex) ;  <span class="comment">//申请互斥访问count变量，对其进行操作</span></span><br><span class="line">        count--; <span class="comment">//读者计数器减1</span></span><br><span class="line">        <span class="keyword">if</span> (count==<span class="number">0</span>)  <span class="comment">//当最后一个读进程读完共享文件</span></span><br><span class="line">            V(rw) ;  <span class="comment">//允许写进程写</span></span><br><span class="line">        V (mutex) ;  <span class="comment">//释放互斥变量 count，允许其他读者使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">writer () &#123;  <span class="comment">//写者进程</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        P(rw); <span class="comment">// 互斥访问共享文件</span></span><br><span class="line">        Writing;  <span class="comment">//写入</span></span><br><span class="line">        V(rw) ;  <span class="comment">//释放共享文件，允许其他进程读写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的算法中，读进程是优先的，也就是说，当存在读进程时，写操作将被延迟，并且只要有一个读进程活跃，随后而来的读进程都将被允许访问文件。这样的方式下，会导致写进程可能长时间等待，且存在写进程“饿死”的情况。</p>
<p>公平情况算法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 读者队列初始值为0，其他资源初始值为1*/</span></span><br><span class="line"><span class="keyword">int</span> readCount = <span class="number">0</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//控制互斥访问数据区</span></span><br><span class="line">semaphore wmutex = <span class="number">1</span>;<span class="comment">//读者互斥访问readCount</span></span><br><span class="line">semaphore rmutex = <span class="number">1</span>; <span class="comment">//存在写者时禁止新的读者进入</span></span><br><span class="line">reader()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      P(wmutex);<span class="comment">//检测是否有写者存在，无写者时进入</span></span><br><span class="line">      P(rmutex);  <span class="comment">//申请使用readCount</span></span><br><span class="line">      <span class="keyword">if</span>(!readCount)<span class="comment">//如果此为第一个读者，则阻止写者进入</span></span><br><span class="line">         P(mutex);</span><br><span class="line">      readCount++;<span class="comment">//读者数量加1</span></span><br><span class="line">      V(rmutex);<span class="comment">//释放readCount的使用权，允许其他读者使用</span></span><br><span class="line">      V(wmutex);<span class="comment">//恢复wmutex</span></span><br><span class="line">      进行读操作</span><br><span class="line">      P(rmutex);  <span class="comment">//申请使用readCount，要对其进行操作</span></span><br><span class="line">      readCount--;<span class="comment">//读者数量减一</span></span><br><span class="line">      <span class="keyword">if</span>(!readCount)<span class="comment">//如果没有读者，则释放数据区，允许写者进入</span></span><br><span class="line">         V(mutex);</span><br><span class="line">    V(rmutex); <span class="comment">//释放readCount的使用权，允许其他读者使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">writer()</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">     &#123;</span><br><span class="line">        P(wmutex);     <span class="comment">//检测是否有其他写者存在，无写者时进入</span></span><br><span class="line">        P(mutex);       <span class="comment">//申请对数据区进行访问</span></span><br><span class="line">        进行写操作</span><br><span class="line">        V(mutex);   <span class="comment">//释放数据区，允许其他进程读写</span></span><br><span class="line">        V(wmutex); <span class="comment">//恢复wmutex</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写者优先</p>
<p> 如果希望写进程优先，即当有读进程正在读共享文件时，有写进程请求访问，这时应禁止后续读进程的请求，等待到已在共享文件的读进程执行完毕则立即让写进程执行，只有在无写进程执行的情况下才允许读进程再次运行。为此，增加一个信号量并且在上面的程序中 writer()和reader()函数中各增加一对PV操作，就可以得到写进程优先的解决程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> wcount = <span class="number">0</span>;  <span class="comment">//用于记录写者数量 </span></span><br><span class="line"><span class="keyword">int</span> rcount = <span class="number">0</span>;   <span class="comment">//用于记录读者数量</span></span><br><span class="line">semaphore rmutex = <span class="number">1</span>;   <span class="comment">//用于读者进程互斥修改rcount</span></span><br><span class="line">semaphore wmutex = <span class="number">1</span>;   <span class="comment">//用于写者进程互斥修改wcount</span></span><br><span class="line">semaphore file = <span class="number">1</span>;    <span class="comment">//用于读者写者互斥访问数据区</span></span><br><span class="line">semphore  readable = <span class="number">1</span>;     <span class="comment">//表示当前是否有写者</span></span><br><span class="line">reader()</span><br><span class="line">&#123;</span><br><span class="line">    P(readable);<span class="comment">//检查是否存在写者，若没有则占用，进行后续操作 </span></span><br><span class="line">    P(rmutex);<span class="comment">//占用rmutex，准备修改rcount</span></span><br><span class="line">    <span class="keyword">if</span>(rcount == <span class="number">0</span>)<span class="comment">//若第一个为读者，则占用数据区</span></span><br><span class="line">        P(file);   <span class="comment">//申请文件资源 </span></span><br><span class="line">    rcount++;<span class="comment">//读者数量加一</span></span><br><span class="line">    V(rmutex);<span class="comment">//释放rmutex，允许其他读者访问rcount  </span></span><br><span class="line">    V(readable); <span class="comment">//释放readable，允许其他读者或写者占用</span></span><br><span class="line">    读操作</span><br><span class="line">    P(rmutex);<span class="comment">//占用rmutex，准备修改rcount</span></span><br><span class="line">    rcount--;<span class="comment">//读者数量减一</span></span><br><span class="line">    <span class="keyword">if</span>(rcount == <span class="number">0</span>)<span class="comment">//若为最后一个读者，则释放数据区</span></span><br><span class="line">        V(file);</span><br><span class="line">    V(rmutex);<span class="comment">//释放rmutex，允许其他读者访问rcount  </span></span><br><span class="line">&#125;</span><br><span class="line">writer()</span><br><span class="line">&#123;</span><br><span class="line">    P(wmutex);<span class="comment">//占用wmutex，准备修改wcount</span></span><br><span class="line">    <span class="keyword">if</span>(wcount == <span class="number">0</span>)<span class="comment">//若第一个为写者，则阻止后续读者进入</span></span><br><span class="line">        P(readable);</span><br><span class="line">    wcount++;<span class="comment">//写者数量加一</span></span><br><span class="line">    V(wmutex);<span class="comment">//释放wmutex，允许其他写者修改wmutex    </span></span><br><span class="line">    P(file);<span class="comment">//等待当前正在操作的读者或写者完成后，占用数据区</span></span><br><span class="line">    写操作</span><br><span class="line">    V(file);<span class="comment">//写完释放数据区 </span></span><br><span class="line">    P(wmutex);<span class="comment">//占用wmutex，准备修改wcount</span></span><br><span class="line">    wcount--;<span class="comment">//写者数量减一</span></span><br><span class="line">    <span class="keyword">if</span>(wcount == <span class="number">0</span>)<span class="comment">//若最后一个为写者，则允许读者进入</span></span><br><span class="line">        V(readable);</span><br><span class="line">    V(wmutex);<span class="comment">//释放wmutex，允许其他写者修改wmutex </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哲学家进餐问题</p>
<p>问题描述</p>
<p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭，如图2-10所示。哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿的时候，才试图拿起左、 右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>
<p>问题分析</p>
<p>1) 关系分析。5名哲学家与左右邻居对其中间筷子的访问是互斥关系。</p>
<p> 2) 整理思路。显然这里有五个进程。本题的关键是如何让一个哲学家拿到左右两个筷子而不造成死锁或者饥饿现象。那么解决方法有两个，一个是让他们同时拿两个筷子；二是对每个哲学家的动作制定规则，避免饥饿或者死锁现象的发生。</p>
<p> 3) 信号量设置。定义互斥信号量数组Ch0PstiCk[5] = {l, 1, 1, 1, 1}用于对5个筷子的互斥访问。</p>
<p> 对哲学家按顺序从0～4编号，哲学家i左边的筷子的编号为i，哲学家右边的筷子的编号为(i+l)%5。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;; <span class="comment">//定义信号量数组chopstick[5],并初始化</span></span><br><span class="line">Pi()&#123;  <span class="comment">//i号哲学家的进程</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        P (chopstick[i] ) ; <span class="comment">//取左边筷子</span></span><br><span class="line">        P (chopstick[(i+<span class="number">1</span>) %<span class="number">5</span>] ) ；  <span class="comment">//取右边篌子</span></span><br><span class="line">        eat;  <span class="comment">//进餐</span></span><br><span class="line">        V(chopstick[i]) ; <span class="comment">//放回左边筷子</span></span><br><span class="line">        V(chopstick[(i+l)%<span class="number">5</span>]);  <span class="comment">//放回右边筷子</span></span><br><span class="line">        think;  <span class="comment">//思考</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了防止死锁的发生，可以对哲学家进程施加一些限制条件，比如至多允许四个哲学家同时进餐;仅当一个哲学家左右两边的筷子都可用时才允许他抓起筷子;对哲学家顺序编号，要求奇数号哲学家先抓左边的筷子，然后再转他右边的筷子，而偶数号哲学家刚好相反。正解制定规则如下：假设釆用第二种方法，当一个哲学家左右两边的筷子都可用时，才允许他抓起筷子。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">philosopher(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		思考;</span><br><span class="line">        想吃饭;</span><br><span class="line">		<span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>) <span class="comment">//偶数哲学家，先拿起右边的筷子后左边的。</span></span><br><span class="line">		&#123;</span><br><span class="line">			P (chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line">			P (chopstick[i]) ;</span><br><span class="line">			进餐</span><br><span class="line">			V (chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line">			V (chopstick[i]) ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">//奇数哲学家，先拿起左边的筷子后右边的。</span></span><br><span class="line">		&#123;</span><br><span class="line">			P (chopstick[i]) ;</span><br><span class="line">			P (chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line">			进餐</span><br><span class="line">			V (chopstick[i]) ;</span><br><span class="line">			V (chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理发师问题</p>
<p>问题描述</p>
<p>一个理发店由一个有几张椅子的等待室和一个放有一张理发椅的理发室组成。<br>     1． 若没有要理发的顾客，则理发师去睡觉；<br>     2． 若一顾客进入理发店，理发师正在为别人理发，且等待室有空椅子，则该顾客就找张椅子按顺序坐下；<br>     3． 若一顾客进入理发店，理发师在睡觉，则叫醒理发师为该顾客理发；<br>     4． 若一顾客进入理发店且所有椅子都被占用了，则该顾客就离开。<br>问题分析<br>引入3个信号量和一个控制变量：<br>    1)控制变量waiting用来记录等候理发的顾客数，初值均为0;<br>    2)信号量customers用来记录等候理发的顾客数，并用作阻塞理发师进程，初值为0;<br>    3)信号量barbers用来记录正在等候顾客的理发师数，并用作阻塞顾客进程，初值为0（刚开始时理发师在睡觉,所以理发师这个资源数目为0）;<br>    4)信号量mutex用于互斥，初值为1. </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">萝卜坑</span><br></pre></td></tr></table></figure>

<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><ul>
<li>定义了一个数据结构和能为并发进程所执行的一组操作</li>
<li>把分散在各个进程中互斥访问公共变量的临界区集中起来，提供对他们的保护</li>
<li>局部于管程的数据只能被局部与管程的过程访问</li>
<li>一个进程只有调用管程内的过程才能进入管程访问共享数据</li>
<li>每次仅允许一个进程在管程内执行某个过程</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><ul>
<li>参与死锁的进程至少两个</li>
<li>每个参与死锁的进程均等待资源</li>
<li>参与死锁的进程至少有两个进程占有资源</li>
<li>死锁进程是系统中当前进程集合的一个子集</li>
</ul>
<p>产生原因：资源竞争</p>
<h3 id="资源的分类"><a href="#资源的分类" class="headerlink" title="资源的分类"></a>资源的分类</h3><ul>
<li>不可剥夺资源：只有当进程不再使用时才释放，其他进程不可强行剥夺</li>
<li>可剥夺资源：另一个进程可以强行把该资源剥夺归己用</li>
</ul>
<h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ul>
<li>互斥条件：一段时间内某个资源仅为一个进程拥有</li>
<li>不可剥夺条件：未使用完毕时，其他资源不可剥夺</li>
<li>请求与保持条件：每次申请等待新资源，继续占有原来拥有的资源</li>
<li>环路等待条件：一个进程已经获取的资源为下一个进程所请求</li>
</ul>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>鸵鸟算法：视而不见</p>
<p>死锁的预防</p>
<ul>
<li>互斥条件：允许多进程同时访问</li>
<li>不可剥夺条件：一个进程新资源不能立即满足，需要释放已有资源</li>
<li>请求与保持条件：预先静态分配，新资源未产生前不给予使用</li>
<li>环路等待条件：采用有序资源分配法</li>
</ul>
<p>死锁的避免</p>
<ul>
<li>安全状态与不安全状态：分配资源时先计算资源使用的安全性</li>
<li>银行家算法<ul>
<li>可利用资源相邻：Available</li>
<li>最大需求矩阵：Max</li>
<li>分配矩阵：Allocation</li>
<li>需求矩阵：Need</li>
<li>Need[i][j]=Max[i][j]-Allocation[i][j]</li>
</ul>
</li>
</ul>
<p>死锁的检测与解除</p>
<ul>
<li><p>资源分配图（圆圈代表进程，方框标识每类资源）</p>
<p><img src="/2020/03/16/osProcessManager/ziyuanfenpei.jpg" alt="图片-资源分配图"></p>
</li>
<li><p>死锁检测算法</p>
<p><img src="/2020/03/16/osProcessManager/sisuojiance.jpg" alt="图片-死锁检测算法"></p>
</li>
</ul>
<p>死锁与饿死</p>
<ul>
<li>死锁的进程都处于等待状态，忙时等待的进程并非处于等待状态又可能饿死</li>
<li>死锁进程不会释放资源，饿死进程释放不会分配给自己的资源</li>
<li>死锁进程发生循环等待，饿死进程不会</li>
<li>死锁涉及多个进程，饿死进程可能只有一个</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤操作系统</p>
<p><a href="c.biancheng.net/cpp/html/2600.html">C语言中文网</a></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>processManager</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统基本概念</title>
    <url>/2020/03/16/osBasicConcept/</url>
    <content><![CDATA[<h1 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h1><table>
<thead>
<tr>
<th>观点分类</th>
<th>功能</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>用户观点</td>
<td>根部不同计算机设计的不同操作系统，目的是方便用户使用</td>
<td>主机、显示器、键盘</td>
</tr>
<tr>
<td>系统观点</td>
<td>资源管理程序，目的是进行处理器管理、存储器管理、设备管理、信息管理</td>
<td>存储器、处理器、外设和信息</td>
</tr>
<tr>
<td>进程观点</td>
<td>若干可以独立运行的程序和一个对这些程序进行协调的核心所组成</td>
<td>用户进程、系统进程</td>
</tr>
<tr>
<td>虚拟机观点</td>
<td>操作系统为用户使用计算机提供了许多服务功能和良好的工作环境</td>
<td></td>
</tr>
</tbody></table>
<h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><table>
<thead>
<tr>
<th>特征</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>并发性</td>
<td>并行性指两个或多个事件在同一时刻发生，并发性指两个或多个事件在同一时间间隔内发生</td>
</tr>
<tr>
<td>共享性</td>
<td>根据同一时刻是否可以被多人使用，是互斥共享，可以同时访问</td>
</tr>
<tr>
<td>虚拟性</td>
<td>把一个物理上的实体变为若干个逻辑上的对应物，如多道程序设计技术</td>
</tr>
<tr>
<td>异步性</td>
<td>时间不同步</td>
</tr>
</tbody></table>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>裸机上的第一层软件，提供计算机用户与计算机硬件系统之间的接口，可以有效的控制和管理计算机系统中的各种硬件和软件资源，便于合理的组织计算机系统工作流程。</p>
<p>五大基本功能</p>
<ul>
<li><p>处理器（进程）管理</p>
</li>
<li><p>存储器（内存）管理</p>
</li>
<li><p>文件管理</p>
</li>
<li><p>设备管理</p>
</li>
<li><p>用户接口</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>用户命令接口</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>联机命令接口又称交互式命令接口</td>
<td>分时操作系统：用户输入命令需等待处理完成才能输入下一条命令</td>
</tr>
<tr>
<td>脱机命令接口又称批处理命令接口</td>
<td>适用于批处理系统：由一组作业控制命令组成，用户期间不能干预 程序接口（系统调用） 图形接口</td>
</tr>
</tbody></table>
<h1 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h1><h2 id="无操作系统阶段"><a href="#无操作系统阶段" class="headerlink" title="无操作系统阶段"></a>无操作系统阶段</h2><ul>
<li>手工输入输出</li>
<li>脱机输入、输出技术</li>
</ul>
<h2 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h2><p>属于操作系统前身，具有自动性、顺序性、单道性。</p>
<h2 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h2><ul>
<li>多道</li>
<li>宏观上并行</li>
<li>微观上串行</li>
<li>如何分配处理器，如何回收，如何利用率高</li>
<li>如何为每道程序分配必要的内存空间，各得其所又不相互干扰，不因其他程序异常而受影响</li>
<li>系统中可能有多种类型的I/O设备共多道程序共享，应如何分配这些I/O设备，如何做到既方便用户对设备的使用，又能提高设备利用率</li>
<li>怎样保证所存放大量程序既便于用户使用，又保证数据的安全性和一致性</li>
<li>对于不同类型的作业（计算型、I\O型、有的重要紧迫，有的需要及时响应）如何组织</li>
</ul>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><h2 id="批处理操作系统"><a href="#批处理操作系统" class="headerlink" title="批处理操作系统"></a>批处理操作系统</h2><ul>
<li>脱机使用，获得结果前不进行交互</li>
<li>成批处理：作业分批提交，监督程序负责每批作业间的自动调度</li>
<li>多道程序运行：选取多个作业调入内存并组织运行</li>
</ul>
<h2 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h2><ul>
<li>实现方法<ul>
<li>简单分时操作系统，每个作业运行一个时间片，轮流从外存调入内存</li>
<li>具有前台和后台的分时操作系统，前台存放时间片调入调出的作业流，当前台正在调入调出，或无调入调出时，在运行后台，给它分配更长时间</li>
<li>多道分时操作系统，在内存中排队，轮流使用</li>
</ul>
</li>
<li>特征：多路性、交互性、独占性、及时性</li>
</ul>
<h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><ul>
<li><p>实时控制系统：以计算机为中心的生产过程控制系统</p>
</li>
<li><p>实时信息处理系统：接受从远程端发来的信息请求</p>
</li>
<li><p>嵌入式操作系统</p>
</li>
<li><p>集群系统：两个或多个独立的系统耦合起来</p>
</li>
<li><p>网络操作系统：将物理上分散的具有自制功能的多个计算机系统互连起来</p>
</li>
<li><p>分布式操作系统：多个分散的处理单元经互联网连接而成</p>
</li>
</ul>
<h1 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h1><h2 id="态"><a href="#态" class="headerlink" title="态"></a>态</h2><table>
<thead>
<tr>
<th>态</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>核心态（管态、系统态）</td>
<td>具有较高的特权，能执行包括特权指令的一切指令</td>
</tr>
<tr>
<td>用户态（目态）</td>
<td>只能执行规定指令</td>
</tr>
</tbody></table>
<p>核心态具有较高的特权，能执行包括特权指令的一切指令</p>
<ul>
<li>特权指令：I/O指令、中断屏蔽指令、清内存指令、存储保护指令、设置时钟指令</li>
<li>内核指令<ul>
<li>时钟管理：通过时钟管理实现进程的切换（如时间片轮转调度）</li>
<li>中断机制</li>
<li>源语（一些关闭中断的小程序）<ul>
<li>处于操作系统底层，最接近硬件部分</li>
<li>具有原子性</li>
<li>运行时间短，调用频繁</li>
</ul>
</li>
<li>系统控制的数据结构及处理</li>
</ul>
</li>
</ul>
<h2 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h2><table>
<thead>
<tr>
<th>中断与异常</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>中断</td>
<td>内中断</td>
</tr>
<tr>
<td>异常</td>
<td>外中断</td>
</tr>
</tbody></table>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><ul>
<li>程序接口或应用编程接口</li>
<li>准备并传递系统调用所需参数</li>
<li>通过陷入指令进入操作系统的系统内核</li>
<li>从用户态进入内核态执行相应的系统函数</li>
<li>将处理结果返回用户进程，从内核态返回用户态</li>
</ul>
<h1 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h1><table>
<thead>
<tr>
<th>体系结构</th>
<th>功能</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>模块组合结构</td>
<td>每个模块根据要完成的功能划分</td>
<td>结构紧密、接口简单直接、系统效率高</td>
<td>不容易把握模块独立性</td>
</tr>
<tr>
<td>层次结构</td>
<td>使模块调用从无序到有序，模块间只存在单向调用和单向依赖</td>
<td>模块间组织和依赖关系清晰明了</td>
<td>无法进行有效的分层</td>
</tr>
<tr>
<td>微内核结构</td>
<td>只在内核留下基本功能</td>
<td>服务独立的运行在用户进程中，失败也不会引起整个进程崩溃</td>
<td>效率低，微内核本身成为瓶颈</td>
</tr>
</tbody></table>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤操作系统</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>basicConcept</tag>
      </tags>
  </entry>
  <entry>
    <title>应用层相关知识点</title>
    <url>/2020/03/15/netApplicationLayer/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>用户对用户</li>
<li>任务：提供系统与用户的接口</li>
<li>功能：文件传输、访问和管理、电子邮件服务</li>
<li>协议：FTP、SMTP、POP3、HTTP</li>
</ul>
<h1 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h1><table>
<thead>
<tr>
<th>模型</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>C/S（客户/服务器模型）</td>
<td>各计算机地位不平等，网络管理工作有少数服务器承担，可扩展性不佳。</td>
</tr>
<tr>
<td>P2P</td>
<td>计算机任务可以分配到个节点上，系统可扩展性好，网络更加健壮。</td>
</tr>
</tbody></table>
<h1 id="DNS系统"><a href="#DNS系统" class="headerlink" title="DNS系统"></a>DNS系统</h1><h2 id="层次域名空间"><a href="#层次域名空间" class="headerlink" title="层次域名空间"></a>层次域名空间</h2><p>采用了层次树状结构的命名法，即域名。</p>
<p>结构：。。。.二级域名.一级域名.顶级域名</p>
<table>
<thead>
<tr>
<th>顶级域名</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>国家顶级域名</td>
<td>.cn中国 .us美国 .uk英国</td>
</tr>
<tr>
<td>通用顶级域名</td>
<td>.com公司和企业 .net网络服务机构 .org非营利向组织 .edu美国专用的教育机构 .gov美国专用的政府部门 .mil美国专用的军事部门 .int国际组织</td>
</tr>
<tr>
<td>基础结构顶级域名arpa</td>
<td>用于反向域名解析，又称反向域名</td>
</tr>
</tbody></table>
<h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><table>
<thead>
<tr>
<th>域名服务器</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>根域名服务器</td>
<td>是最重要的域名服务器，所有根域名服务器都知道顶级域名服务器的域名和IP地址，本地域名服务器只要无法解析，就求助于根域名服务器，告诉本地域名服务器上一级域名服务器的地址。</td>
</tr>
<tr>
<td>顶级域名服务器</td>
<td>管辖在该顶级域名服务器注册的所有二级服务器，当收到dns请求时，给出结果或者下一步请求的域名服务器的地址。</td>
</tr>
<tr>
<td>权限域名服务器（授权域名服务器）</td>
<td>负责一个区的域名服务，给出结果或下一步应当访问的权限域名服务器。</td>
</tr>
<tr>
<td>本地域名服务器</td>
<td>非常重要，主机发送dns请求时就会将查询请求报文发送给本地域名服务器。</td>
</tr>
</tbody></table>
<h2 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h2><table>
<thead>
<tr>
<th>分类</th>
<th>解析过程</th>
</tr>
</thead>
<tbody><tr>
<td>迭代查询</td>
<td>根域名服务器收到查询请求，要么给出查询结果，要么告诉本地域名服务器下一步向哪个域名服务器进行查询。</td>
</tr>
<tr>
<td>递归查询</td>
<td>本地域名服务器只请求一次，后面几次都是在其他几个域名服务器之间进行的。</td>
</tr>
</tbody></table>
<h1 id="FTP文件传输"><a href="#FTP文件传输" class="headerlink" title="FTP文件传输"></a>FTP文件传输</h1><p>工作原理</p>
<ul>
<li>TCP可靠传输，C/S模型</li>
<li>打开21端口</li>
<li>等待客户进程发出请求</li>
<li>启动从属程序处理请求，从属程序可能会创造一些新的进程</li>
<li>主程序等待其他客户进程发出请求</li>
<li>主程序与从属程序并发进行</li>
</ul>
<table>
<thead>
<tr>
<th>连接分类</th>
<th>端口</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>控制连接</td>
<td>21</td>
<td>客户端通过这个连接发送各种操作请求</td>
</tr>
<tr>
<td>数据连接</td>
<td>20</td>
<td>在文件传输请求后创建数据传送和接收进程，并在传输完成后关闭</td>
</tr>
</tbody></table>
<h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>用户代理<ul>
<li>用户与电子邮件系统的接口，如outlook</li>
</ul>
</li>
<li>邮件服务器<ul>
<li>发送接收邮件，报告邮件传输情况</li>
</ul>
</li>
<li>电子邮件使用协议<ul>
<li>SMTP,POP3</li>
</ul>
</li>
</ul>
<h2 id="发送接收过程"><a href="#发送接收过程" class="headerlink" title="发送接收过程"></a>发送接收过程</h2><ul>
<li>发件人调用用户代理来编辑要发送的邮件</li>
<li>发件人通过用户代理把邮件传送给发送端邮件服务器<ul>
<li>客户端建立TCP连接服务器</li>
<li>服务器发送身份信息，确认连接已经建立</li>
<li>客户端发送身份信息，服务器确认收到</li>
<li>客户端发送邮件接收者地址，服务器确认收到</li>
<li>客户端发送邮件发送者地址，服务器确认收到</li>
<li>客户端请求发送邮件内容，服务器确认准备好</li>
<li>客户端发送邮件内容，最有以一个仅包含.的行结束，服务器发回数据已收到的确认</li>
</ul>
</li>
<li>邮件服务器将邮件放入邮件缓存队列，等待发送</li>
<li>发送端的SMTP进程发现邮件缓存中有邮件，就向接收端SMTP进程建立TCP连接</li>
<li>TCP建立后开始传输邮件，完成后TCP关闭连接</li>
<li>接收端SMTP将邮件放入收件人邮箱</li>
<li>收件人调用用户代理，使用POP3(IMAP)从邮箱中取回<ul>
<li>客户端建立TCP连接至服务器</li>
<li>服务器发送身份信息，确认链接已经建立</li>
<li>客户端发送USER命令+用户名，服务器确认收到</li>
<li>客户端发送PASS命令+用户密码，服务器确认收到</li>
<li>客户端发送LIST命令，服务器返回当前邮件箱的邮件个数列表</li>
<li>客户端发送RETR命令，服务器发回相应的邮件内容</li>
<li>客户端接受完邮件后，选择是否发送DELE命令+邮件编号，通知服务器从邮箱中删除相应的邮件</li>
</ul>
</li>
</ul>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><ul>
<li>To:收件人邮箱地址</li>
<li>Subject：邮件主题</li>
<li>收件人邮箱名@邮箱所在主机域名</li>
<li>MIME<ul>
<li>SMTP只限于传送一定长度的7为ASCII编</li>
<li>MIME意图继续使用目前的RFC 822格式但增加邮件主体的结构，定义传送非ASCII码规则<ul>
<li>quoted-printable<ul>
<li>用=加两个十六进制字符，表示非ASCIII</li>
<li>如，汉字系统两字代码为11000……011，共32位，就表示为=CF=B5=CD=B3</li>
</ul>
</li>
<li>base64<ul>
<li>共64个值，字母大小写，+ / == =</li>
<li>将24位二进制代码划分四个六位组，转化为对应的base64编码，并以这些字符的二进制ASCII编码发送</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><table>
<thead>
<tr>
<th>协议</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SMTP简单邮件传输协议</td>
<td>端口号25，TCP连接，连接建立/邮件发送/连接释放</td>
</tr>
<tr>
<td>POP3邮局协议版本3</td>
<td>在用户计算机中运行POP客户程序，在ISP服务器中运行POP服务程序，用户从POP服务器读取邮件，POP服务器就将该邮件删去。</td>
</tr>
</tbody></table>
<h1 id="WWW万维网"><a href="#WWW万维网" class="headerlink" title="WWW万维网"></a>WWW万维网</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>一个大规模联机式的信息贮藏所</li>
<li>用统一资源定位符来标识URL的各种文档，&lt;协议&gt;://&lt;主机&gt;:&lt;端口号&gt;/&lt;路径&gt;</li>
</ul>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul>
<li>Web用户使用浏览器指定URL与Web服务器建立连接，并发送浏览请求</li>
<li>Web服务器吧URL转化为文件路径，并返回信息给Web浏览器</li>
<li>通信完成，关闭连接</li>
</ul>
<h2 id="HTTP超文本传送协议"><a href="#HTTP超文本传送协议" class="headerlink" title="HTTP超文本传送协议"></a>HTTP超文本传送协议</h2><p>端口80，是TCP可靠连接</p>
<p>报文：</p>
<ul>
<li>请求报文：客户向服务器发送请求报文</li>
<li>响应报文：从服务器到客户的回答</li>
<li>内容<ul>
<li>开始行，区别请求报文(请求行，方法、目标URL)和响应报文(状态行，版本、状态码)</li>
<li>首部行，说明浏览器，服务器，报文主体的一些信息</li>
<li>实体主体，不一定有</li>
</ul>
</li>
<li>方法<ul>
<li>GET：请求读取由URL所标识的信息</li>
<li>HEAD：读取由URL所标识的信息首部</li>
<li>POST：给服务器添加信息</li>
<li>CONNECT：用于代理服务器</li>
</ul>
</li>
<li>工作方式<ul>
<li>非持久连接：每个网页元素都需要单独建立一次TCP三次握手</li>
<li>持久连接：发送响应后仍保持这条连接</li>
</ul>
</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤计算机网络</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>applicationLayer</tag>
      </tags>
  </entry>
  <entry>
    <title>传输层相关知识点</title>
    <url>/2020/03/15/netTransportLayer/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>应用对应用、进程对进程</li>
<li>单位：(segments段)报文段TCP、用户数据报UDP</li>
<li>任务：负责主机中两个进程之间的通信</li>
<li>功能<ul>
<li>为端到端连接提供可靠的传输服务</li>
<li>为端到端连接提供流量控制、差错控制、服务质量等管理服务</li>
<li>提供应用进程间的逻辑通信</li>
<li>差错检测</li>
<li>提供无连接和面向连接的服务</li>
<li>复用和分用</li>
<li>单独TCP的有：连接管理、流量控制与拥塞控制</li>
</ul>
</li>
</ul>
<h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><p>传输层按端口号寻址，类似数据链路层按mac，网络层按ip</p>
<p>熟知端口号：0~1023</p>
<table>
<thead>
<tr>
<th>应用</th>
<th>端口</th>
</tr>
</thead>
<tbody><tr>
<td>FTP</td>
<td>21,20</td>
</tr>
<tr>
<td>TELNET</td>
<td>23</td>
</tr>
<tr>
<td>SMTP</td>
<td>25</td>
</tr>
<tr>
<td>DNS</td>
<td>53</td>
</tr>
<tr>
<td>TFTP</td>
<td>69</td>
</tr>
<tr>
<td>HTTP</td>
<td>80</td>
</tr>
<tr>
<td>SNMP</td>
<td>161</td>
</tr>
</tbody></table>
<p>登记端口号：1024~49151（为没有熟知端口号的程序使用、须在IANA登记）</p>
<p>客户端端口或短暂端口：49152~65535</p>
<p>套接字：（主机IP地址，端口号）唯一标识了网络中的某台主机上的某个应用进程</p>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>传输数据前无需建立连接，数据到达后也无需确认</li>
<li>不可靠交付</li>
<li>报文头部短，传输开销小，时延较短</li>
<li>不需维持复杂的连接状态表</li>
<li>用户数据报只有8个字节的首部开销</li>
<li>网络拥塞不会使源主机的发送速率降低</li>
<li>支持一对一、一对多、多对多、多对一的交互通信</li>
</ul>
<h2 id="数据包组成"><a href="#数据包组成" class="headerlink" title="数据包组成"></a>数据包组成</h2><p>源端口、目的端口、长度、校验和</p>
<h2 id="UDP校验"><a href="#UDP校验" class="headerlink" title="UDP校验"></a>UDP校验</h2><ul>
<li>只提供差错校验，计算校验时在用户数据报之前加上12B的伪首部</li>
<li>伪首部包括源IP地址字段、目的IP地址字段、全0字段、协议字段、UDP长度字段</li>
<li>伪首部只用于验证校验和，既不向下传送，也不向上传递</li>
<li>二进制反码运算求和，无差错时其结果全为1<ul>
<li>从低位到高位逐列运算</li>
<li>0+0=0 1+0=1 1+1=0进1</li>
<li>最高位产生进位，最后结果加1</li>
</ul>
</li>
</ul>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul>
<li>面向连接，不提供广播或多播服务</li>
<li>可靠交付</li>
<li>报文段头部长，传输开销大</li>
</ul>
<h2 id="报文段组成"><a href="#报文段组成" class="headerlink" title="报文段组成"></a>报文段组成</h2><p><img src="/2020/03/15/netTransportLayer/baowenduan.png" alt="baowenduan"></p>
<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><ul>
<li>两个套接字：{socket1，socket2}={(IP1:port1),(IP2:port2)}</li>
<li>三次握手</li>
<li>四次释放</li>
</ul>
<h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><p>TCP数据编号与确认</p>
<ul>
<li>将传送的报文看成是字节组成的数据流，每个字节对应一个序号</li>
<li>建立连接时双方要商定初始序号，报文首部中的序号字段数值，表示该报文段中的数据部分的第一个 字节的序号</li>
<li>确认是对接收到的数据最高序号表示确认</li>
<li>接收端返回的序号是已收到的数据最高序号加1，表示接收端期望下次收到的数据中第一个数据字节的序号</li>
</ul>
<p>TCP的重传机制</p>
<ul>
<li>每发送一个报文段，就对设置一次计时器，如果规定时间内没有收到确认，就重传该报文</li>
<li>计算超时计时器的重传时间<ul>
<li>RTT<ul>
<li>记录每个报文段发出的时间以及收到相应的确认报文段的时间，这两个时间之差就是报文段的往返时延</li>
<li>将各报文段的往返时延样本加权平均，就得出报文段的平均往返时延RTT</li>
<li>每侧量到一个新的往返时延样本，就按下式重新计算一次平均往返时延RTT=(1-a)<em>(旧的RTT)+a</em>(新的往返时延样本)</li>
<li>超时重传时间ROT:新的(ROT)=b*(RTT)</li>
</ul>
</li>
<li>Karn<ul>
<li>新的(ROT)=c*旧的(ROT)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><ul>
<li>利用滑动窗口控制实现流量控制</li>
<li>TCP为每个报文设有一个持续计数器，只要收到对方的零窗口通知就启动持续计时器，时间到就发送一个零窗口探测报文段，对方在探测这个报文段时就给出了现在的窗口值，若是零就重新计时，若不是就打破死锁僵局</li>
<li>三种机制<ul>
<li>TCP维持一个变量，等于最大报文段长度MSS，只要缓存中存放的数据达到MSS字节时，就组装成一个TCP报文段发送出去</li>
<li>由发送方应用进程指名要求发送报文段，即TCP的推动Push操作</li>
<li>发送方的一个计时器期限到了，就把已有的缓存数据装入报文段，但长度不超过MSS并发送出去</li>
</ul>
</li>
</ul>
<p><img src="/2020/03/15/netTransportLayer/liuliangkongzhi.jpg" alt="图片-流量控制"></p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul>
<li>目的：使网络能够承受现有的网络负荷</li>
<li>是一个全局过程，涉及所有主机路由器以及与降低网络传输性能有关的所有因素</li>
<li>指给定发送端和接收端之间的点对点通信量的控制</li>
<li>分组丢失是网络发生拥塞的征兆而不是原因</li>
<li>拥塞本身成为引起网络性能恶化甚至发生死锁的原因</li>
</ul>
<h3 id="控制分类"><a href="#控制分类" class="headerlink" title="控制分类"></a>控制分类</h3><table>
<thead>
<tr>
<th>控制分类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>闭环控制</td>
<td>事先将有关发生拥塞的因素考虑周到，力求网络在工作中不发生拥塞</td>
</tr>
<tr>
<td>开环控制</td>
<td>监测网络系统以便检测到拥塞何时何处发生、将拥塞发生的信息传送到可采取行动的地方、调整网络的运行以解决问题</td>
</tr>
</tbody></table>
<h3 id="四种算法"><a href="#四种算法" class="headerlink" title="四种算法"></a>四种算法</h3><p>TCP要求发送端维护两个窗口</p>
<ul>
<li>接收端窗口rwnd：接收端根据其目前接受缓存大小所需诺的最新窗口值，反映了接收端的容量，有接收端将其放在报文首部的字段通知发送端</li>
<li>拥塞窗口cwnd：发送端根据自己估计的网络拥塞程度而设置的窗口值，反映了网络的当前容量</li>
<li>rwnd&lt;cwnd时：发送窗口的上限值是接受方的接受能力限制发送窗口的最大值</li>
<li>rwnd&gt;cwnd时：发送窗口的上限值是网络拥塞限制发送窗口的最大值</li>
</ul>
<h4 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h4><ul>
<li><p>开始发送报文段时先设置cwnd=1，即设置最大报文段长度MSS的数值</p>
</li>
<li><p>每收到一个对新的报文段的确认后，将拥塞窗口加1，即增加一个MSS的数值</p>
</li>
</ul>
<p><img src="/2020/03/15/netTransportLayer/mankaishi.jpg" alt="图片-慢开始算法"></p>
<h4 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h4><ul>
<li><p>慢开始门限ssthresh</p>
</li>
<li><p>TCP连接进行初始化时，拥塞窗口cwnd=1，慢开始门限初始值设为16个字节ssthresh=16，发送端不能超过拥塞窗口cwnd和接收端窗口rwnd的最小值</p>
</li>
<li><p>执行慢开始算法，cwnd=1，发送第一个报文段M0</p>
</li>
<li><p>发送端每收到一个确认，cwnd++，cwnd=2，发送端接着发送M1M2</p>
</li>
<li><p>发送端收到两个确认，cwnd+=2，cwnd=4，发送端接着可以发四个M</p>
</li>
<li><p>如此按指数增长</p>
</li>
<li><p>当cwnd==ssthresh时，改为执行拥塞避免算法 ，是线性增长的</p>
</li>
<li><p>假定拥塞窗口增长到24时，网络出现超时，表明网络拥塞了</p>
</li>
<li><p>ssthresh变为发送窗口数值的一半，为12，cwnd=1，并执行慢开始算法</p>
</li>
<li><p>当cwnd==ssthresh时执行拥塞避免算法</p>
</li>
</ul>
<p><img src="/2020/03/15/netTransportLayer/yongsebimian.jpg" alt="图片-拥塞避免"></p>
<h4 id="快重传算法"><a href="#快重传算法" class="headerlink" title="快重传算法"></a>快重传算法</h4><ul>
<li><p>要求接收方每收到一个失序的报文段后就立即发出重复确认</p>
</li>
<li><p>只要发送方收到三个重复确认就应当立即重传对方尚未收到的报文段</p>
</li>
</ul>
<p><img src="/2020/03/15/netTransportLayer/kuaichongchuan.jpg" alt="图片-快重传"></p>
<h4 id="快恢复算法"><a href="#快恢复算法" class="headerlink" title="快恢复算法"></a>快恢复算法</h4><ul>
<li><p>当发送方收到3个重复的确认时，就执行乘法减小，把慢开始门限ssthresh设置为当前拥塞窗口的一半，接下去不执行慢开始算法</p>
</li>
<li><p>由于发送方现在认为网络很可能没有发生拥塞，所以不执行慢开始算法，而是将ssthresh设置为当前拥塞窗口的一半，然后开始执行拥塞避免算法</p>
</li>
</ul>
<p><img src="/2020/03/15/netTransportLayer/kuaihuifu.jpg" alt="图片-快恢复"></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤计算机网络</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>transportLayer</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层相关知识点</title>
    <url>/2020/03/15/netNetworkLayer/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>主机对主机</li>
<li>单位：Packets包：数据报</li>
<li>硬件：路由器</li>
<li>任务：将传输层传下来的报文段封装成分组，选择适当的路由，是传输层传下来的分组能够交付到目的主机</li>
<li>功能<ul>
<li>为传输层提供服务</li>
<li>组包和拆包</li>
<li>路由选择：确定进来的分组应该被传送到哪一条路线上</li>
<li>分组转发：将IP数据报从适合的端口转发出去</li>
<li>拥塞控制：开环控制、闭环控制</li>
<li>异构网络互连：各种网络协议不同，但是让用户看起来是一个整体</li>
</ul>
</li>
<li>协议：ICMP、ARP、RARP、IP、IGMP</li>
</ul>
<h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><h3 id="数据报"><a href="#数据报" class="headerlink" title="数据报"></a>数据报</h3><ul>
<li>总长度：数据包的总长是MAC地址数据部分，1500B，如果超出则分片</li>
<li>标志：MF合并数据报、DF=1不可以分片，当数据报过大时，返回ICMP告知最大传输单位、DF=0可以分片传输</li>
</ul>
<h3 id="地址分类"><a href="#地址分类" class="headerlink" title="地址分类"></a>地址分类</h3><table>
<thead>
<tr>
<th>类别</th>
<th>地址</th>
<th>私有地址</th>
</tr>
</thead>
<tbody><tr>
<td>网络号</td>
<td>0.0.0.0</td>
<td>\</td>
</tr>
<tr>
<td>广播地址</td>
<td>255.255.255.255</td>
<td>\</td>
</tr>
<tr>
<td>A类</td>
<td>1.0.0.0~126.255.255.255</td>
<td>10.0.0.0~10.255.255.255</td>
</tr>
<tr>
<td>B类</td>
<td>128.1.0.0~191.255.255.255</td>
<td>172.16.0.0~172.31.255.255</td>
</tr>
<tr>
<td>C类</td>
<td>192.0.1.0~223.255.255.255</td>
<td>192.168.0.0~192.168.255.255</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>特殊地址</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>网络地址</td>
<td></td>
</tr>
<tr>
<td>直接广播地址</td>
<td>主机号全为1，该组所有主机都会收到，只能做目的地址</td>
</tr>
<tr>
<td>受限广播地址</td>
<td>全1，用于定义当前网络</td>
</tr>
<tr>
<td>这个网络上的这个主机</td>
<td>全0，主机为了发现自己的IP地址，使用全0作为源地址，全1作为目的地址</td>
</tr>
<tr>
<td>这个网络上的特定主机</td>
<td>用于某个主机向同一网络上的其他主机发送报文</td>
</tr>
<tr>
<td>回环地址</td>
<td>127开头，用来测试机器的软件，客户机进程用回环地址给同样机器上的服务器进程发送请求</td>
</tr>
</tbody></table>
<h3 id="NAT-内外网转换"><a href="#NAT-内外网转换" class="headerlink" title="NAT(内外网转换)"></a>NAT(内外网转换)</h3><ul>
<li>节省IP地址</li>
<li>隐藏内部真实IP</li>
<li>TCP负载均衡</li>
<li>两网合并，解决内网地址冲突问题</li>
</ul>
<h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p>子网划分</p>
<ul>
<li>由两级变为三级</li>
<li>IP地址：{&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}</li>
</ul>
<p>子网掩码</p>
<ul>
<li>用子网掩码表示网络号长度</li>
</ul>
<h3 id="CIDR无分类编址"><a href="#CIDR无分类编址" class="headerlink" title="CIDR无分类编址"></a>CIDR无分类编址</h3><p>IP地址：{&lt;网络前缀&gt;,&lt;主机号&gt;}，类似于子网掩码</p>
<h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><ul>
<li>解决同一局域网主机或路由器IP地址和硬件地址的映射问题</li>
<li>每个主机中都有ARP高速缓存，用来存放所有局域网上的各主机和路由器的IP地址到硬件地址的映射表</li>
<li>ARP请求分组是广播发送的，响应分组是普通的单播</li>
<li>四种情况<ul>
<li>发送方是主机or路由器，要把IP数据报发送到本网络上的主机，这时用ARP找到目的主机的硬件地址</li>
<li>发送方是主机or路由器，要把IP数据报发送到另一个网络上的主机，这时用ARP找到本网络上的一个路由器的硬件地址，然后交给路由器</li>
</ul>
</li>
</ul>
<h3 id="DHCP动态主机配置协议"><a href="#DHCP动态主机配置协议" class="headerlink" title="DHCP动态主机配置协议"></a>DHCP动态主机配置协议</h3><ul>
<li>动态分配IP地址</li>
<li>允许一台计算机加入新的网络获取IP地址，不需要手工参与</li>
<li>是应用层协议，使用UDP传输</li>
<li>分配的IP地址是临时的，只能在一段时间内（租用期）使用</li>
</ul>
<p>过程</p>
<ul>
<li>DHCP客户机广播“DHCP发现”消息，试图找到网络中的DHCP服务器，服务器获取一个IP地址</li>
<li>DHCP服务器收到“DHCP发现”消息，就向网络提供“DHCP提供”消息，其中包括提供DHCP客户机的IP地址和相关配置信息</li>
<li>DHCP客户机收到“DHCP提供”消息，如果接收DHCP提供的相关参数，则广播“DHCP请求”消息向DHCP服务器请求提供IP地址</li>
<li>DHCP服务器广播“DHCP确认”消息，分配IP地址给DHCP客户机</li>
<li>当有多个客户机请求时，DHCP通常选择最先到达的信息</li>
</ul>
<h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p>差错报告报文</p>
<table>
<thead>
<tr>
<th>差错报告报文</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>终点不可达</td>
<td>路由或主机不能交付数据时，使源点知道终点不可达</td>
</tr>
<tr>
<td>源站抑制</td>
<td>路由或主机由于拥塞而丢弃数据报时，向源点发送，使源点发送速率变慢</td>
</tr>
<tr>
<td>时间超时</td>
<td>当IP分组TTL值被减为0后，路由器除了要丢弃该分组还要向源点发送时间超时；当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，向源点发送时间超时</td>
</tr>
<tr>
<td>参数问题</td>
<td>路由器或目的主机收到的数据报的首部中有字段的值不正确时，就丢弃该数据报，并向源点发送，现在一般不发</td>
</tr>
<tr>
<td>改变路由</td>
<td>重定向，路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给其他的路由器</td>
</tr>
</tbody></table>
<p>询问报文</p>
<ul>
<li>有回送请求和回答报文</li>
<li>时间戳请求和回答报文</li>
<li>掩码地址请求和回答报文</li>
<li>路由器询问和通告报文</li>
</ul>
<p>不发送报告的几种情况</p>
<ul>
<li>对ICMP差错报告报文不再发送ICMP差错报告报文</li>
<li>对第一分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文</li>
<li>对具有组播地址的数据报片都不发送ICMP差错报告报文</li>
<li>对具有特殊地址的数据报片（127.0.0.0或0.0.0.0）不发送ICMP差错报告报文</li>
</ul>
<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>特点</p>
<ul>
<li>128位</li>
<li>十六进制表示，四个一位用冒号隔开，四个全0可写为一个0，连着几个冒号都是0，可不写，但要确定个数只能出现一次</li>
<li>划分层次多</li>
<li>首部格式灵活：减少为8个段，更快处理分组，改善吞吐率</li>
<li>改进的选项：以前必要的现在可选了，加快分组处理速度</li>
<li>允许协议继续扩充</li>
<li>支持即插即用</li>
<li>支持资源的预分配</li>
</ul>
<p>三种地址类型：单播、组播、广播</p>
<h1 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h1><table>
<thead>
<tr>
<th>路由算法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>动态路由</td>
<td>自动学习</td>
</tr>
<tr>
<td>静态路由</td>
<td>手动配置</td>
</tr>
</tbody></table>
<h2 id="内部网关协议IGP"><a href="#内部网关协议IGP" class="headerlink" title="内部网关协议IGP"></a>内部网关协议IGP</h2><p>一个自治系统内部所使用的路由选择协议称为内部网关协议IGP，路由选择称为域内路由选择，具体协议有RIP、OSPF。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>RIP</th>
<th>OSPF</th>
</tr>
</thead>
<tbody><tr>
<td>算法</td>
<td>距离-向量路由算法</td>
<td>链路状态路由算法</td>
</tr>
<tr>
<td>协议参数</td>
<td>用于表示目的网络远近的参数为跳数，即到达目的网络所经过的路由器个数，最大为15</td>
<td>表示的目的网络的数为虚拟值，与链路的带宽相等，不受物理跳数的限制，适合大型网络</td>
</tr>
<tr>
<td>收敛速度</td>
<td>将整个路由表作为路由信息广播至网络中，周期为30s，占用资源，影响收敛</td>
<td>路由信息比较少，广播非周期性，收敛效果好</td>
</tr>
<tr>
<td>分层</td>
<td>网络是平面概念，无区域或边界的定义</td>
<td>网络或自治系统可以划分很多区域，每个区域通过OSPF边界路由相连</td>
</tr>
<tr>
<td>负载平衡</td>
<td>只安装一条路径传输数据</td>
<td>同一个目的网络有多条相同代价的路径，可以将通信量分配给这几条路径</td>
</tr>
<tr>
<td>灵活性</td>
<td>无</td>
<td>对不同链路根据IP分组不同服务类型而设置不同代价</td>
</tr>
<tr>
<td></td>
<td>不以组播地址发送报文</td>
<td>以组播地址发送报文</td>
</tr>
<tr>
<td></td>
<td>采用跳数作为距离的代价</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>将一个自治系统再划分为若干更小的范围，成为区域。</td>
</tr>
<tr>
<td></td>
<td>是被动的，基于谣言的，靠邻居路由判断，仅和邻居交换信息</td>
<td>是独立决策的，会主动测试所有邻接节点的状态，定期的将链路状态传播给其他所有节点，说明本路由器和哪些路由器相邻以及该链路的度量</td>
</tr>
<tr>
<td></td>
<td>交换的信息是当前本路由器所知道的信息，即自己的路由表，并按照固定的时间交换路由信息</td>
<td>使用洪泛法，通过所有输出端口向所有邻接路由，发送的信息是本路由器相邻的所有路由的链路状态，但只是路由器所知道的部分信息。只有链路状态都发生变化时，路由器才用洪泛法向所有路由器发送信息</td>
</tr>
</tbody></table>
<h3 id="RIP距离矢量选择协议"><a href="#RIP距离矢量选择协议" class="headerlink" title="RIP距离矢量选择协议"></a>RIP距离矢量选择协议</h3><ul>
<li><p>先修改此RIP报文中所有项目，把下一跳字段中的地址都改为X，并把所有距离字段+1</p>
</li>
<li><p>对修改后的RIP报文中的每一个项目执行如图操作</p>
<p><img src="/2020/03/15/netNetworkLayer/rip.jpg" alt="图片-RIP执行过程"></p>
</li>
<li><p>若3min还没收到相邻路由器的更新路由表则把相邻路由器记为不可达路由，记为16，若120s后仍未收到更新的报文，则删除</p>
</li>
</ul>
<p>报文格式：首部、路由</p>
<p>优点：简单、开销小、收敛过程较快</p>
<p>缺点</p>
<ul>
<li>RIP限制了网络的规模，它能使用的最大距离为15</li>
<li>路由器之间交换的路由信息是路由器中的最完整路由表，随网络规模增加，开销也增加</li>
<li>当网络出现故障时，经过较长的时间才能将此信息传送到所有的路由器，即坏消息传播的慢，更新过程的收敛时间长</li>
</ul>
<h3 id="OSPF链路状态协议"><a href="#OSPF链路状态协议" class="headerlink" title="OSPF链路状态协议"></a>OSPF链路状态协议</h3><table>
<thead>
<tr>
<th>分组类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>问候分组</td>
<td>发现和维持邻站的可达性</td>
</tr>
<tr>
<td>数据库描述分组</td>
<td>向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息</td>
</tr>
<tr>
<td>链路状态请求分组</td>
<td>向对方请求某些链路的详细信息</td>
</tr>
<tr>
<td>链路状态更新分组</td>
<td>用洪泛法对全网更新链路状态</td>
</tr>
<tr>
<td>链路状态确认分组</td>
<td>对链路更新分组的确认</td>
</tr>
</tbody></table>
<h2 id="外部网关协议EGP"><a href="#外部网关协议EGP" class="headerlink" title="外部网关协议EGP"></a>外部网关协议EGP</h2><p>自治系统之间使用的路由选择协议成为外部网关协议EGP，路由选择成为域间路由选择</p>
<h2 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h2><ul>
<li>不同自治系统之间交换路由信息的协议</li>
<li>路径向量路由选择协议</li>
<li>寻找一条相对来说比较好的路由</li>
<li>特点<ul>
<li>交换路由信息的节点数量级是自治系统数的量级，比自治系统中的网络数少很多</li>
<li>每一个自治系统中BGP发言人的数目很少，系统不过分复杂</li>
<li>支持CIDR，其路由表包括目的网络前缀、下一跳路由器、到达该目的网络所要经过的各个自治系统序列</li>
<li>再BGP刚运行时，BGP的邻站是交换整个的BGP路由表，但以后只需在变化部分更新</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>报文</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>打开报文</td>
<td>用来与相邻的另一个BGP发言人建立关系</td>
</tr>
<tr>
<td>更新报文</td>
<td>用来发送某一路由信息以及列出要撤销的多条路由</td>
</tr>
<tr>
<td>保活报文</td>
<td>用来确认打开报文和周期性的证实邻站关系</td>
</tr>
<tr>
<td>通知报文</td>
<td>用来发送检测到的差错</td>
</tr>
</tbody></table>
<p><img src="/2020/03/15/netNetworkLayer/xieyi.jpg" alt="图片-路由协议"></p>
<h1 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a>IP组播</h1><p>需要支持组播协议的路由器，使用D类地址224.0.0.0~239.255.255.255,前缀1110，只能用于目的地址，尽最大努力交付，不提供可靠传输，不产生ICMP，并非所有D类地址都可以组播。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>只在本局域网上进行硬件组播</li>
<li>在因特网的范围内进行组播</li>
</ul>
<h2 id="组播地址换算MAC"><a href="#组播地址换算MAC" class="headerlink" title="组播地址换算MAC"></a>组播地址换算MAC</h2><ul>
<li>IP地址化为二进制，取最后23位</li>
<li>第24位为0</li>
<li>四位一组换为十六进制</li>
<li>在前面加上固定首部01-00-5E</li>
</ul>
<h1 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h1><p>实现权限漫游的功能</p>
<table>
<thead>
<tr>
<th>功能实体</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>移动节点</td>
<td>具有永久IP地址的移动节点</td>
</tr>
<tr>
<td>本地代理</td>
<td>有一个端口与移动节点本地链路相连的路由器，根据移动用户的转交地址，采用隧道技术转交移动节点的数据报</td>
</tr>
<tr>
<td>外部代理</td>
<td>移动节点的漫游链路上的路由节点，他通知本地用户代理自己的转交地址，是移动节点漫游链路的默认路由器</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>四大技术</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>代理搜索</td>
<td>知道自己是否正在漫游</td>
</tr>
<tr>
<td>申请转交地址</td>
<td>移动节点到外网时从外代理处得到的临时地址</td>
</tr>
<tr>
<td>登录</td>
<td>移动节点到达外网的一系列认证、注册、建立隧道的过程</td>
</tr>
<tr>
<td>隧道</td>
<td>本地代理与外部代理之间建立的双向数据通道</td>
</tr>
</tbody></table>
<p>过程</p>
<ul>
<li>移动节点在本地网时，按传统的TCP/IP进行通信</li>
<li>移动节点漫游到一个外地网络时，仍按使用固定的IP地址进行通信，为了能够收到通信对端发给它的IP分组，移动节点需要向本地代理注册当前的位置地址，这个位置地址就是转交地址，移动IP的转交地址可以是外部代理的地址或动态配置的一个地址</li>
<li>本地代理收到来自转交地址的注册后，就会构建一条通向转交地址的隧道，将截获的发给移动节点的IP分组通过隧道传送到转交地址处</li>
<li>在转交地址处解除隧道封装，恢复出原始的IP分组，最后送到移动节点，这样移动节点在外网就能够收到这些送给它的IP分组了</li>
<li>移动节点在外网通过外网的路由器或者外代理向通信对端发送IP数据报</li>
<li>当移动节点来到另一个网络时，只需要向本地代理更新注册的转交地址，就可以继续通信了</li>
<li>当移动节点回到本地网时，移动节点想本地代理注销转交地址，这时移动节点又将使用传统的TCP/IP方式进行通信</li>
</ul>
<h1 id="网络层设备，路由器"><a href="#网络层设备，路由器" class="headerlink" title="网络层设备，路由器"></a>网络层设备，路由器</h1><p>路由选择部分：</p>
<ul>
<li>核心部件：路由选择处理器</li>
<li>根据所选定的路由选择协议构造出路由表，同时经常或定期的和相邻路由器交换路由信息不断更新和维护路由表</li>
</ul>
<p>分组转发部分</p>
<ul>
<li><p>组成：一组输入端口、交换结构、一组输出端口</p>
</li>
<li><p>交换方法：通过存储器进行交换、通过总线进行交换、通过互联网络进行交换</p>
</li>
<li><p>过程：从输入端口进。查找转发表，或排队等待。进入交换接口。进行缓存，并在数据链路层处理模块中给分组加上数据链路层的首部尾部。交给物理层发送到外部线路。</p>
</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤计算机网络</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>networkLayer</tag>
      </tags>
  </entry>
  <entry>
    <title>数据链路层相关知识点</title>
    <url>/2020/03/15/netDataLinkLayer/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>单位：Frames帧</li>
<li>硬件：交换机、网桥</li>
<li>任务：将网络层传下来的数据报封装成帧</li>
<li>协议：PHP、HDLC</li>
<li>功能</li>
</ul>
<table>
<thead>
<tr>
<th>功能</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>链路管理</td>
<td>链路连接的建立、拆除、分离</td>
</tr>
<tr>
<td>帧定界和帧同步</td>
<td>接收方确定收到的比特流中一帧的开始位置与结束位置</td>
</tr>
<tr>
<td>差错检测</td>
<td>使接收方确定收到的数据就是发送方发送的数据</td>
</tr>
<tr>
<td>透明传输</td>
<td>不管什么样的比特组合都应当在链路中传送</td>
</tr>
</tbody></table>
<h1 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h1><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符计数法</td>
<td>用一个字符表示帧的开始，一个计数字段表示该帧包含的字节数，从而推断出帧的结束位和下一个帧开始位</td>
</tr>
<tr>
<td>字节填充的首尾界符法</td>
<td>从128个ASCII码中的33个键盘不能输入的字符中挑出两个作为起始和结束标志。当传输文件不是键盘输入的,文件中会出现起始和结束标志,因此使用字节填充的首尾界符法，SOH–&gt;ESCx,EOT–&gt;ESCy,ESC–&gt;ESCz</td>
</tr>
<tr>
<td>比特填充的首尾标志法</td>
<td>首尾标志为01111110 文件中每连续5个1,则后面加入1个0</td>
</tr>
<tr>
<td>物理编码违例法</td>
<td>利用物理介质上编码违法方式来区分开始和结束</td>
</tr>
</tbody></table>
<h1 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h1><h2 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h2><ul>
<li><p>奇偶校验码</p>
<ul>
<li>奇校验码:添加一位校验码,使得整个码字里面的1个数是奇数</li>
<li>偶校验码:添加一位校验码,使得整个码字里面的1个数是偶数</li>
</ul>
</li>
<li><p>循环冗余码CRC</p>
<p><img src="/2020/03/15/netDataLinkLayer/crc.jpg" alt="图片-CRC计算过程"></p>
</li>
</ul>
<h2 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h2><p>海明码（Hamming Code）是一个可以有多个校验位，具有检测并纠正一位错误代码的纠错码，所以它也仅用于信道特性比较好的环境中，如以太局域网中，因为如果信道特性不好的情况下，出现的错误通常不是一位。<br>海明码的基本思想是将有效信息按某种规律分成若干组，每组安排一个校验位进行奇偶性测试，然后产生多位检测信息，并从中得出具体的出错位置，最后通过对错误位取反来将其纠正。<br>要采用海明码纠错，需要按以下步骤来进行：计算校验位数→确定校验码位置→确定校验码→实现校验和纠错。</p>
<h1 id="传输机制"><a href="#传输机制" class="headerlink" title="传输机制"></a>传输机制</h1><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><table>
<thead>
<tr>
<th>流量控制</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>停止-等待流量控制</td>
<td>发送方发送一个帧,得到应答后再发送下一个帧,否则一直等待</td>
</tr>
<tr>
<td>滑动窗口流量控制</td>
<td>允许发送多个帧,得到一个应答窗口向前滑动一个帧。当窗口满了,发送方会强行关闭网络层,直到有一个空闲缓冲区出来</td>
</tr>
</tbody></table>
<h2 id="可靠传输机制"><a href="#可靠传输机制" class="headerlink" title="可靠传输机制"></a>可靠传输机制</h2><p>利用传输层TCP</p>
<h2 id="滑动窗口机制"><a href="#滑动窗口机制" class="headerlink" title="滑动窗口机制"></a>滑动窗口机制</h2><table>
<thead>
<tr>
<th>协议</th>
<th>窗口状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>停止-等待协议</td>
<td>发送窗口=1,接收窗口=1</td>
<td>可靠传输（确认：发送确认帧超时，重传：一段时间没有响应就会重新发送）；数据帧破坏（如果帧正确则接收，不正确则丢弃，发送方未收到确认帧等待一段时间后再次发送）；确认帧被破坏（发送方在帧中加入标识，接收方判断是新帧还是旧帧）</td>
</tr>
<tr>
<td>后退N帧协议(GBN)</td>
<td>发送窗口&gt;1,接收窗口=1</td>
<td>滑动窗口中，某帧出错，则其及后续帧丢弃，发送方重传</td>
</tr>
<tr>
<td>选择重传协议(SR)</td>
<td>发送窗口&gt;1,接收窗口&gt;1</td>
<td>某帧出错，其后续帧存入接收方缓存中，发送方重发出错帧</td>
</tr>
</tbody></table>
<h1 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h1><p>介质访问控制(medium access control)简称MAC。 是解决当局域网中共用信道的使用产生竞争时，如何分配信道的使用权问题。</p>
<h2 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h2><ul>
<li>频分多路复用：道路变宽</li>
<li>时分多路复用：时间分割</li>
<li>波分多路复用：波段分割</li>
<li>码分多路复用：碎片数据✖码片向量，-1表示比特0，1表示比特1，0表示没有数据</li>
</ul>
<h2 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h2><ul>
<li><p>随机接入(争用型)</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ALOHA</td>
<td>不经过任何检测就发送数据，没有收到确认则继续发送</td>
</tr>
<tr>
<td>CSMA</td>
<td>1-坚持CSMA：发送节点监听到空闲时，立即发送数据，否则继续监听；p-坚持CSMA：发送节点监听到空闲时，依概率p发送数据，以概率（1-p）延迟一段时间并重新监听；非坚持CSMA：发送节点一旦监听到空闲时，就立即发送数据，否则延迟一段时间重新监听。</td>
</tr>
<tr>
<td>CSMA/CD</td>
<td>过程：发送数据之前检测总线是否有其他计算机发送数据，若无则发送数据，发送时继续监听，若出现冲突则随机时间后继续发送，适合有线网络，是被动型。</td>
</tr>
<tr>
<td>CSMA/CA</td>
<td>过程：发送数据之前检测总线是否有其他计算机发送数据，若无则发送数据，一段时间后检查对方是否发回帧确认，若没有继续重发，适合无线型网络，是主动型。</td>
</tr>
</tbody></table>
</li>
<li><p>受控接入：不能随便发送某数据，得到某种东西才能发送</p>
</li>
</ul>
<h2 id="轮询访问介质访问控制"><a href="#轮询访问介质访问控制" class="headerlink" title="轮询访问介质访问控制"></a>轮询访问介质访问控制</h2><ul>
<li>过程：用户不能随机发送数据，通过一个集中控制的监控站经过轮询过程后再决定信道的分配</li>
<li>令牌环局域网</li>
<li>令牌传递协议</li>
</ul>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p>工作原理：采用总线拓扑结构，无连接工作方式，不对发送的数据进行编号，也不要求对方发送确认。</p>
<p>MAC帧如下：</p>
<p><img src="/2020/03/15/netDataLinkLayer/maczhen.jpg" alt="图片-MAC帧"></p>
<ul>
<li><p>前导码：前同步符、帧开始定界符</p>
</li>
<li><p>目的地址、源地址：目的地址前八位最后一位为0，发给某一工作站；最后一位为1，其余不全为1，发给一组工作站；全为1，广播地址，发给所有工作站。</p>
</li>
</ul>
<p>传输介质，其中10指10Mbit/s，base基带信号</p>
<p><img src="/2020/03/15/netDataLinkLayer/10base.jpg" alt="图片-各种以太网"></p>
<p>高速以太网：100Base-T以太网、吉比特以太网、10吉比特以太网</p>
<p>无线局域网</p>
<ul>
<li>有固定基础设施的无线局域网（BSS基站）</li>
<li>无固定基础设施的无线局域网（自主网络）</li>
</ul>
<p>IEEE802.11</p>
<ul>
<li>物理层：跳频扩频（FHSS）、直接序列扩频（DSS）、红外线（IR）</li>
<li>MAC层：分布协调功能（DCF）、点协调功能（PCF）、CSMA/CD、确认机制</li>
</ul>
<h3 id="令牌环网"><a href="#令牌环网" class="headerlink" title="令牌环网"></a>令牌环网</h3><ul>
<li>当网络空闲时，环路中只有令牌在网络中循环传递</li>
<li>令牌传递到数据要发送的节点，修改令牌标志位，附加要传输的数据</li>
<li>数据延环路继续传输，直到遇到接收节点</li>
<li>接收节点复制数据，令牌继续传，传回发送节点</li>
<li>发送节点检查数据是否出错，出错重传，没有就产生一个新令牌，继续在令牌环上游荡</li>
</ul>
<h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><h3 id="PPP"><a href="#PPP" class="headerlink" title="PPP"></a>PPP</h3><p>是面向字节的协议，只负责检错、是不可靠传输、点对点通讯、全双工链路。</p>
<p>过程：用户拨号接入ISP，调制解调器对拨号做出确认，并建立一条物理连接，计算机向路由器发送一系列LCP分组，网络控制协议NCP给个人计算机分配一个临时IP，接入网络成功。</p>
<p><img src="/2020/03/15/netDataLinkLayer/ppp.jpg" alt="图片-PPP"></p>
<h3 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h3><p>是面向比特的协议</p>
<p>基本配置</p>
<ul>
<li>非平衡配置：由一个主机控制整个链路</li>
<li>平衡配置：链路两端的两个站是复合站，每个复合站可以平等的发起数据，不需要得到对方复合站的允许</li>
</ul>
<p><img src="/2020/03/15/netDataLinkLayer/HDCL.jpg" alt="图片-HDCL"></p>
<h1 id="物理设备"><a href="#物理设备" class="headerlink" title="物理设备"></a>物理设备</h1><h2 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h2><p>网桥至少有两个端口，每个端口与一个网段相连，接收到数据存储到缓存中，若为出错，则查找转发表从别的端口转发出去</p>
<ul>
<li>优点：过滤通信量、扩大物理范围、提高可靠性、可连接至不同物理层、不同MAC层和不同速率的以太网上</li>
<li>缺点：存储转发增加了时延、在MAC子层并没有流量控制功能、具有不同MAC子层的网段桥接在一起时时延更大、适合用户数量不多，通信量小的局域网</li>
</ul>
<table>
<thead>
<tr>
<th>分类</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>透明网桥</td>
<td>指不知道要经过哪几个网桥，自主学习转发表，新增或更新（源地址、进入的接口和时间）</td>
</tr>
<tr>
<td>源选径网桥</td>
<td>对外广播，选择最佳路由</td>
</tr>
</tbody></table>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><ul>
<li>实质：多端口网桥</li>
<li>直通式交换：只检查帧的目的地址，收到后立马被转发出去</li>
<li>存储转发式交换：先存储在高速缓存中，检查数据是否正确，查找转发表，转发</li>
</ul>
<h2 id="网桥与交换机对比"><a href="#网桥与交换机对比" class="headerlink" title="网桥与交换机对比"></a>网桥与交换机对比</h2><ul>
<li>网桥有两个端口，交换机多个</li>
<li>网桥连接到局域网网段，交换机连接主机或HUB</li>
<li>网桥一对计算机同时通讯，交换机允许多对</li>
<li>网桥存储转发，以太网有直通转发和存储转发</li>
</ul>
<h2 id="冲突域与广播域总结"><a href="#冲突域与广播域总结" class="headerlink" title="冲突域与广播域总结"></a>冲突域与广播域总结</h2><p><img src="/2020/03/15/netDataLinkLayer/chongtu.jpg" alt="图片-冲突域与广播域"></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤计算机网络</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>dataLinkLayer</tag>
      </tags>
  </entry>
  <entry>
    <title>物理层的相关知识点</title>
    <url>/2020/03/15/netPhysicalLayer/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>单位：Bits比特</li>
<li>硬件：集线器、中继器</li>
<li>任务：透明的传输比特流</li>
<li>功能：为数据端设备提供传输数据的通路</li>
</ul>
<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><table>
<thead>
<tr>
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>信号</td>
<td>数据的电气或电磁表现（基带信号：数字信号0和1；宽带信号：模拟信号）</td>
</tr>
<tr>
<td>信源</td>
<td>信息的源泉</td>
</tr>
<tr>
<td>信道</td>
<td>信息传送的道路</td>
</tr>
<tr>
<td>信宿</td>
<td>信息的归宿地</td>
</tr>
<tr>
<td>带宽</td>
<td>通信线路允许通过的信号频带范围Hz、 网络通信线路所能传输数据的能力bit/s</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>通信方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>同步</td>
<td>接收端和发送端时钟频率相同</td>
</tr>
<tr>
<td>异步</td>
<td>以字节为单位 增加一个起始比特和终止比特 可以任意间隔发送下一个字节</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>通信模式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>单工</td>
<td>只有一个方向</td>
</tr>
<tr>
<td>半双工</td>
<td>两个方向但不能同时进行</td>
</tr>
<tr>
<td>全双工</td>
<td>两个方向可以同时进行</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>速率</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>波特率（码元传输速率）</td>
<td>脉冲个数哦或信号变化的次数 表示单位时间内数字通信系统所传输的码元个数</td>
</tr>
<tr>
<td>比特率（信息传输速率）</td>
<td>单位时间内数字通信系统所传输的二进制码元个数 一码元通过变化表示0和1，后来可以携带4比特</td>
</tr>
</tbody></table>
<h1 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h1><h2 id="奈奎斯特定理"><a href="#奈奎斯特定理" class="headerlink" title="奈奎斯特定理"></a>奈奎斯特定理</h2><p>奈奎斯特定律是一种信息速率，根据奈奎斯特定律，信道的极限速率（码元速率）等于信道带宽（低通信道）等于信道带宽（理论状态）。</p>
<p>在理想低通的条件下(没有噪声)，带宽有限的信道，极限码元速率是2W 波特。<br>W是信道带宽，单位是Hz。每个码元离散状态的数目用V表示，则极限传输速率 = 2Wlog2V</p>
<h2 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h2><p>香农定理是指在带宽受限且有高斯白噪声干扰的信道极限传输速率。</p>
<p>信道的极限传输速率 = Wlog2(1+S/N)Wlog2(1+S/N)<br>具体来说，香农定理主要围绕的是S/N的计算考察，S表示信道传输信号的平均功率。</p>
<h1 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h1><h2 id="编码-模拟变数字"><a href="#编码-模拟变数字" class="headerlink" title="编码(模拟变数字)"></a>编码(模拟变数字)</h2><p>数字数据编码为数字信号</p>
<p>模拟数据编码为数字信号：采样-&gt;量化-&gt;编码</p>
<p><img src="/2020/03/15/netPhysicalLayer/bianma.jpg" alt="图片-编码方式"></p>
<table>
<thead>
<tr>
<th>编码方式</th>
<th>规则</th>
</tr>
</thead>
<tbody><tr>
<td>非归零码(NRZ)</td>
<td>低电平0，高电平1</td>
</tr>
<tr>
<td>曼彻斯特编码</td>
<td>中间跳变，从高到低跳变表示“1”，从低到高跳变表示“0”</td>
</tr>
<tr>
<td>差分曼彻斯特编码</td>
<td>开始时跳变为“0”，无跳变为“1”。中间跳变，初始为1</td>
</tr>
</tbody></table>
<h2 id="调制-数字变模拟"><a href="#调制-数字变模拟" class="headerlink" title="调制(数字变模拟)"></a>调制(数字变模拟)</h2><p>数字数据编码为模拟信号</p>
<p>模拟数据编码为模拟信号</p>
<table>
<thead>
<tr>
<th>调制名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>带通调制(载波调制)</td>
<td>改变频率范围，调幅、调频、调相</td>
</tr>
<tr>
<td>基带调制</td>
<td>改变波形</td>
</tr>
</tbody></table>
<h1 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h1><p><img src="/2020/03/15/netPhysicalLayer/shujuchuanshu.jpg" alt="图片-数据传输方式"></p>
<table>
<thead>
<tr>
<th>传输方式</th>
<th>描述</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>电路交换</td>
<td>建立一条被双方占有的物理通路</td>
<td>通信时延小、实时性强、有序传输、使用范围广、控制简单、避免冲突</td>
<td>建立连接时间长、信道利用率低、缺乏统一标准、灵活性差</td>
</tr>
<tr>
<td>报文交换</td>
<td>数据交换单位是报文，报文携带有目的地址和源地址等信息，采用存储转发方式</td>
<td>无需建立连接、动态分配线路、提高可靠性、提高线路利用率、提供多目标服务</td>
<td>有转发时延 要求网络节点有较大的存储缓存空间</td>
</tr>
<tr>
<td>分组交换</td>
<td>仍采用存储转发方式，将较长的报文分割为若干个较短的分组，逐个的转发出去</td>
<td>加速传输 简化存储管理 减少出错率和重发数据量</td>
<td>存在传输时延 可能出现失序、丢失、重复分组等现象</td>
</tr>
</tbody></table>
<h1 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h1><table>
<thead>
<tr>
<th>报文</th>
<th>过程</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>数据报</td>
<td>主机A先将分组逐个的发往与它相连的交换机1,1将A发来的分组缓存 1查找转发表,不同时刻转发表的内容可能不同,或转发给234 直到分组到达主机B</td>
<td>发送分组前无需建立连接 分组首部包含的是目的地址 尽最大努力交付,不保证可靠性,无序到达 减少延迟,提高了吞吐量 不独占某一链路,资源利用率高</td>
</tr>
<tr>
<td>虚电路</td>
<td>在发送前和主机建立一条虚连接 主机A发出特殊呼叫请求,B发送呼叫应答进行确认,虚电路建立成功 分组走相同路径 传输结束,主机发送释放请求</td>
<td>通讯必须建立连接 走相同路径,按序到达 分组首部包含的是虚电路标识符 路由失效时受影响</td>
</tr>
</tbody></table>
<h1 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h1><p>传输介质在物理层之下,不属于模型中</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>机械特性、电气特性、功能特性</p>
<h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><h3 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h3><p>无屏蔽双绞线</p>
<ul>
<li>标准<ul>
<li>标准568A：绿白-1，绿-2，橙白-3，蓝-4，蓝白-5，橙-6，棕白-7，棕-8。</li>
<li>标准568B：橙白-1，橙-2，绿白-3，蓝-4，蓝白-5，绿-6，棕白-7，棕-8。</li>
</ul>
</li>
<li>平行线：两端相同</li>
<li>交叉线：一端568A,一段568B</li>
</ul>
<p>屏蔽双绞线：加了一层金属网,较硬</p>
<h3 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h3><p>同轴电缆（CoaxialCable）是指有两个同心导体，而导体和屏蔽层又共用同一轴心的电缆。</p>
<h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><p>单模光纤：使用昂贵的半导体激光器,不发生反射,适合远距离传输</p>
<p>多模光纤：使用发光二极管,传输过程中会逐渐展宽失真,适合近距离传输</p>
<h1 id="物理设备"><a href="#物理设备" class="headerlink" title="物理设备"></a>物理设备</h1><h2 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h2><ul>
<li>放大器放大的是模拟信号,中继器放大数字信号</li>
</ul>
<h2 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h2><ul>
<li>计算机连接到集线器上,集线器对信号进行收发广播,每台电脑都会收到,不是发给自己的不予理睬</li>
<li>集线器不能隔离冲突域</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤计算机网络</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>physicalLayer</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络基本概念</title>
    <url>/2020/03/15/netBasicConcept/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>一些互联自治的计算机系统的集合</p>
<h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><h2 id="物理组成"><a href="#物理组成" class="headerlink" title="物理组成"></a>物理组成</h2><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><ul>
<li>主机</li>
<li>通讯处理机（前端处理器）</li>
<li>通讯线路<ul>
<li>有线</li>
<li>无线</li>
</ul>
</li>
<li>交换设备<ul>
<li>交换机</li>
<li>路由器</li>
<li>etc</li>
</ul>
</li>
</ul>
<h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><p>实现资源共享的软件和工具，如：QQ</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>一种规则</p>
<h2 id="工作方式组成"><a href="#工作方式组成" class="headerlink" title="工作方式组成"></a>工作方式组成</h2><h3 id="边缘部分"><a href="#边缘部分" class="headerlink" title="边缘部分"></a>边缘部分</h3><ul>
<li>组成：所有连接在互联网上供用户直接使用的主机</li>
<li>作用：通信、资源共享</li>
</ul>
<h3 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h3><ul>
<li>组成大量的网络和连接这些网络的路由器</li>
<li>作用：提供连通性和交换服务</li>
</ul>
<h2 id="功能组成"><a href="#功能组成" class="headerlink" title="功能组成"></a>功能组成</h2><h3 id="通讯子网"><a href="#通讯子网" class="headerlink" title="通讯子网"></a>通讯子网</h3><ul>
<li>组成：传输介质、通信设备、响应的网络协议</li>
<li>作用：提供数据传输、交换和控制能力，实现信息通讯</li>
</ul>
<h3 id="资源子网"><a href="#资源子网" class="headerlink" title="资源子网"></a>资源子网</h3><ul>
<li>组成：主机、终端、各类软件资源和信息资源</li>
<li>作用：负责全网的数据处理业务，像网络用户提供各种网络资源与服务</li>
</ul>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ul>
<li>数据通信（最基本，最重要）</li>
<li>资源共享</li>
<li>分布式处理</li>
<li>信息综合处理</li>
<li>负载均衡</li>
<li>提高可靠性</li>
</ul>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><h2 id="分布范围"><a href="#分布范围" class="headerlink" title="分布范围"></a>分布范围</h2><ul>
<li>广域网</li>
<li>城域网</li>
<li>局域网</li>
<li>个人区域网</li>
</ul>
<h2 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h2><ul>
<li><p>星形网络</p>
</li>
<li><p>总线型网络</p>
</li>
<li><p>环形网络</p>
</li>
<li><p>网状形网络</p>
</li>
</ul>
<h2 id="传输技术"><a href="#传输技术" class="headerlink" title="传输技术"></a>传输技术</h2><ul>
<li>广播式网络</li>
<li>点对点网络</li>
</ul>
<h2 id="使用者"><a href="#使用者" class="headerlink" title="使用者"></a>使用者</h2><ul>
<li>公用网</li>
<li>专用网</li>
</ul>
<h2 id="数据交换技术"><a href="#数据交换技术" class="headerlink" title="数据交换技术"></a>数据交换技术</h2><ul>
<li>电路交换网</li>
<li>报文交换网</li>
<li>分组交换网</li>
</ul>
<h1 id="相关组织"><a href="#相关组织" class="headerlink" title="相关组织"></a>相关组织</h1><ul>
<li>ISO国际标准化组织</li>
<li>ITU国际电信联盟</li>
<li>IEEE美国电气和电子工程师协会</li>
</ul>
<h1 id="参考模型"><a href="#参考模型" class="headerlink" title="参考模型"></a>参考模型</h1><h2 id="ISO-OSI"><a href="#ISO-OSI" class="headerlink" title="ISO/OSI"></a>ISO/OSI</h2><ul>
<li>应用层</li>
<li>表示层</li>
<li>会话层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
<h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><ul>
<li>应用层</li>
<li>传输层</li>
<li>互联网层</li>
<li>网络接收层</li>
</ul>
<h2 id="5层模型"><a href="#5层模型" class="headerlink" title="5层模型"></a>5层模型</h2><ul>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
<h1 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h1><h2 id="时延（总时延为四者之和）"><a href="#时延（总时延为四者之和）" class="headerlink" title="时延（总时延为四者之和）"></a>时延（总时延为四者之和）</h2><ul>
<li>发送时延（传输时延）<ul>
<li>主机或路由器发送数据所需要的时间，从第一位开始发送到最后一位发送完毕</li>
<li>发送时延=数据帧长度（bit）/发送速率（bit/s）</li>
</ul>
</li>
<li>传播时延<ul>
<li>电磁波在信道中传播一定的距离所需要的时间</li>
<li>传播时延=信道长度（m）/电磁波在信道上的传播速度（m/s）</li>
</ul>
</li>
<li>处理时延<ul>
<li>主机在路由器在接收到分组时进行处理所需要的时间</li>
</ul>
</li>
<li>排队时延<ul>
<li>进入路由器在输入队列排队等待处理</li>
<li>确定转发接口后，在输出队列等待转发</li>
</ul>
</li>
</ul>
<h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><ul>
<li>时延带宽积=传播时延*带宽</li>
</ul>
<h2 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h2><ul>
<li>从发送方开始发送数据，到发送方收到接收方的确认消息</li>
</ul>
<h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><ul>
<li>信道利用率<ul>
<li>某信道有%的时间是被利用的</li>
</ul>
</li>
<li>网络利用率<ul>
<li>全网络信道利用率加权平均值</li>
</ul>
</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤计算网络</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>conception</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络参考模型</title>
    <url>/2020/03/15/networkReferenceModel/</url>
    <content><![CDATA[<p>将网络分层有利于让整个流程更加清晰，复杂的问题简单化。计算机网络参考模型常见的有三种：</p>
<p><img src="/2020/03/15/networkReferenceModel/cankaomoxing.jpg" alt="图片-三个参考模型"></p>
<p><a href="https://wenku.baidu.com/view/f7593b88974bcf84b9d528ea81c758f5f61f29f4.html" target="_blank" rel="noopener">图片改编自百度文库</a></p>
<h1 id="OSI七层参考模型"><a href="#OSI七层参考模型" class="headerlink" title="OSI七层参考模型"></a>OSI七层参考模型</h1><p>OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO组织在1985年研究的网络互联模型。该体系结构标准定义了网络互联的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层和应用层），即OSI开放系统互连参考模型。</p>
<p>OSI 将计算机网络体系结构划分为七层，每层都可以提供抽象良好的接口，能够提供面向连接和无连接两种通信服务机制。是一种使各种不同的计算机和网络在世界范围内实现互联的标准框架。OSI 虽然层级多，由于功能细化，便于排障。不过由于种种原因，没有得以推行，只能作为一种适合学习的模型。</p>
<p><img src="/2020/03/15/networkReferenceModel/OSItujie.jpg" alt="图片-图解OSI"></p>
<p><a href="http://www.colasoft.com.cn/download/document.php" target="_blank" rel="noopener">图片来自科来</a></p>
<h1 id="TCP-IP四层参考模型"><a href="#TCP-IP四层参考模型" class="headerlink" title="TCP/IP四层参考模型"></a>TCP/IP四层参考模型</h1><p>TCP/IP参考模型是计算机网络的祖父ARPANET和其后继的因特网使用的参考模型。ARPANET是由美国国防部DoD（U.S.Department of Defense）赞助的研究网络。逐渐地它通过租用的电话线连结了数百所大学和政府部门。当无线网络和卫星出现以后，现有的协议在和它们相连的时候出现了问题，所以需要一种新的参考体系结构。</p>
<p>这个体系结构在它的两个主要协议出现以后，即先有的TCP和IP协议，后有的模型，被称为TCP/IP参考模型（TCP/IP reference model）。基于TCP/IP的参考模型将协议分成四个层次，它们分别是：网络访问层、网际互联层（主机到主机）、传输层、和应用层，能够提供面向连接和无连接两种通信服务机制。由于出现的早，更为众人所采用，是偏向于实践的模型。</p>
<h1 id="教学五层模型"><a href="#教学五层模型" class="headerlink" title="教学五层模型"></a>教学五层模型</h1><p>为了便于学习，便出现了TCP/IP模型分化出来的模型，即教学五层模型。这个模型在工业界是没有的，主要是方便教学使用。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>对象</th>
<th>单位</th>
<th>功能</th>
<th>协议</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>用户对用户</td>
<td></td>
<td>文件传输、访问和管理、电子邮件服务</td>
<td>FTP 、SMTP、POP3、HTTP、DNS、TFTP、SNMP</td>
</tr>
<tr>
<td>传输层</td>
<td>应用对应用、进程对进程</td>
<td>(segments段)报文段TCP、用户数据报UDP</td>
<td>为端到端连接提供可靠的传输服务，为端到端连接提供流量控制、差错控制、服务质量等管理服务，提供应用进程间的逻辑通信，差错检测，提供无连接和面向连接的服务，复用和分用，TCP:连接管理 流量控制与拥塞控制</td>
<td>TCP、UDP</td>
</tr>
<tr>
<td>网络层</td>
<td>主机对主机</td>
<td>Packets包：数据报</td>
<td>组包和拆包、路由选择、分组转发、拥塞控制、异构网络互连</td>
<td>ICMP、ARP、RARP、IP、IGMP</td>
</tr>
<tr>
<td>数据链路层</td>
<td></td>
<td>Frames帧</td>
<td>链路管理、帧定界和帧同步、差错检测、透明传输</td>
<td>PHP、HDLC</td>
</tr>
<tr>
<td>物理层</td>
<td></td>
<td>Bits比特</td>
<td>提供传输数据的通路</td>
<td></td>
</tr>
</tbody></table>
<p>以前学习的时候参考天勤做了一个思维大纲图，欢迎来看，<a href="https://mubu.com/doc/5PAGbmxGYrg" target="_blank" rel="noopener">计算机网络</a></p>
<h1 id="数据封装拆解过程"><a href="#数据封装拆解过程" class="headerlink" title="数据封装拆解过程"></a>数据封装拆解过程</h1><p>从应用层的数据到物理层的比特率，每向下一层数据都会被进一步封装，就像洋葱一样，只有它的芯才是真正的要表达的数据，那一层一层的是传输时的信息，比如下一步要传递给谁？它的地址是多少？</p>
<p><img src="/2020/03/15/networkReferenceModel/fengzhuang.png" alt="图片-数据封装"></p>
<p><a href="https://wenku.baidu.com/view/f7593b88974bcf84b9d528ea81c758f5f61f29f4.html" target="_blank" rel="noopener">图片改编自百度文库</a></p>
<p>现实生活中，我们不可能一根网线就可把数据发送给对方，中间要经过多个路由器、交换机。</p>
<p><img src="/2020/03/15/networkReferenceModel/2020-03-15-networkReferenceModel%5Cliudongguocheng.png" alt="图片-数据流动过程"></p>
<p><a href="https://wenku.baidu.com/view/f7593b88974bcf84b9d528ea81c758f5f61f29f4.html" target="_blank" rel="noopener">图片改编自百度文库</a></p>
<p>每次需要经过交换机时MAC头部就会被拆解，并被更换为新的MAC头部。每次需要经过路由器时，MAC头部被拆解并向上提交至网络层，IP头部也会被拆解并更换为新的IP头部，然后向下提交加上新的MAC头部。以此类推，最后到达了目标主机。再逐层拆解最后洋葱被拨的只剩芯了，这也是我们真正想要发送的数据。</p>
<p><img src="/2020/03/15/networkReferenceModel/jiefeng.png" alt="图片-数据解封过程"></p>
<p><a href="https://wenku.baidu.com/view/f7593b88974bcf84b9d528ea81c758f5f61f29f4.html" target="_blank" rel="noopener">图片改编自百度文库</a></p>
<p>最后这是一张表述每一层所对应物理设备，当然这并不是绝对的，因为现实生活中也会有网络层交换机。</p>
<p><img src="/2020/03/15/networkReferenceModel/shebei.png" alt="图片-对应设备"></p>
<p><a href="https://wenku.baidu.com/view/f7593b88974bcf84b9d528ea81c758f5f61f29f4.html" target="_blank" rel="noopener">图片改编自百度文库</a></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://wenku.baidu.com/view/f7593b88974bcf84b9d528ea81c758f5f61f29f4.html" target="_blank" rel="noopener">百度文库-01-计算机网络参考模型</a></p>
<p><a href="[https://baike.baidu.com/item/OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B](https://baike.baidu.com/item/OSI参考模型)">百度百科-OSI参考模型</a></p>
<p><a href="https://www.jianshu.com/p/348df1dde9bd" target="_blank" rel="noopener">简书-计算机网络-参考模型</a></p>
<p><a href="https://zhidao.baidu.com/question/573470632.html" target="_blank" rel="noopener">百度知道</a></p>
<p><a href="[https://baike.baidu.com/item/TCP%2FIP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B](https://baike.baidu.com/item/TCP%2FIP参考模型)">百度百科-TCP/IP参考模型</a></p>
<p><a href="https://www.cnblogs.com/lsdb/p/9564094.html" target="_blank" rel="noopener">博客园-努力改个网名</a></p>
<p><a href>天勤计算机网络</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>OSI - TCP/IP</tag>
        <tag>五层模型</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS域名解析过程</title>
    <url>/2020/03/14/dnsProcess/</url>
    <content><![CDATA[<p>DNS域名解析过程大致分为两种：</p>
<h1 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h1><p>所谓迭代查询是指：根域名服务器收到查询请求，要么给出查询结果，要么告诉本地域名服务器下一步向哪个域名服务器进行查询。</p>
<p>主要是本地域名服务器向根域名服务器查询信息时所采用的方式。</p>
<h1 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h1><p>所谓递归查询是指：本地域名服务器只请求一次，后面几次都是在其他几个域名服务器之间进行的。</p>
<p>主要是主机向本地域名服务器查询信息时所采用的方式。当主机需要查询IP时，本地域名服务器不知道域名所对应的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器发送查询请求报文，而不是让主机自己进行下一步查询。</p>
<h1 id="访问度娘的过程"><a href="#访问度娘的过程" class="headerlink" title="访问度娘的过程"></a>访问度娘的过程</h1><pre><code>①本机向local dns请求www.baidu.com
②local dns向根域请求www.baidu.com，根域返回com.域的服务器IP
③向com.域请求www.baidu.com，com.域返回baidu.com域的服务器IP
④向baidu.com请求www.baidu.com，返回cname www.a.shifen.com和a.shifen.com域的服务器IP
⑤向root域请求www.a.shifen.com
⑥向com.域请求www.a.shife.com
⑦向shifen.com请求
⑧向a.shifen.com域请求
⑨拿到www.a.shifen.com的IP
⑩localdns返回本机www.baidu.com cname www.a.shifen.com 以及 www.a.shifen.com的IP</code></pre><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/crazw/article/details/8986504" target="_blank" rel="noopener">CSDN-Crazw_jia</a></p>
<p><a href="https://blog.csdn.net/Daputao_net/article/details/81203531" target="_blank" rel="noopener">CSDN-Daputao_net</a></p>
<p><a href="https://www.cnblogs.com/qingdaofu/p/7399670.html" target="_blank" rel="noopener">博客园-皈依之路</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP的头信息</title>
    <url>/2020/03/14/httpHeads/</url>
    <content><![CDATA[<p>HTTP头信息主要包括通用头、请求头、响应头、实体头。</p>
<p><img src="/2020/03/14/httpHeads/qingqiutou.png" alt="qingqiutou"><br><img src="/2020/03/14/httpHeads/xiangyingtou.png" alt="xiangyingtou"></p>
<h1 id="通用头部"><a href="#通用头部" class="headerlink" title="通用头部"></a>通用头部</h1><p>通用头域包含请求和响应消息都支持的头域，通用头域包含缓存头部Cache-Control、Pragma及信息性头部Connection、Date、Transfer-Encoding、Update、Via。</p>
<table>
<thead>
<tr>
<th align="left">应答头</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Cache-Control</td>
<td align="left">指定请求和响应遵循的缓存机制</td>
</tr>
<tr>
<td align="left">Pragma</td>
<td align="left">用来包含实现特定的指令</td>
</tr>
<tr>
<td align="left">Connection</td>
<td align="left">表示是否需要持久连接</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">指定请求和响应遵循的缓存机制</td>
</tr>
<tr>
<td align="left">Cache-Control</td>
<td align="left">表示消息发送的时间</td>
</tr>
<tr>
<td align="left">Transfer-Encoding</td>
<td align="left">服务器表明自己对本响应消息体作了怎样的编码</td>
</tr>
<tr>
<td align="left">Upgrade</td>
<td align="left">指定另一种可能完全不同的协议</td>
</tr>
<tr>
<td align="left">Via</td>
<td align="left">列出该响应经过了哪些代理服务器，他们用什么协议发送的请求</td>
</tr>
</tbody></table>
<h1 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h1><p>请求头用于说明是谁或什么在发送请求、请求源于何处，或者客户端的喜好及能力。服务器可以根据请求头部给出的客户端信息，试着为客户端提供更好的响应。请求头域可能包含下列字段Accept、Accept-Charset、Accept- Encoding、Accept-Language、Authorization、From、Host、If-Modified-Since、If-Match、If-None-Match、If-Range、If-Range、If-Unmodified-Since、Max-Forwards、Proxy-Authorization、Range、Referer、User-Agent。对请求头域的扩展要求通讯双方都支持，如果存在不支持的请求头域，一般将会作为实体头域处理。</p>
<table>
<thead>
<tr>
<th align="left">应答头</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Accept</td>
<td align="left">告诉WEB服务器自己接受什么介质类型</td>
</tr>
<tr>
<td align="left">Accept-Charset</td>
<td align="left">浏览器告诉服务器自己能接收的字符集</td>
</tr>
<tr>
<td align="left">Accept-Encoding</td>
<td align="left">浏览器申明自己接收的编码方法</td>
</tr>
<tr>
<td align="left">Accept-Language</td>
<td align="left">浏览器申明自己接收的语言</td>
</tr>
<tr>
<td align="left">Authorization</td>
<td align="left">客户端接收到服务器的WWW-Authenticate响应时，用该头部来回应服务器自己的身份验证信息</td>
</tr>
<tr>
<td align="left">If-Match</td>
<td align="left">如果对象的ETag没有改变，即对象没有改变，才执行请求的动作</td>
</tr>
<tr>
<td align="left">If-None-Match</td>
<td align="left">如果对象的ETag改变了，才执行请求的动作</td>
</tr>
<tr>
<td align="left">If-Modified-Since</td>
<td align="left">如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作，否则返回代码304，告诉浏览器该对象没有修改</td>
</tr>
<tr>
<td align="left">If-Unmodified-Since</td>
<td align="left">如果请求的对象在该头部指定的时间之后没修改过，才执行请求的动作</td>
</tr>
<tr>
<td align="left">If-Range</td>
<td align="left">浏览器告诉 WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分给我，如果对象改变了，就把整个对象给我</td>
</tr>
<tr>
<td align="left">Range</td>
<td align="left">浏览器告诉 WEB 服务器自己想取对象的哪部分</td>
</tr>
<tr>
<td align="left">Proxy-Authenticate</td>
<td align="left">代理服务器响应浏览器，要求其提供代理身份验证信息</td>
</tr>
<tr>
<td align="left">Host</td>
<td align="left">客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号</td>
</tr>
<tr>
<td align="left">Referer</td>
<td align="left">浏览器向WEB 服务器表明自己是从哪个网页URL获得点击当前请求中的网址/URL</td>
</tr>
<tr>
<td align="left">User-Agent</td>
<td align="left">浏览器表明自己的身份</td>
</tr>
</tbody></table>
<h1 id="响应头部"><a href="#响应头部" class="headerlink" title="响应头部"></a>响应头部</h1><p>响应头向客户端提供一些额外信息，比如谁在发送响应、响应者的功能，甚至与响应相关的一些特殊指令。这些头部有助于客户端处理响应，并在将来发起更好的请求。响应头域包含Age、Location、Proxy-Authenticate、Public、Retry- After、Server、Vary、Warning、WWW-Authenticate。对响应头域的扩展要求通讯双方都支持，如果存在不支持的响应头域，一般将会作为实体头域处理。</p>
<table>
<thead>
<tr>
<th align="left">应答头</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Age</td>
<td align="left">当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了</td>
</tr>
<tr>
<td align="left">Server</td>
<td align="left">WEB 服务器表明自己是什么软件及版本等信息</td>
</tr>
<tr>
<td align="left">Accept-Ranges</td>
<td align="left">WEB服务器表明自己是否接受获取其某个实体的一部分的请求</td>
</tr>
<tr>
<td align="left">Vary</td>
<td align="left">WEB服务器用该头部的内容告诉 Cache 服务器，在什么条件下才能用本响应所返回的对象响应后续的请求</td>
</tr>
</tbody></table>
<h1 id="实体头部"><a href="#实体头部" class="headerlink" title="实体头部"></a>实体头部</h1><p>实体头部提供了有关实体及其内容的大量信息，从有关对象类型的信息，到能够对资源使用的各种有效的请求方法。总之，实体头部可以告知接收者它在对什么进行处理。请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括信息性头部Allow、Location，内容头部Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type，缓存头部Etag、Expires、Last-Modified、extension-header。</p>
<table>
<thead>
<tr>
<th align="left">应答头</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Allow</td>
<td align="left">服务器支持哪些请求方法</td>
</tr>
<tr>
<td align="left">Location</td>
<td align="left">表示客户应当到哪里去提取文档，用于将接收端定位到资源的位置（URL）上</td>
</tr>
<tr>
<td align="left">Content-Base</td>
<td align="left">解析主体中的相对URL时使用的基础URL</td>
</tr>
<tr>
<td align="left">Content-Encoding</td>
<td align="left">WEB服务器表明自己使用了什么压缩方法压缩响应中的对象</td>
</tr>
<tr>
<td align="left">Content-Language</td>
<td align="left">WEB 服务器告诉浏览器理解主体时最适宜使用的自然语言</td>
</tr>
<tr>
<td align="left">Content-Length</td>
<td align="left">WEB服务器告诉浏览器自己响应的对象的长度或尺寸</td>
</tr>
<tr>
<td align="left">Content-Location</td>
<td align="left">资源实际所处的位置</td>
</tr>
<tr>
<td align="left">Content-MD5</td>
<td align="left">主体的MD5校验和</td>
</tr>
<tr>
<td align="left">Content-Range</td>
<td align="left">传送的范围</td>
</tr>
<tr>
<td align="left">Content-Type</td>
<td align="left">WEB 服务器告诉浏览器自己响应的对象的类型</td>
</tr>
<tr>
<td align="left">Etag</td>
<td align="left">供WEB服务器判断一个对象是否改变了</td>
</tr>
<tr>
<td align="left">Expires</td>
<td align="left">WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB服务器验证了其有效性后，才能用来响应客户请求</td>
</tr>
<tr>
<td align="left">Last-Modified</td>
<td align="left">WEB服务器认为对象的最后修改时间</td>
</tr>
</tbody></table>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/wangzhen_csdn/article/details/80776991" target="_blank" rel="noopener">CSDN-wangzhibo_csdn</a><br><a href="https://segmentfault.com/q/1010000010814115" target="_blank" rel="noopener">segmentfault-某熊猫桑</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>三次握手与四次挥手</title>
    <url>/2020/03/14/tcpConnect/</url>
    <content><![CDATA[<h1 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h1><p>当获取IP之后，客户端就会发送一个报文段给服务器，开启三次握手。</p>
<p><img src="/2020/03/14/tcpConnect/baowenduan.png" alt="baowenduan"></p>
<p>其中确认号下面那个犄角旮旯里：</p>
<blockquote>
<p>URG(urgent)：紧急，为1时表示有紧急数据，应正确传送。<br>ACK(acknowledgement)：确认，为1时确认字号才有效，一旦TCP连接建立，就必须把ACK置为1。<br>PSH(push)：传送，为1时表示尽快交付，不必把整个缓存都填满后再交付。<br>RST(reset)：重置，为1时表示连接中出现严重差错，必须释放连接，重新建立。<br>SYN(synchronous)：建立联机，为1时表示这是一个连接请求或连接接受报文。<br>FIN(finish)：结束，为1时表示此报文段的发送端的数据已发送完毕，要求释放传输连接。</p>
<p>Sequence number(seq)：顺序号码<br>Acknowledge number(ack)：确认号码</p>
</blockquote>
<p><img src="/2020/03/14/tcpConnect/sanciwoshou.png" alt="sanciwoshou"></p>
<p><a href="https://www.bilibili.com/video/av52745283?from=search&seid=12199868811481081570" target="_blank" rel="noopener">图片来源：B站-计算机网络第36讲</a></p>
<p>三次握手功能如下：</p>
<blockquote>
<p>客户端：服大大，我要发数据给你哇，你快来接收啦。<br>服务器：好的，老客你发吧。<br>客户端：嗯嗯，那我发了。</p>
</blockquote>
<p>那为什么是三次握手呢？</p>
<p>这就要考虑到传输时丢包的问题，即当服务器发送给客户端的数据丢包了，如果只有两次握手，服务器是无法确认客户端是否能收到自己的回复。所以第三次握手的作用就是，如果服务器收不到客户端对自己的回复，那么它就会继续发送，直到确认客户端收到了自己的回复。</p>
<blockquote>
<p>客户端：服大大，我要发数据给你哇，你快来接收啦。<br>客户端：（？？？没收到？再来一次）<br>客户端：服大大，我要发数据给你哇，你快来接收啦。<br>服务器：好的，老客你发吧。<br>服务器：（？？？怎么不回我，可能又丢包了，那再发一次吧）<br>服务器：好的，老客你发吧。<br>客户端：嗯嗯，那我发了。<br>服务器：（收到了老客的回复，说明我们的TCP连接已经建立）<br>客户端：（不管服大大有没有收到这条消息，我都认为我们的TCP连接已经建立）</p>
</blockquote>
<p>当然这也只是比较理想的一种情况，现实中这些传递的包可能会卡在路上过了很久之后才传过来，这个时候很有可能客户端与服务器都传输完数据了。如果只有两次握手的话，那么很有可能会再次唤起服务器，造成资源的浪费。  </p>
<p><img src="/2020/03/14/tcpConnect/erciwoshou.png" alt="erciwoshou"></p>
<p><a href="https://www.bilibili.com/video/av52745283?from=search&seid=12199868811481081570" target="_blank" rel="noopener">图片来源：B站-计算机网络第36讲</a></p>
<blockquote>
<p>客户端：服大大，我要发数据给你哇，你快来接收啦。（1）<br>客户端：（？？？没收到？再来一次）<br>客户端：服大大，我要发数据给你哇，你快来接收啦。（2）<br>服务器：好的，老客你发吧。（2）<br>客户端与服务器开心的发完数据，并且关闭了连接。<br>服务器：你怎么又来了？（1）<br>服务器建立连接（1）<br>服务器等待客户端传输请求（1）<br>服务器：我等（1）<br>服务器：我等（1）<br>服务器：我等等等（1）<br>……<br>服务器：？？……？？（1）<br>服务器亡（1）</p>
</blockquote>
<h1 id="传输数据"><a href="#传输数据" class="headerlink" title="传输数据"></a>传输数据</h1><p>握手成功后，开始传输数据，数据被分为多个分节，一次数据的传输需要2个TCP包。数据发送包，接收方应答包。</p>
<p>如果已经建立了连接，客户端突然出现故障。TCP设有一个保活计时器，服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h1 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h1><p><img src="/2020/03/14/tcpConnect/sicihuishou.png" alt="sicihuishou"></p>
<p><a href="https://www.bilibili.com/video/av52745283?from=search&seid=12199868811481081570" target="_blank" rel="noopener">图片来源：B站-计算机网络第36讲</a></p>
<blockquote>
<p>客户端发完数据<br>客户端：服大大，我数据发完了。(停止发送数据，进入终止等待1状态)<br>服务器：好的，我知道了。(进入关闭等待状态)<br>客户端收到回复进入终止等待2状态<br>服务器发完数据<br>服务器：老客啊，我也发完了。(进入最后确认状态)<br>客户端接收完数据：好的。(客户端进入时间等待状态，服务器进入CLOSED状态)<br>2*MSL(最长报文段寿命Maximum Segment Lifetime)时间后，客户端进入CLOSED状态。</p>
</blockquote>
<p>客户端等待2MSL的原因：</p>
<p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p>
<p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.zhihu.com/question/24853633" target="_blank" rel="noopener">知乎-TCP 为什么是三次握手，而不是两次或四次？</a></p>
<p><a href="https://www.bilibili.com/video/av52745283?from=search&seid=12199868811481081570" target="_blank" rel="noopener">B站-计算机网络第36讲</a></p>
<p><a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">CSDN-小书go</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP请求方法</title>
    <url>/2020/03/14/httpMethods/</url>
    <content><![CDATA[<p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。</p>
<p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p>
<p>所以HTTP目前为止一共有九种请求方法。</p>
<h1 id="HEAD-获取报头"><a href="#HEAD-获取报头" class="headerlink" title="HEAD(获取报头)"></a>HEAD(获取报头)</h1><blockquote>
<p>The <strong>HTTP <code>HEAD</code> method</strong> requests the headers that are returned if the specified resource would be requested with an HTTP <code>GET</code> method. Such a request can be done before deciding to download a large resource to save bandwidth, for example.</p>
<p>A response to a <code>HEAD</code> method should not have a body. If so, it must be ignored. Even so, entity headers describing the content of the body, like <code>Content-Length</code> may be included in the response. They don’t relate to the body of the <code>HEAD</code> response, which should be empty, but to the body which a similar request using the <code>GET</code>method would have returned as a response.</p>
</blockquote>
<p>HEAD与GET方法类似，但是它不会返回消息体，用来获取报头，通常用来测试超链接的有效性、可用性。</p>
<h1 id="GET-查询"><a href="#GET-查询" class="headerlink" title="GET(查询)"></a>GET(查询)</h1><blockquote>
<p>The <strong>HTTP <code>GET</code> method</strong> requests a representation of the specified resource. Requests using <code>GET</code> should only retrieve data.</p>
</blockquote>
<p>HTTP协议规定GET是获取资源的方法，通过URL提交，在地址栏中可以看到，其所提交的数据最多只能有1024个字节。GET有利于资源的传播，其请求在Ajax环境下不会被缓存，有利于减轻服务器的压力。</p>
<h1 id="POST-新增"><a href="#POST-新增" class="headerlink" title="POST(新增)"></a>POST(新增)</h1><blockquote>
<p>The <strong>HTTP <code>POST</code> method</strong> sends data to the server. The type of the body of the request is indicated by the Content-Type header.</p>
</blockquote>
<p>HTTP协议规定POST是创建资源的方法，其内容是在HTTP请求的body里实现，POST传输数据时不会在URL里显示，可以传输较为大量的数据，在Ajax环境下会被缓存，非幂等的，多次访问都会产生影响。</p>
<h1 id="PUT-修改"><a href="#PUT-修改" class="headerlink" title="PUT(修改)"></a>PUT(修改)</h1><blockquote>
<p>The <strong>HTTP PUT request method</strong> creates a new resource or replaces a representation of the target resource with the request payload.</p>
<p>The difference between <code>PUT</code> and <code>POST</code> is that <code>PUT</code>is idempotent: calling it once or several times successively has the same effect (that is no side effect), where successive identical <code>POST</code> may have additional effects, like passing an order several times.</p>
</blockquote>
<p>HTTP协议规定PUT是更新资源的方法,<code>PUT</code>是幂等的方法，即调用一次与调用多次是等价的。</p>
<h1 id="PATCH-修改"><a href="#PATCH-修改" class="headerlink" title="PATCH(修改)"></a>PATCH(修改)</h1><blockquote>
<p>The <strong>HTTP PATCH request method</strong> applies partial modifications to a resource.</p>
<p>The HTTP <code>PUT</code>method only allows complete replacement of a document. Unlike <code>PUT</code>, <code>PATCH</code> is not idempotent, meaning successive identical patch requests <em>may</em> have different effects. However, it is possible to issue <code>PATCH</code> requests in such a way as to be idempotent.</p>
<p>PATCH (like PUT) may have side-effects on other resources.</p>
<p>To find out whether a server supports <code>PATCH</code>, a server can advertise its support by adding it to the list in the Allow or Access-Control-Allow-Methods(for CORS) response headers.</p>
</blockquote>
<p>HTTP协议规定PATCH是修改资源的方法，是对PUT方法的补充，用来对已知资源进行局部更新，但PATCH与POST一样是非幂等的。</p>
<h1 id="DELETE-删除"><a href="#DELETE-删除" class="headerlink" title="DELETE(删除)"></a>DELETE(删除)</h1><blockquote>
<p>The <strong>HTTP DELETE request method</strong> deletes the specified resource.</p>
</blockquote>
<p>HTTP协议规定DELETE是删除资源的方法.</p>
<h1 id="CONNECT-代理"><a href="#CONNECT-代理" class="headerlink" title="CONNECT(代理)"></a>CONNECT(代理)</h1><blockquote>
<p>The <strong>HTTP <code>CONNECT</code> method</strong> starts two-way communications with the requested resource. It can be used to open a tunnel.</p>
<p>For example, the <code>CONNECT</code> method can be used to access websites that use SSL (HTTPS). The client asks an HTTP Proxy server to tunnel the TCP connection to the desired destination. The server then proceeds to make the connection on behalf of the client. Once the connection has been established by the server, the Proxy server continues to proxy the TCP stream to and from the client.</p>
</blockquote>
<p><code>CONNECT</code>在网页开发中一般不会被用到，其作用是将服务器作为代理(访问中介)，让服务器代替用户访问别的资源，然后再将该资源返回给用户，这样用户就可以访问到只有服务器才能访问的网站(比如翻墙 )，它直接使用TCP去连接。</p>
<h1 id="TRACE-测试"><a href="#TRACE-测试" class="headerlink" title="TRACE(测试)"></a>TRACE(测试)</h1><blockquote>
<p>The <strong>HTTP <code>TRACE</code> method</strong> performs a message loop-back test along the path to the target resource, providing a useful debugging mechanism.</p>
</blockquote>
<p>回显服务器收到的请求，主要用于测试或诊断。</p>
<h1 id="OPTIONS-测试"><a href="#OPTIONS-测试" class="headerlink" title="OPTIONS(测试)"></a>OPTIONS(测试)</h1><blockquote>
<p>The <strong>HTTP <code>OPTIONS</code> method</strong> is used to describe the communication options for the target resource. The client can specify a URL for the OPTIONS method, or an asterisk (*) to refer to the entire server.</p>
<p> For Example, to find out which request methods a server supports, one can use curl and issue an OPTIONS request.</p>
</blockquote>
<p>通过该方法传回该资源所支持的所有HTTP请求，也可以测试服务器是否可以正常使用。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods" target="_blank" rel="noopener">MDN</a></p>
<p><a href="https://www.runoob.com/http/http-methods.html" target="_blank" rel="noopener">菜鸟联盟</a></p>
<p><a href="https://blog.csdn.net/kobejayandy/article/details/24606521" target="_blank" rel="noopener">CSDN-kobejayandy</a></p>
<p><a href="https://www.jianshu.com/p/93727598b564" target="_blank" rel="noopener">简书-5onghua</a></p>
<p><a href="https://www.zhihu.com/question/31640769" target="_blank" rel="noopener">知乎</a></p>
<p><a href="https://www.cnblogs.com/liuzhenbo/p/11045048.html" target="_blank" rel="noopener">博客园-心田居士</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP状态码</title>
    <url>/2020/03/13/httpStatusCode/</url>
    <content><![CDATA[<h1 id="什么是HTTP状态码？"><a href="#什么是HTTP状态码？" class="headerlink" title="什么是HTTP状态码？"></a>什么是HTTP状态码？</h1><p>所谓的HTTP状态码就是表示网页服务器超文本传输协议(HyperText Transfer protocol)响应状态的3位十进制数字代码，它由<a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">RFC2616</a>规范定义，并由互联网号码分配局(Internet Assigned Numbers Authority)维护。当浏览者访问一个网页时，浏览器会向服务器发送请求，服务器会返回一个包含HTTP状态码的信息头(server head)响应网页请求。</p>
<p>换句话说HTTP状态码就是统一标准被大家都认可的一个表示网页与服务器之间通信状态的一个东西。</p>
<h1 id="常用状态码"><a href="#常用状态码" class="headerlink" title="常用状态码"></a>常用状态码</h1><ul>
<li>200 - 请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL</li>
<li>404 - 请求的资源（网页等）不存在</li>
<li>500 - 内部服务器错误</li>
</ul>
<h1 id="HTTP状态码的分类"><a href="#HTTP状态码的分类" class="headerlink" title="HTTP状态码的分类"></a>HTTP状态码的分类</h1><p>HTTP状态码由三个十进制组成，只有第一个十进制定义了分类，后面两个无分类作用，其具体分类如下：</p>
<h2 id="1-信息"><a href="#1-信息" class="headerlink" title="1** 信息"></a>1** 信息</h2><p>服务器收到请求，需要请求者继续执行操作。</p>
<p>服务器：老客啊，你到底想干啥？？？</p>
<table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">状态码英文名称</th>
<th align="left">中文描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100</td>
<td align="left">Continue</td>
<td align="left">继续。客户端应继续其请求</td>
</tr>
<tr>
<td align="left">101</td>
<td align="left">Switching Protocols</td>
<td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
</tbody></table>
<h2 id="2-成功"><a href="#2-成功" class="headerlink" title="2** 成功"></a>2** 成功</h2><p>操作被成功接收并处理。</p>
<p>服务器：老客啊，不愧是cp，你看这次咱俩配合的多默契。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态码英文名称</th>
<th>中文描述</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK</td>
<td>请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td>已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td>203</td>
<td>Non-Authoritative Information</td>
<td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td>205</td>
<td>Reset Content</td>
<td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content</td>
<td>部分内容。服务器成功处理了部分GET请求</td>
</tr>
</tbody></table>
<h2 id="3-重定向"><a href="#3-重定向" class="headerlink" title="3**  重定向"></a>3**  重定向</h2><p>需要进一步的操作以完成请求。</p>
<p>服务器：老客啊，你要的东西不在这，你换个地方去拿。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态码英文名称</th>
<th>中文描述</th>
</tr>
</thead>
<tbody><tr>
<td>300</td>
<td>Multiple Choices</td>
<td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently</td>
<td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy</td>
<td>使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td>306</td>
<td>Unused</td>
<td>已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect</td>
<td>临时重定向。与302类似。使用GET请求重定向</td>
</tr>
</tbody></table>
<h2 id="4-客户端错误"><a href="#4-客户端错误" class="headerlink" title="4** 客户端错误"></a>4** 客户端错误</h2><p>请求包含语法错误或无法完成请求。</p>
<p>服务器：老客啊，这是你的错，不怨我。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态码英文名称</th>
<th>中文描述</th>
</tr>
</thead>
<tbody><tr>
<td>400</td>
<td>Bad Request</td>
<td>客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>请求要求用户的身份认证</td>
</tr>
<tr>
<td>402</td>
<td>Payment Required</td>
<td>保留，将来使用</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td>客户端请求中的方法被禁止</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required</td>
<td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td>408</td>
<td>Request Time-out</td>
<td>服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td>409</td>
<td>Conflict</td>
<td>服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td>410</td>
<td>Gone</td>
<td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td>411</td>
<td>Length Required</td>
<td>服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed</td>
<td>客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td>413</td>
<td>Request Entity Too Large</td>
<td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td>414</td>
<td>Request-URI Too Large</td>
<td>请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type</td>
<td>服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td>416</td>
<td>Requested range not satisfiable</td>
<td>客户端请求的范围无效</td>
</tr>
<tr>
<td>417</td>
<td>Expectation Failed</td>
<td>服务器无法满足Expect的请求头信息</td>
</tr>
</tbody></table>
<h2 id="5-服务器错误"><a href="#5-服务器错误" class="headerlink" title="5**  服务器错误"></a>5**  服务器错误</h2><p>服务器在处理请求的过程中发生了错误。</p>
<p>服务器：嗯。这次是我的错误。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态码英文名称</th>
<th>中文描述</th>
</tr>
</thead>
<tbody><tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented</td>
<td>服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Time-out</td>
<td>充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version not supported</td>
<td>服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">菜鸟联盟大佬</a></p>
<p><a href="https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660" target="_blank" rel="noopener">度娘</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHubReadme</title>
    <url>/2000/03/13/README/</url>
    <content><![CDATA[<p>用hexo开始写博客，辛辛苦苦写的文章放在这个仓备份一下吧。</p>
<p>如果你对我的博客感兴趣欢迎来访问。</p>
<p>GitHub：<a href="https://lesvay.github.io/">https://lesvay.github.io/</a></p>
<p>Gitee：<a href="https://lesvay.gitee.io/" target="_blank" rel="noopener">https://lesvay.gitee.io/</a></p>
]]></content>
  </entry>
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>408刷题笔记10</title>
    <url>/2020/04/08/note40810/</url>
    <content><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="CPU的功能和基本概念"><a href="#CPU的功能和基本概念" class="headerlink" title="CPU的功能和基本概念"></a>CPU的功能和基本概念</h2><p>条件转移指令依据标志寄存器</p>
<p>指令寄存器对用户透明</p>
<p>PC属于控制器</p>
<p>程序计数器位数取决于存储器的容量，指令寄存器的位数取决于指令字长，通用寄存器的位数取决于机器字长</p>
<p>地址译码器不属于CPU</p>
<p>CPU专用寄存器：PC程序计数器、IR指令寄存器、MDR存储器数据寄存器、MAR存储器地址寄存器、PSW程序状态字寄存器</p>
<h2 id="指令执行过程"><a href="#指令执行过程" class="headerlink" title="指令执行过程"></a>指令执行过程</h2><p>空操作取指后PC也会自加1</p>
<p>DMA每传送一个数据就占用存取周期</p>
<p>取指操作是自动进行的不需要得到相应的指令</p>
<p>CPU响应中断的时间，在一条指令执行结束后，进入中断周期</p>
<p>指令字长取决于操作码长度、操作数地址的长度和 操作数地址的个数</p>
<h2 id="数据通路的功能和基本结构"><a href="#数据通路的功能和基本结构" class="headerlink" title="数据通路的功能和基本结构"></a>数据通路的功能和基本结构</h2><p>CPU数据通路的基本结构：总线结构和专用数据通路结构</p>
<p>总线结构：单总线结构、双总线结构、多总线结构</p>
<h2 id="控制器的功能和工作原理"><a href="#控制器的功能和工作原理" class="headerlink" title="控制器的功能和工作原理"></a>控制器的功能和工作原理</h2><p>CU输入信号来源：经指令译码器译码产生的指令信息、时序系统产生的机器周期信号和节拍信号、来自执行单元的反馈信息即标志，前两个是主要因素。</p>
<p>机器指令的操作码字段指出各个微程序的入口地址</p>
<p>微程序速度慢但较为灵活，控制器由ROM组成。一条微指令存放在控制器的一个空存单元中。</p>
<p>微程序控制器中，控制部件向执行部件发出的控制信号称为微命令。</p>
<p>在一个CPU周期中，一组实现一定功能的微命令的组合构成一条微指令，有序的微指令序列构成一段微程序，微程序的作用是实现一条对应的机器指令。</p>
<p>水平型微指令字长程序短，可以定义并执行几种并行的基本操作。</p>
<p>垂直型微指令字短程序长，只能定义并执行一种基本操作。</p>
<p>微程序个数=机器指令n+公共取指微指令+中断周期微指令</p>
<p>CPU控制器：指令寄存器、程序计数器、操作控制器</p>
<p>主机中寄存器位数：ACC32\MQ32\ALU32\IR32\MDR32\PC16\MAR16</p>
<h2 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h2><p>指令流水线阻塞：结构相关（资源相关）、数据相关、控制相关</p>
<p>空间并行技术：多个功能部件共同执行同一任务的不同部分</p>
<p>时间并行技术：多个功能部件时间上错开，轮流执行不同任务的相同部分</p>
<p>指令冒险即数据相关，一个程序中必须等前一天指令执行完才能执行后一条指令。</p>
<p>解决数据相关问题：暂停相关指令的执行（暂停流水线）、采用专门的数据通路（旁路技术）。</p>
<p>指令周期：IF-&gt;ID-&gt;EX-&gt;WB</p>
<h2 id="总线概述"><a href="#总线概述" class="headerlink" title="总线概述"></a>总线概述</h2><p>猝发传输（突发传输）是在一个总线周期中，可以传输多个存储地址连续的数据，即一次传输一个地址和一批地址连续的数据。</p>
<p>按功能分：片内总线、系统总线（数据总线、地址总线、控制总线）、通信总线</p>
<p>按标准：ISA总线、VESA总线、PCI总线</p>
<p>三总线结构：DMA总线、主存总线、I/O总线</p>
<p>控制总线中控制信号：时序信号、I/O设备和存储器的响应信号</p>
<h2 id="总线仲裁"><a href="#总线仲裁" class="headerlink" title="总线仲裁"></a>总线仲裁</h2><p>n个设备：链式查询3条控制线、计数器定时查询[log2n]+2、独立请求2n+1</p>
<p>计数器定时查询，当计数器永远从0开始，则靠近仲裁机构的优先级高。若从断点开始计数，则优先级相等。</p>
<p>总先忙信号由获得总线使用权的设备发出的。</p>
<h2 id="总线操作和定时"><a href="#总线操作和定时" class="headerlink" title="总线操作和定时"></a>总线操作和定时</h2><p>全互锁、半互锁、不互锁</p>
<h2 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h2><p>典型总线标准：ISA、EISA、VESA、PCI、PCI-Express、AGP、USB、RS-232C</p>
<p>USB是串行总线，同时只能传播一位数据</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>408</tag>
      </tags>
  </entry>
  <entry>
    <title>408刷题笔记9</title>
    <url>/2020/04/07/note4089/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="网络层的功能"><a href="#网络层的功能" class="headerlink" title="网络层的功能"></a>网络层的功能</h2><p>异构网络是指传输介质、数据编码方式、链路控制协议以及不同的数据单元格式和转发机制。在物理层和数据链路层定义。</p>
<h2 id="路由算法"><a href="#路由算法" class="headerlink" title="路由算法"></a>路由算法</h2><p>由于“好的消息传得快，坏的消息传的慢”路由信息变化时未能及时被所有路由器知道，导致慢收敛现象，导致路由接受了无效的信息，从而产生了路由回路问题。</p>
<p>直接交付：发送方和目的站具有相同的子网地址</p>
<p>分层路由路由器被划分为区域，仅知道自己所在区域的目标地址。</p>
<h2 id="IPV4"><a href="#IPV4" class="headerlink" title="IPV4"></a>IPV4</h2><p>协议字段表示使用IP协议的上层协议，6TCP,17UDP</p>
<p>版本字段表示IP协议的版本，4IPv4，6IPv6</p>
<p>首部长度以32bit为计数单位，总长度以8bit为计数单位</p>
<p>片偏移8bit为单位</p>
<p>127.x.x.x回路测试</p>
<p>避免无限转发环路分组的方法是设定生命周期TTL</p>
<p>NAT表项由管理员添加，如果没有就直接不转发丢弃。</p>
<p>ICMP差错报告报文：重点不可达、源点抑制（路由或主机因拥塞而丢弃数据）、时间超过、参数问题、改变路由（重定向）</p>
<p>ping使用了ICMP询问报文中的回送请求和回答请求</p>
<p>首部长度</p>
<p>MF=1表示后面还有其他分片</p>
<p>DF=1表示可以分片</p>
<h2 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h2><p>16个字节，128位</p>
<p>IPV6取消了校验和字段，首部长度固定，也不需要首部长度字段。</p>
<p>IPV6不允许分片，如果数据报太大，则路由器把该数据报丢弃</p>
<h2 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h2><p>路由选择功能：获取网络拓扑信息、构建路由表、在网络中更新路由信息、选择到达每个目的网络的最优路径、识别一个网络的无环通路。</p>
<p>路由收敛是指当路由环境发生变化后，各路由器调整自己的路由表以适应网络拓扑结构的变换，最终达到稳定状态</p>
<p>RIP是应用层协议，OSPF是网络层协议</p>
<p>OPSF使用hello分组与邻居保持连接</p>
<p>OSPF路由器：区域内部路由器、主干路由器、区域边界路由器、自治域边界路由器</p>
<p>BGP交换的网络可达性信息是到达某个网络所经过的路径</p>
<h2 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a>IP组播</h2><p>一个组播所需要的带宽小于多个单播带宽之和</p>
<p>组播地址范围：224.0.0.0-239.255.255.255</p>
<p>组播需要路由器增加一些能够识别组播的软件</p>
<h2 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h2><p>当一个分组到达用户的本地LAN时，它被转送发给某一台与本地LAN相连接的路由器。该路由器寻找目的主机，这时本地代理响应该请求，将这些分组封装到一些新IP分组的载荷，并将新分组发送给外部代理，外部代理将分组移交给移动后的主机。</p>
<p>注册过程将新的可达信息通知归属代理。</p>
<p>移动主机在原始本地网时，获得的是主地址，当移动到其他网段后会产生一个临时辅地址。</p>
<h2 id="网络层设备"><a href="#网络层设备" class="headerlink" title="网络层设备"></a>网络层设备</h2><p>路由器依据传输距离进行选择</p>
<p>路由选择处理机根据选定的路由选择协议构造路由表</p>
<p>分组转发部分：交换结构、输入端口、输出端口</p>
<p>路由选择部分：路由选择处理机、路由选择协议、路由表</p>
<p>默认路由，目的地址：0.0.0.0，子网掩码：0.0.0.0</p>
<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="IO方式"><a href="#IO方式" class="headerlink" title="IO方式"></a>IO方式</h2><p>中断处理过程：关中断-&gt;保存断点-&gt;识别中断源-&gt;保存现场-&gt;中断事件处理-&gt;恢复现场-&gt;开中断-&gt;中断返回</p>
<p>高优先级置0表示可被中断，比该中断优先级低的置1表示不可被中断。</p>
<p>总线仲裁方式I/O设备争用总线，中断判优方式I/O设备争用CPU</p>
<p>中断向量地址是中断服务程序入口地址的地址</p>
<p>自陷是人为设定的特殊处理机制</p>
<p>CPU会统一扫描各中断源进行判优决定响应哪个中断源，每个存储周期结束后检查是否有DMA</p>
<p>主存故障引起机器校验中断（内中断）</p>
<p>输入输出引起访管中断，需要调用系统接口</p>
<p>主存和CPU以外的中断叫外中断</p>
<p>高中断级别-&gt;低中断级别，0表示不可中断，1表示可中断</p>
<p>中断保护：PC和PSW，由硬件完成</p>
<p>DMA只能用于数据传输，不能中断程序。不占用程序计数器和寄存器</p>
<p>CPU工作周期：取指周期、间址周期、执行周期、中断周期</p>
<p>DMA可以在CPU工作周期间的任意缝隙中</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>408</tag>
      </tags>
  </entry>
  <entry>
    <title>408刷题笔记8</title>
    <url>/2020/04/06/note4088/</url>
    <content><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="IO管理概述"><a href="#IO管理概述" class="headerlink" title="IO管理概述"></a>IO管理概述</h2><p>可寻址是块设备的基本特征</p>
<p>共享设备是可寻址的和可随机访问的。一段时间允许多个进程同时访问，同一时间只允许一个进程访问。不会引起进程死锁。</p>
<p>I/O即设备控制器实现对设备的控制</p>
<p>DMA是I/O设备和主存之间的数据通路，不经过CPU。DMA是方式，通道是处理器。</p>
<p>命令/状态寄存器控制DMA的工作模式并反映给CPU当前的状态，地址寄存器存放DMA作业时的源地址和目标地址，数据寄存器存放DMA转移的数据。</p>
<p>字节多路通道，各个通道循环使用主通道，适合大量低速或中速I/O设备</p>
<p>绝对号：区分和识别设备</p>
<p>固有属性：决定了设备的使用方式</p>
<p>独立性：提高设备分配的灵活性和利用率</p>
<p>安全性：保证分配设备不会永久阻塞</p>
<p>通道设备控制设备控制器、设备控制器控制设备工作</p>
<p>所有设备启动工作由系统统一来做</p>
<p>来自通道的I/O中断事件由设备管理负责处理</p>
<p>编制好的通道程序是存放在主存中的</p>
<p>通道在完成通道程序后向CPU发出报告产生中断</p>
<p>设备驱动程序按类型分配，每类提供一个</p>
<p>系统调用命令是接口，不会改变。设备驱动程序负责执行操作系统发出的I/O命令，因设备不同而不同</p>
<p>I/O流程：用户程序-&gt;系统调用处理程序(设备无关软件)-&gt;设备驱动程序-&gt;中断处理程序</p>
<p>通道方式相对于DMA方式CPU干预更深，而且可以使用一些指令灵活改变通道程序</p>
<p>DMA方式传输批量数据以存储器为核心，中断控制方式传输以字节为单位以CPU为核心</p>
<h2 id="IO核心子系统"><a href="#IO核心子系统" class="headerlink" title="IO核心子系统"></a>IO核心子系统</h2><p>设备分配的数据结构：SDT系统设备表（整个系统只有一张）-&gt;DCT设备控制表（每个设备有一张）-&gt;COCT控制器控制表（每个控制器）&lt;-&gt;CHCT通道控制表（每个通道）</p>
<p>SPOOLing输入输出井磁盘上的存储空间，缓冲池是在内存开辟空间。</p>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="传输层提供的服务"><a href="#传输层提供的服务" class="headerlink" title="传输层提供的服务"></a>传输层提供的服务</h2><p>可靠是指使用确认机制来确保传输的数据不丢失</p>
<p>TCP报文长20B，IP报文长20B</p>
<p>使用UDP传输时，应用层要提供可靠性方面的工作</p>
<h2 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h2><p>伪首部只在计算校验和时临时添加，不计入UDP的长度中。</p>
<p>UDP数据报格式包括：源端口号、目的端口号、报文长度和校验和。</p>
<p>长度字段记录UDP数据包的长度，包括首部和数据部分。</p>
<p>校验和不是必须的，如果不使用则将校验和字段设置为0，如果校验结果为0，则将校验和全置为1</p>
<p>标识符相同才可以进行组装</p>
<h2 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h2><p>协议字段：17UDP,6TCP</p>
<p>TCP采用的是报文段的确认机制</p>
<p>TCP最大数据流：接收方允许的窗口和拥塞窗口最小值</p>
<p>滑动窗口的作用：流量控制</p>
<p>拥塞窗口是发送端根据网络拥塞情况确定的窗口值</p>
<p>新的RTT=（1-α）×（旧RTT）+α×新的RTT样本</p>
<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="IO系统基本概念"><a href="#IO系统基本概念" class="headerlink" title="IO系统基本概念"></a>IO系统基本概念</h2><p>I/O设备通过设备控制器与总线相连</p>
<p>通道程序存放在主存中，通道程序由通道执行</p>
<h2 id="外部设备"><a href="#外部设备" class="headerlink" title="外部设备"></a>外部设备</h2><p>打印机从打字原理区分分为击打式和非击打式。按照能否打出汉字来区分分为点阵式和活字式。</p>
<p>汉字内码在主存中占用8个字节</p>
<p>VRAM存放ASCII码显示字符</p>
<p>RAID是无冗余和无校验，有多个物理盘组成，不影响磁记录密度，也不会提高磁盘利用率</p>
<h2 id="IO接口"><a href="#IO接口" class="headerlink" title="IO接口"></a>IO接口</h2><p>I/O的命令字、状态字、中断类型号</p>
<p>区分存储单元和I/O设备需要不同的地址码</p>
<p>I/O功能：数据格式转换、I/O过程中错误与状态检测、I/O操作的控制与定时、与主机和外设通信</p>
<p>按照数据传输格式可以将接口分为并行接口和串行接口</p>
<p>统一编址方式下，存储单元和I/O设备是靠不同的地址码区分，访存指令可以访问I/O设备</p>
<p>独立编址方式下，存储单元和I/O设备是靠不同的指令来区分</p>
<p>数据传输发生在通用寄存器和I/O端口之间</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>408</tag>
      </tags>
  </entry>
  <entry>
    <title>408刷题笔记7</title>
    <url>/2020/04/05/note4087/</url>
    <content><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="指令格式"><a href="#指令格式" class="headerlink" title="指令格式"></a>指令格式</h2><p>运算型指令寻址的是操作数，转移型指令寻址的则是下次欲执行的指令的地址</p>
<p>零地址运算指令又称堆栈运算指令，参与的两个操作数来自栈顶和次栈顶单元。</p>
<h2 id="指令寻址方式"><a href="#指令寻址方式" class="headerlink" title="指令寻址方式"></a>指令寻址方式</h2><p>不同寻址方式可以缩短指令字长、扩大寻址空间、提高编程的灵活性。</p>
<p>寄存器寻址只需指定寄存器编号，可以缩短地址码位数。</p>
<p>隐地址在指令中隐含操作数的地址，可以简化地质结构，如零地址指令。</p>
<p>寄存器中的内容和指令地址码相加得到的是操作数的地址码</p>
<table>
<thead>
<tr>
<th></th>
<th>基址寻址</th>
<th>变址寻址</th>
</tr>
</thead>
<tbody><tr>
<td>有效地址</td>
<td>EA=(BR)+A</td>
<td>EA=(IX)+A</td>
</tr>
<tr>
<td>访问次数</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>寄存器内容</td>
<td>有操作系统或管理程序确定</td>
<td>由用户设定</td>
</tr>
<tr>
<td>程序执行过程中值可变否</td>
<td>不可变</td>
<td>可变</td>
</tr>
<tr>
<td>特点</td>
<td>有利于多道程序设计和编制浮动程序</td>
<td>有利于处理数据问题和编制循环程序</td>
</tr>
</tbody></table>
<p>相对寻址有利于程序浮动</p>
<p>跳跃寻址可实现程序条件或无条件转移</p>
<p>机器按字寻址，PC取决于存储器的个数</p>
<p>寄存器间接寻址EA=（Ri）</p>
<p>转移指令、子程序调用与返回指令用于解决变动程序中指令执行次序的需求。</p>
<p>变长指令中寄存器寻址无需到内存读取速度最快，定长指令中直接寻址速度最快。</p>
<p>寄存器寻址和寄存器间接寻址寻址最短，直接寻址、间接寻址、立即寻址指令码长度最长。</p>
<table>
<thead>
<tr>
<th>寻址方式</th>
<th>EA公式</th>
</tr>
</thead>
<tbody><tr>
<td>直接寻址</td>
<td>EA=A</td>
</tr>
<tr>
<td>间接寻址</td>
<td>EA=(A)</td>
</tr>
<tr>
<td>变址寻址</td>
<td>EA=(RX)+A</td>
</tr>
<tr>
<td>相对寻址</td>
<td>EA=(PC)+A</td>
</tr>
</tbody></table>
<h2 id="CISC和RISC的基本概念"><a href="#CISC和RISC的基本概念" class="headerlink" title="CISC和RISC的基本概念"></a>CISC和RISC的基本概念</h2><p>RISC大多数指令在一个时钟周期内完成，内部通用寄存器相对于CISC多，指令数、寻址方式和指令合适种类相对于CISC少。以硬布线逻辑为主不用或者少用微程序控制。</p>
<p>RISC中指令长度一致、按边界对齐存放、仅Load/Store指令访存。增加寄存器的数目以减小访存次数、种类少功能简单、通过简单指令的组合来实现复杂指令功能。</p>
<p>RISC精简指令系统计算机</p>
<p>CSIC复杂指令系统计算机</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="文件系统基础"><a href="#文件系统基础" class="headerlink" title="文件系统基础"></a>文件系统基础</h2><p>打开文件的操作：把指定文件的目录（控制块）复制到内存指定的区域</p>
<p>read要求提供的参数：文件描述符fd、buf缓冲区首址、传送的字节数n</p>
<p>建立符号链接计数值直接复制，建立硬链接计数值+1，删除时符号链接不变（若访问时，发现该文件已经不存在则直接删除符号链接），硬链接-1（若不为0，则不能删除）</p>
<p>系统级安全管理包括注册和登录</p>
<p>对于一个文件的访问常由用户访问权限和文件属性</p>
<p>位示图用于磁盘空间管理，是空闲块管理方法</p>
<h2 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h2><p>FCB分解：将FCB一部分数据分解出去，存放在另一个数据结构中，在目录中仅留下文件的基本信息和指向该数据结构的指针。</p>
<h2 id="磁盘组织与管理"><a href="#磁盘组织与管理" class="headerlink" title="磁盘组织与管理"></a>磁盘组织与管理</h2><p>旋转延迟的大小与磁盘调度算法无关、取决于磁盘空闲空间的分配程序、与文件的物理结构有关。</p>
<p>磁盘格式化：建立文件系统的根目录、对保存空间磁盘块信息的数据结构进行初始化</p>
<p>柱面号：文件记录数/扇区数</p>
<p>磁道号：（文件记录数 MOD 扇区数）DIV 盘面</p>
<p>扇区号：（文件记录数 MOD 扇区数）MOD 盘面</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h2><p>客户机面向用户、服务器面向任务</p>
<p>授权域名服务器将其管辖的主机名转换为主机的IP地址</p>
<p>DNS分组丢失可以多次请求，是幂等的，多次请求与一次请求结果一致，不会有危害。</p>
<h2 id="文件传输协议"><a href="#文件传输协议" class="headerlink" title="文件传输协议"></a>文件传输协议</h2><p>客户端端口号不固定，服务器数据连接20，控制连接21</p>
<p>数据连接在传输完数据后就关闭，控制连接一直连接</p>
<p>一个特殊的用户名anonymous，密码为任意</p>
<p>POP3明文本传输加密</p>
<p>MIME扩充邮件服务，增加了邮件主体结构，定义了传送非ASCII码的编码规则</p>
<h2 id="万维网WWW"><a href="#万维网WWW" class="headerlink" title="万维网WWW"></a>万维网WWW</h2><p>connection中close非持续连接，keep-alive持续链接</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>408</tag>
      </tags>
  </entry>
  <entry>
    <title>408刷题笔记6</title>
    <url>/2020/04/04/note4086/</url>
    <content><![CDATA[<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h2><p>程序编译过程：预处理cpp-&gt;编译ccl-&gt;汇编as-&gt;链接ld-&gt;可执行文件。形成逻辑地址的阶段：链接。完成逻辑到物理地址的变换：装载。</p>
<p>程序正在I/O操作时不能交换主存，否则它的I/O数据区将被新换入的进程占用，导致错误。</p>
<p>段页式系统中，进程首先划分为段，每段再进一步划分为页</p>
<p>覆盖技术：单一连续存储管理、固定分区分配的存储管理</p>
<p>静态装入：编程阶段九八物理地址计算好</p>
<p>可重定位：装入时把逻辑地址转换为物理地址，但装入后不能改变</p>
<p>动态重定位：执行时再决定装入地址并装入，同一个模块在内存的物理地址有可能改变。</p>
<p>产生内部碎片：分页式、固定分区、段页式</p>
<p>产生外部碎片：分段式</p>
<p>页表的首地址 存放在页表基址寄存器中PTBR</p>
<p>分段是在用户编程时，将程序按照逻辑划分为几个逻辑段。分段存储，将程序按照逻辑段划分有利于其动态链接。</p>
<p>可重入程序，通过共享来使用同一块存储空间，通过动态连接的方式将所需的程序段映射到相关进程中去，减少了对换数量。</p>
<p>段式存储：方便编程、分段共享、分段保护、动态链接和动态增长</p>
<p>主存的访问是以字节或字为单位</p>
<p>分页：固定长度，只需给出地址</p>
<p>分段：不固定，要给出段名和段内地址</p>
<p>段页式存储：分段的方法分配和管理用户地址空间，分页方法来管理物理存储空间</p>
<p>动态分区有外部碎片无内部碎片</p>
<p>固定分区有内部碎片无外部碎片</p>
<h2 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h2><p>虚拟存储是补充内存逻辑空间的技术</p>
<p>虚拟存储器最大容量由计算机的地址结构决定</p>
<p>分页存储间接扩充了内存</p>
<p>修改位和访问位供调出页面使用</p>
<p>抖动：频繁的引入主存页面，淘汰后立即调入，调然后又立即淘汰</p>
<p>虚拟存储技术存储管理方法需要有请求机制</p>
<p>快表（相联存储器）用于地址变换</p>
<p>只有FIFO会导致Belady异常</p>
<p>交换技术交换的是整个进程，而虚拟存储技术交换的是部分进程</p>
<p>覆盖技术覆盖段相互独立，不存在交叉访问。</p>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h2><p>FDM适合传输模拟，TDM适合传输数字</p>
<p>1-坚持型CSMA 监听到信道忙继续监听直到空闲发送数据</p>
<p>p-坚持型CSMA 监听到信道忙等待下一时隙监听空闲概论P发送数据，忙以概论1-p推迟到下一时隙监听</p>
<p>非坚持型CSMA监听到信道忙随机等待再监听</p>
<p>争议期：冲突检测时间，信号在最远两个端点之间往返传输的时间</p>
<p>二进制指数回退算法：后退延时的取值范围与重发次数n形成二进制指数关系。网络负载小，后退延时的取值范围小，负载大，其取值也大。取值越大帧重传时再次发生冲突的概论越低。在0——2^(i-1)中取一个数。</p>
<p>CSMA/CA对正确接收的数据帧进行确认，无线局域网，不需要在发送过程中进行中途检测</p>
<p>CSMA/CD有线网络</p>
<p>令牌环网不会产生冲突，适合负载重的网络。</p>
<h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><p>MAC提供无连接不可靠服务</p>
<p>网卡实现的功能在物理层和数据链路层</p>
<p>MAC地址冲突时，两台设备都不能正常使用</p>
<p>MAC子层：组帧、拆帧、比特差错检测、寻址、竞争处理</p>
<p>LLC子层：建立和释放数据链路层的逻辑链接、提供与高层的接口、差错控制、给帧加序号</p>
<h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><p>局域网包括以太网、令牌环网等</p>
<p>从互联网角度看局域网与广域网平等</p>
<p>互联网可以连接不同类型网络</p>
<p>广域网使用分组交换技术</p>
<p>PPP：字符填充，面向字节的协议。由链路控制协议LCP（扩展链路控制协议，用于建立、配置、测试和管理数据链路）、网络控制协议NCP（为网络层协议建立和配置逻辑链接）、一个将IP数据报封装到串行链路的方法。</p>
<p>HDLC：面向比特的协议，零比特填充，5个1后面加0。正常响应模式下只能由主站启动。包括信息帧(I帧)、监督帧(S帧)、无编号帧(U帧)</p>
<h2 id="数据链路层设备"><a href="#数据链路层设备" class="headerlink" title="数据链路层设备"></a>数据链路层设备</h2><p>物理层设备不可以分割冲突域，数据链路层可以分割冲突域，不能分割广播域，网络层设备可以分割广播域。</p>
<p>交换机比集线器优点：支持多用户同时通讯</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>408</tag>
      </tags>
  </entry>
  <entry>
    <title>408刷题笔记5</title>
    <url>/2020/04/03/note4085/</url>
    <content><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="半导体随机存储器"><a href="#半导体随机存储器" class="headerlink" title="半导体随机存储器"></a>半导体随机存储器</h2><p>芯片引脚数=地址线+数据线+片选线+读控制线RD+写控制线WE</p>
<p>采用地址复用技术引脚数=地址线/2+数据线+行通选线(片选项)+列通选线+读控制线RD+写控制线WE</p>
<p>DRAM采用地址复用技术</p>
<p>DRAM刷新以行为单位</p>
<p>分散刷新不存在死时间</p>
<p>DRAM集成度高，需要刷新，一次刷新过程只占用一个周期。易失性半导体。依靠电容暂存电荷来存储信息，有电荷为1，无电荷 态来存储0和1</p>
<p>闪存属于ROM，是非易失的</p>
<p>RAM和ROM都是随机存取，RAM是随机存取器：Cache</p>
<p>ROM只读，写的话需要擦除：EPROM、FlashMemory、CD-ROM</p>
<p>操作系统引导程序存储在ROM内存，执行程序存在RAM内存</p>
<p>增加存储器带宽： 采用高速DRAM芯片、采用多体交叉存储器、刷新存储器至显示控制器的内部总线宽度加倍、采用双端口存储器将刷新端口和更新端口分开</p>
<p>死时间率=刷新时间/总时间，总时间一般为2ms</p>
<h2 id="主存储器与CPU的连接"><a href="#主存储器与CPU的连接" class="headerlink" title="主存储器与CPU的连接"></a>主存储器与CPU的连接</h2><p>数据位是行，地址位是列</p>
<p>地址要2^n，数据直接</p>
<p>地址是字，数据是位</p>
<p>2000H=2*16^3=2^13</p>
<p>地址寄存器存放CPU要访问/写入的内存单元地址，数据寄存器存放CPU要读取/写入的数据</p>
<h2 id="双口RAM和多模块存储器"><a href="#双口RAM和多模块存储器" class="headerlink" title="双口RAM和多模块存储器"></a>双口RAM和多模块存储器</h2><p>双端口RAM左右端口同时读写某一个地址时会发生冲突。可以同时访问同一区间和单元。</p>
<p>高位多体交叉存储器不能满足局部性原理，低位多体交叉存储器满足局部性原理。</p>
<p>多体变单体字长扩大，有利于提高读写速度，但是不够灵活</p>
<p>多端口存储器是对同一个存储体使用多套读写电路实现。不能对其的同一个存储单元同时执行多个写入操作</p>
<p>多体结构存储器则允许在同一个存储周期对几个存储体执行写入操作</p>
<p>四体交叉存储冲突：序列%4，相邻的四个区域内相同则冲突</p>
<h2 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h2><p>Cache当写不中时加载相应的低一级的块到高速缓存中，然后更新这个高速缓存，称为写分配。而避开Cache，直接将字写到主存中称为非写分配。</p>
<p>不命中Cache时是写分配和非写分配。命中时是非写分配法和全写法。</p>
<p>时间局部性：一条指令被执行，不久的将来他有可能再次被执行</p>
<p>空间局部性：一条指令被访问，不久的将来他有可能再次被访问</p>
<p>写回法减少了方寸次数，但存在不一致隐患</p>
<p>写直通法保证数据一致，较高的安全性，把数据直接写入主存和Cache</p>
<h2 id="虚拟存储器"><a href="#虚拟存储器" class="headerlink" title="虚拟存储器"></a>虚拟存储器</h2><p>虚拟存储器应具有较强的局部性</p>
<p>程序局部性原理：一个程序执行过程中其大部分情况下是顺序执行的，某条指令或数据使用后，在最近一段时间内较大可能再次被访问（时间局部性），邻近的指令或数据有可能在近期被使用（空间局部性）。程序对主存的访问是不均匀的。</p>
<p>Cache中存放的是主存的一部分副本，TLB（快表）中存放的是page（页表）。Cache命中，则page命中。TLB命中，则page命中，反之未必。</p>
<p><img src="/2020/04/03/note4085/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E5%85%B3%E7%B3%BB.png" alt="虚拟存储器关系"></p>
<p>虚拟存储器需要对操作系统实现地址映射，故对系统程序员不透明</p>
<p>快表采用了相联存储器件，按照查找内容访问，因此比慢表查找速度块。</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>临界区指系统中用于发访问共享资源的代码。共享的，每次只能一个人使用。</p>
<p>信号量包括：互斥量和资源量，只有初始化和PV操作才能改变其值。</p>
<p>互斥量：1表示只允许一个进程进入，0表示已经有一个程序进入，小于0其绝对值表示等待的进程个数。</p>
<p>资源量：大于0表示可用资源数，小于等于0其绝对值表示等待的进程数。</p>
<p>同步机制的四个准则：空闲让进、忙则等待、让权等待、有限等待</p>
<p>互斥关系：进程之间因相互竞争使用独占性资源产生的制约关系。同步关系：进程之间为协同工作需要交换信息、相互等待而产生的制约关系。</p>
<p>PV操作属于低级的进程通信原语，不能被中断。</p>
<p>管程定义了一个数据结构和能为并发进程所执行的一组操作，这组操作可以同步进程和改变管程中的数据。</p>
<p>管程由局部于管程的共享变量说明、该数据结构进行操作的一组过程、对局部于管程的数据设置初始值的语句，为管程赋予一个名字。</p>
<p>管程可以解决临界区分散所带来的管理和控制问题。</p>
<p>管程是进程同步的工具，用于解决信号量机制大量同步操作分散的问题，每次只允许一个进程进入管程，便于共享资源又互斥。它是被进程调用，是语法范围，无法创建和撤销。</p>
<p>管程中V操作一定会改变信号量，而signal操作是针对某个条件的变量，如果不存在因该条件而阻塞的进程，则signal不会产生任何影响。</p>
<p>P阻塞，V唤醒</p>
<p>可重入编码编写，才能实现共享功能</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>死锁的预防：破环互斥、破环占用并请求（一次性分配）、破坏循环等待（有序分配）、破环不可剥夺（剥夺资源）</p>
<p>死锁的避免：防止系统进入不安全状态，银行家算法</p>
<p>死锁的检测：资源有向图法、资源矩阵法</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>408</tag>
      </tags>
  </entry>
  <entry>
    <title>408刷题笔记4</title>
    <url>/2020/04/02/note4084/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h2><p>传统以太网采用广播方式发送，主机间的通信方式是半双工</p>
<p>单模光纤：如果光纤的直径减小到和光前波长相同的适合，光纤如图一个波导，光在其中没有反射，而沿直线传播</p>
<table>
<thead>
<tr>
<th>物理层特性</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>电气特性</td>
<td>规定了信号的电压高低、传输距离等</td>
</tr>
<tr>
<td>功能特性</td>
<td>指明某条线上某一电平的电压表示何种意义</td>
</tr>
<tr>
<td>过程特性</td>
<td>定义了各条物理线路的工作过程和时序关系</td>
</tr>
</tbody></table>
<h2 id="物理层设备"><a href="#物理层设备" class="headerlink" title="物理层设备"></a>物理层设备</h2><p>中继器：将衰减的信号再生</p>
<p>物理层互联：数据传输速率要相同，否则会出现接收方来不及接收数据，导致数据丢失。或接受太快，导致效率低。</p>
<p>中继器或集线器：5个网段、4个中继器或集线器、3个网段为主机段。也就是说中继器或集线器网络中，任何发送方和接收方最多只能经过4个中继器或集线器、5个网段</p>
<h2 id="数据链路层的功能"><a href="#数据链路层的功能" class="headerlink" title="数据链路层的功能"></a>数据链路层的功能</h2><p>避免帧的丢失数据链路层采用的方法是计时器超时重发</p>
<p>连接是建立在确认的基础之上</p>
<h2 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h2><p>字符计数法：在帧前面加入一个数字表示，该数字为后面跟的个数+1（自身）</p>
<p>字符填充，使用DLE STX来标识开始和结束，中间有DLE就在前面加一个DLE转义</p>
<p>比特填充：使用01111110做首位，在信息中每遇到5个1就在后面加一个0</p>
<h2 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h2><p>传输差错由噪声引起，可分为热噪声和冲击噪声。热噪声是信道固有的，引起的是随机差错，可以通过提高信噪比来降低它对数据传输的影响。冲击噪声由外界电磁干扰引起，引起的是突发差错，是引起传输差错的主要原因。</p>
<p>海明码：纠错d位，需要码距2d+1，检错d位，需要码距d+1</p>
<p>CRC校验通信双方要事先协定多项式编码</p>
<h2 id="流量控制与可靠传输机制"><a href="#流量控制与可靠传输机制" class="headerlink" title="流量控制与可靠传输机制"></a>流量控制与可靠传输机制</h2><p>后退N帧：当收到5号帧时，意味着4号帧也已经收到。</p>
<p>选择重传：哪个每收到确认重发哪个</p>
<p>后退N帧，序列号个数不小于发送窗口大小+1</p>
<p>选择重传：最大尺寸不超过序列号的一半</p>
<table>
<thead>
<tr>
<th>滑动窗口协议</th>
<th>发送窗口</th>
<th>接收窗口</th>
</tr>
</thead>
<tbody><tr>
<td>停止-等待协议</td>
<td>=1</td>
<td>=1</td>
</tr>
<tr>
<td>后退N帧协议</td>
<td>&gt;1</td>
<td>=1</td>
</tr>
<tr>
<td>选择重传协议</td>
<td>&gt;1</td>
<td>&gt;1</td>
</tr>
</tbody></table>
<p>选择重传：接收+发送&lt;=2^n</p>
<p>信道利用率=数据发送时延/(数据发送时延+传播时延)</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="处理机调度"><a href="#处理机调度" class="headerlink" title="处理机调度"></a>处理机调度</h2><p>周转时间=作业完成时间-作业提交时间</p>
<p>带权周转时间=作业的周转时间/系统为它提供服务的时间</p>
<p>I/O时间长的优先级大</p>
<p>响应比=（等待时间+要求服务时间）/要求服务时间</p>
<p>作业是从用户角度出发，进程是从操作系统的角度出发</p>
<p>抢占式短作业优先：若新就绪的比正在执行的剩余短，则抢占                 </p>
<p>短进程优先周转时间最短</p>
<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="算术逻辑单元"><a href="#算术逻辑单元" class="headerlink" title="算术逻辑单元"></a>算术逻辑单元</h2><p>并行加法器中本位不仅与参与运算的两个数值值位有关，还和低位送来的进位有关</p>
<p>ALU是组合逻辑电路</p>
<p>进位传递对并行器的影响最为关键</p>
<p> 加法器中：进位信号：g=xy，进位传递信号：p=x异或y</p>
<p>ALU既可以算术运算，也可以逻辑运算</p>
<p>加法器进位</p>
<p><img src="/2020/04/02/note4084/jinwei.png" alt="加法器进位"></p>
<h2 id="存储器的层次结构"><a href="#存储器的层次结构" class="headerlink" title="存储器的层次结构"></a>存储器的层次结构</h2><p>CD-ROM光盘，是串行存储，访问是顺序的，是直接存取存储器DAM</p>
<p>存取周期指连续两次存取之间的间隔</p>
<p>内存储器包括RAM和ROM</p>
<h2 id="存储器的层次化结构"><a href="#存储器的层次化结构" class="headerlink" title="存储器的层次化结构"></a>存储器的层次化结构</h2><p>速度：寄存器&gt;Cache&gt;主存&gt;辅存</p>
<p>CPU与主存可直接交换信息</p>
<p>主存辅存之间的数据调动由操作系统完成，仅对应用级程序员透明</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>408</tag>
      </tags>
  </entry>
  <entry>
    <title>408刷题笔记3</title>
    <url>/2020/04/01/note4083/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h2><p>信道不等于电路，一条可通信的电路可能包含多个信道</p>
<p>调制：数字-&gt;模拟</p>
<p>解调：模拟-&gt;数字</p>
<p>模拟：频带传输</p>
<p>数字：基带传输</p>
<table>
<thead>
<tr>
<th>方式</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>模拟信号传输模拟数据</td>
<td></td>
</tr>
<tr>
<td>模拟信号传输数字数据</td>
<td>QAM</td>
</tr>
<tr>
<td>数字信号传输模拟数据</td>
<td>脉冲编码调制PCM</td>
</tr>
<tr>
<td>数字信号传输数字数据</td>
<td>曼彻斯特、差分曼彻斯特</td>
</tr>
</tbody></table>
<p>波特率（信号每秒变化的次数）=比特率/每码元含的比特数，即（log2 n，n为码元的有效值，此处为2）</p>
<p>数据率=波特率/n，n表示一位数据需要几个电平表示，此处为2，曼彻斯特为4，4B/5B为4个需要5个，为4/5</p>
<p>每码元所含比特数=传输速率/波特率</p>
<p>离散值的个数=2^每码元所含比特数</p>
<p>奈奎斯特：最大传输速率=2Wlog2V b/s,W表示带宽，采样频率、Baud=2W，V表示离散值个数</p>
<p>香农：Wlog2（1+S/N） b/s，S信道所传输信号的平均功率，N为信道高噪声功率，S/N为信噪比。其中dB=10log10（S/N）</p>
<p>奈奎斯特与香农两者相比取小的值</p>
<p>码元传输速率（码元速率、波形速率）：单位时间内数字通信系统所传输的码元（脉冲个数或信号变化的次数）个数</p>
<p>信息传输速率（信息速率、比特率）：单位时间内数字通信系统所传输的二进制码元（比特数）个数</p>
<p>香农定理：影响信道最大传输速率的因素：信道的带宽和噪声比</p>
<p>并行传输：距离短、速度快，适合计算机内部</p>
<p>串行传输：距离长、速度慢</p>
<p>曼彻斯特编码将时钟信号与数据信号都包含着信号中，并可以传输给对方，中间采用向上向下跳变区分0和1。适合二进制信号传输。占用的频带宽度是原始基带宽带的两倍。</p>
<p>声音是模拟信号</p>
<p>报文大小不固定，交换需要较大的存储空间，接收存储转发的时间不固定，所以不能应用于实时通信环境，如语音视频</p>
<p>以太网采用的是分组交互</p>
<table>
<thead>
<tr>
<th>交换技术</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>分组交换</td>
<td>将报文分割，减小了传输时延。传输单位相比报文更小，有固定的长度。分为数据报（无连接）较可靠，虚电路（连接），虚电路包括永久性和临时性。一条线子可以有多条虚电路</td>
</tr>
<tr>
<td>报文交换</td>
<td>不固定且较长</td>
</tr>
<tr>
<td>电路交换</td>
<td>面向连接，建立时有时延，传输时实时性，不提供差错检测功能</td>
</tr>
</tbody></table>
<p>NRZ 低电平0，高电平1</p>
<p>NRZI与前一个一样0，不一样1</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程映像是：PCB、程序段和数据的组合，其中PCB是进程存在的唯一标志</p>
<p>操作系统通过PCB对进程进行控制，PCB包含基本状态和优先权</p>
<p>线程是处理机调度的基本单位可以独立执行程序，但没有自己独立的地址空间，可以通过他们的共享存储空间进行通信。</p>
<p>进程之间的地址是私有的只能自己访问</p>
<p>进程重要的特性是动态性</p>
<p>封闭性：执行结果只取决于自身</p>
<p>进程有生命周期，不会一直存在于系统之中，会因为结束或异常而撤销。</p>
<p>多对一的模型中，一个线程被阻塞则该进程被阻塞</p>
<table>
<thead>
<tr>
<th>C语言程序</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>代码和赋值数据段（正文段）</td>
<td>二进制代码和常量</td>
</tr>
<tr>
<td>数据堆段</td>
<td>动态分配的存储区</td>
</tr>
<tr>
<td>数据栈段</td>
<td>临时使用的变量</td>
</tr>
</tbody></table>
<p>全局变量与用户代码有关，与PCB无关</p>
<p>进程自身决定从运行状态到阻塞状态</p>
<p>I/O操作导致阻塞</p>
<p>进程间通信有管道、消息传递、共享内存、文件映射、套接字</p>
<p>进程可以创建进程或线程、线程只能创建线程</p>
<p>管道是一个固定大小的缓冲区，通常为内存的一页</p>
<p>多任务是针对于操作系统</p>
<p>多线程是针对于程序</p>
<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="定点数的表示与运算"><a href="#定点数的表示与运算" class="headerlink" title="定点数的表示与运算"></a>定点数的表示与运算</h2><p>补码表示最后要+1</p>
<p>1表示负号</p>
<p>int 32位 short 16位，8位1个字节</p>
<p>有符号转无符号，原来的补码就是现在的原码</p>
<table>
<thead>
<tr>
<th>0的表示</th>
<th>+</th>
<th>-</th>
</tr>
</thead>
<tbody><tr>
<td>原码</td>
<td>00000</td>
<td>10000</td>
</tr>
<tr>
<td>反码</td>
<td>00000</td>
<td>11111</td>
</tr>
<tr>
<td>补码</td>
<td>00000</td>
<td>00000</td>
</tr>
<tr>
<td>移码</td>
<td>10000</td>
<td>10000</td>
</tr>
</tbody></table>
<p>若x为正数，则原码、反码、补码相同</p>
<p>若x为负数，补码变原码，符号位不变，数值位取反，末尾+1</p>
<p>无论x是正数还是符数[x]求[-x]即连同符合每位取反末尾+1</p>
<p>n+1位定点小数反码范围：-1+2^(-n)&lt;=x&lt;=1-2^(-n)</p>
<p>n+1位定点小数原码范围：-2^(n)+1&lt;=x&lt;=2^(n)-1</p>
<p>补码移位，正数左右都添0，负数右1左0</p>
<p>原码移位左右补0</p>
<p>同一个数的补码和移码表示，数值相同，符号位相反</p>
<p>不带进位的位循环左移最高位进入最低位和标志寄存器</p>
<p>模4补码具有模2补码的全部优点且更容易检查加减运算中的溢出问题，存储时只需要一个符号位，在ALU中完成加减运算需要把每个符号位都送至ALU的双符号位中。</p>
<p>双符号位，第一位表示结果正0负 1，第二位表示是否溢出</p>
<p>加减法溢出，符号位C0最高位进位C1，异或为1表示溢出</p>
<p>*2左移，/2右移</p>
<p>补码范围-128~127</p>
<p>原码乘法符号位与数值位分开运算</p>
<p>补码一位乘法，需要移动n位，进行n+1次加法运算.原来的n位，右移n+1位，符号位，共2n+1位。</p>
<p>原码一位乘法，移动与加法运算均为n</p>
<p>原码不恢复余数除法即加减交替法，仅当最后一步不够减时，才恢复一次余数</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>408</tag>
      </tags>
  </entry>
  <entry>
    <title>408刷题笔记2</title>
    <url>/2020/03/31/note4082/</url>
    <content><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h2><p>计算机网络是由自治计算机互连起来的集合体，使计算机之间更加紧密联系。</p>
<p>计算机网络最基本的功能是数据通信，是其他功能的基础</p>
<p>计算机网络三大主要功能：数据通信、资源共享、分布式处理</p>
<p>计算机网络逻辑功能上分为：资源子网、通信子网</p>
<p>网络资源包括：硬件资源、软件资源和数据资源</p>
<p>城域网是较大范围内连接多个局域网的局域网，仍是以太网。</p>
<p>局域网与广域网之间除了范围，其协议也不同</p>
<p>局域网：广播技术，是在数据链路层和物理层</p>
<p>广域网：点对点、交换技术</p>
<p>分组交换：把数据分成多个大小相当的小数据片</p>
<p>发送时延=分组长度/信道宽带</p>
<p>传播时延=信道长度/传播速率</p>
<p>报文流：网络保持对报文边界追踪，接收到两个报文看成是两个</p>
<p>字节流：不保持追踪，接收到两个字节流看成一个整体</p>
<h2 id="计算机网络体系结构与参考模型"><a href="#计算机网络体系结构与参考模型" class="headerlink" title="计算机网络体系结构与参考模型"></a>计算机网络体系结构与参考模型</h2><p>协议是指不同结点对等实体之间进行通信的规则或约定，协议达成可以向上一层提供服务，也需要下一层提供服务。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>方向</th>
<th>透明性</th>
</tr>
</thead>
<tbody><tr>
<td>协议</td>
<td>水平</td>
<td>看不见下一层的协议</td>
</tr>
<tr>
<td>服务</td>
<td>垂直</td>
<td>可以看见下一层的服务</td>
</tr>
</tbody></table>
<p>OSI三个主要概念：服务、接口、协议</p>
<p>传输层和网络层才有拥塞控制的功能</p>
<p>传输层以上是端到端的通信（端口号）</p>
<table>
<thead>
<tr>
<th>模型</th>
<th>网络层</th>
<th>传输层</th>
</tr>
</thead>
<tbody><tr>
<td>OSI</td>
<td>无连接和面向连接</td>
<td>面向连接</td>
</tr>
<tr>
<td>TCP/IP</td>
<td>无连接</td>
<td>无连接和面向连接</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>OSI层</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td></td>
</tr>
<tr>
<td>表示层</td>
<td>数据的解密加密、压缩、格式转换</td>
</tr>
<tr>
<td>会话层</td>
<td>会话管理和同步，信号中断恢复后可继续接着传</td>
</tr>
<tr>
<td>传输层</td>
<td>应答、分组排序、流量控制，增加相应端口信息</td>
</tr>
<tr>
<td>网络层</td>
<td>控制信息和IP地址</td>
</tr>
<tr>
<td>数据链路层</td>
<td>物理寻址、流量控制、差错检测，控制信息和MAC地址</td>
</tr>
<tr>
<td>物理层</td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>TCP/IP</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td></td>
</tr>
<tr>
<td>传输层</td>
<td>差错检测，流量控制</td>
</tr>
<tr>
<td>网际层</td>
<td>无连接不可靠数据报服务</td>
</tr>
<tr>
<td>网络接口层</td>
<td></td>
</tr>
</tbody></table>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="操作系统的基本概念"><a href="#操作系统的基本概念" class="headerlink" title="操作系统的基本概念"></a>操作系统的基本概念</h2><p>现代操作系统最基本的两个特征：并发和共享</p>
<p>并发性：若干事件在同一时间间隔内发生</p>
<p>并行性：若干事件在同一时刻发生</p>
<p>操作系统接口：命令接口、系统调用</p>
<p>命令接口：联机用户接口、脱机用户接口</p>
<p>系统调用：也称程序接口，操作系统提供给应用程序的接口，只能通过用户程序间接使用。系统调用命令也称广义指令。</p>
<p>计算机开机后程序最终被加载到内存的系统区，是一个RAM</p>
<p>库函数有时会使用系统调用来实现功能，但不完全只使用系统调用。</p>
<h2 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h2><p>实时操作系统必须在被控制对象规定时间内来处理来自外部的事件。采用抢占式的优先级高者优先以便可以及时的处理某些紧急事件。</p>
<p>实时操作系统两个重要目标：实时性和可靠性，允许浪费某些资源。</p>
<p>优先级+非抢占式调度算法可以改善系统的响应时间，保证重要的事件优先执行，次要的事件也能得到响应</p>
<p>分时操作系统：时间片轮转，要求快速响应多个用户</p>
<p>批处理系统：用户脱机使用、成批处理、多道程序并发执行，交互能力差</p>
<p>分时操作系统：多个用户同时独立使用计算机、人机交互性强、响应及时</p>
<p>实时操作系统：反应快，可靠性强，资源利用率低</p>
<h2 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h2><p>输入输出需要中断，中断是在核心态下执行的</p>
<p>系统调用需要触发trap陷入指令</p>
<p>中断处理是操作系统必须提供的功能，各种错误处理需要中断，核心态和用户态切换也需要中断处理</p>
<p>进入中断处理的程序是核心态的，只能属于操作系统程序</p>
<p>核心态-&gt;用户态：操作系统完成，由中断返回到用户程序时</p>
<p>用户态-&gt;核心态：硬件完成，发生中断时，外部中断</p>
<p>进程切换属于系统调用执行过程中的事件，只能发生在核心态</p>
<p>广义指令的调用可以发生在用户态，但其执行一定处于核心态</p>
<p>输入输出涉及到中断，所以必须放到核心态下执行</p>
<p>中断处理重要的两个寄存器：PC(程序计数器)、PSWR(程序状态字寄存器)。子程序只保护PC，中断处理，保护两个。</p>
<p>中断：指CPU执行指令以外的事情发生。PC内容由中断隐指令保存、通用寄存器内容由操作系统保存。</p>
<p>异常：也称内中断、例外或陷入，指CPU执行指令内部的事件</p>
<p>通道技术使得I/O独立于CPU，使得输入与输出可以与CPU并行。</p>
<p>中断技术指I/O结束后，可以中断CPU执行其他程序。</p>
<p>多道程序指I/O与CPU在执行时间上可以并行。</p>
<h2 id="操作系统的体系结构"><a href="#操作系统的体系结构" class="headerlink" title="操作系统的体系结构"></a>操作系统的体系结构</h2><p>微内核将内核与系统服务分离出来，使得服务之间使用进程机制进行通信。传统的是都在内核中。</p>
<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><h2 id="计算机的性能指标"><a href="#计算机的性能指标" class="headerlink" title="计算机的性能指标"></a>计算机的性能指标</h2><p>CPU时钟频率越高完成指令的一个执行步骤所用的时间就越短</p>
<table>
<thead>
<tr>
<th>指标</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>MIPS</td>
<td>每秒执行多少百万条指令，衡量标准机的性能，主频/CPI</td>
</tr>
<tr>
<td>CPI</td>
<td>平均每条指令的时钟周期数</td>
</tr>
<tr>
<td>IPC</td>
<td>每个时钟周期执行的指令数</td>
</tr>
<tr>
<td>MFLOPS</td>
<td>每秒执行多少百万条浮点数运算，衡量向量机的性能</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>字长</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>机器字长</td>
<td>计算机的位数，CPU一次能处理数据的位数，通常与CPU的寄存器位数有关，是数据运算的基本单位长度</td>
</tr>
<tr>
<td>指令字长</td>
<td>计算机指令字的位数</td>
</tr>
<tr>
<td>存储字长</td>
<td>二进制代码的位数==MDR的位数</td>
</tr>
<tr>
<td>数据字长</td>
<td>数据总线一次能并行传送信息的位数，可以不等于MDR</td>
</tr>
</tbody></table>
<p>机器字长、指令字长、存储字长三者可以相等可以不等</p>
<p>寄存器由触发器构成</p>
<p>状态寄存器、通用寄存器、PC可以由汇编设置，指令寄存器完全透明。</p>
<p>兼容指计算机软件或硬件的通用性，通常在同一系列不同型号的计算机间通用。</p>
<p>64K×32位：地址总线宽度16位，数据总线宽带为32位，所以MAR为16位，PC为16位，MDR为32位。又指令字长=存储字长=机器字长，则IR、ACC、MQ、X均为32位</p>
<p>CPU时钟周期：1/HZ</p>
<p>程序执行时间：CPI×（1/MHZ）×I</p>
<p>平均指令周期：1/MIPS</p>
<p>平均执行速度：平均指令周期/CPU时钟周期</p>
<h2 id="数制与编码"><a href="#数制与编码" class="headerlink" title="数制与编码"></a>数制与编码</h2><p>8421BCD码每4位对应一个十进制，其中1010—1111不能使用，因为十进制没得这几个数</p>
<p>十进制转为其他进制：整数部分%进制，余数逆序输出，商继续除。小数部分乘以进制，整数部分输出，小数部分继续乘。</p>
<p>低进制不能表示高进制的小数部分，如二进制不能表示十进制的小数，因为二进制只能有：1/2，1/4，1/8…</p>
<p>ASCII码由7位表示，最高位保持为0</p>
<p>小端存储，第一个存地位最小的两个数，如01234567H，存67H</p>
<p>码距&gt;=2的数据校验码具有检错能力，码距越大，检错能力越强。</p>
<p>汉明码码距&gt;2，可以检测出一位数据错误并指出位置,可以发现两位错误，并纠正1位</p>
<p>奇偶校验码距=2，可以检测出一位数据错误或奇数位错误，不能指出距离，也不能检测出偶数位错误。奇校验当为奇数个1则正确，偶校验为偶数个1则正确。</p>
<p>CRC通过除法运算建立数据和校验位之间的约定关系，检查出错误后可以请求重发、删除数据、通过余数值自行纠正。适合大量数据。</p>
<p>汉明码纠正1位检验位数为k，2^k&gt;=n+k+1。纠正2位，2^(k-1)&gt;=n+k+1</p>
<p>CRC码中，要求数字长度不变，余数与CRC码出错位的对应关系不变，将接收到的CRC码与多项式相除，为0则对，不为0则有错误，多项式选取合理的话可以判断出错位。</p>
<p>海明码计算：</p>
<p>数据为1010，长度n=4，则根据2^k&gt;=n+k+1，求得k=3，得到一个长n+k=7的表。</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>其中2^n位设为P(n+1),其余位子依次填入数据</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>P2</td>
<td>1</td>
<td>P3</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p>有二进制表头</p>
<table>
<thead>
<tr>
<th>001</th>
<th>010</th>
<th>011</th>
<th>100</th>
<th>101</th>
<th>110</th>
<th>111</th>
</tr>
</thead>
<tbody><tr>
<td>P1</td>
<td>P2</td>
<td>1</td>
<td>P3</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<p>找出P表数字1的位置剩余表头数字该位置也是1的，并将对应数据拼合。</p>
<p>P1(001) -&gt; M3(011)M5(101)M7(111)-&gt;100，奇0偶1</p>
<p>P2(010)-&gt;M3(011)M6(110)M7(111)-&gt;110，奇1偶0</p>
<p>P3(100)-&gt;M5(101)M6(110)M7(111)-&gt;010，奇0偶1</p>
<p>根据奇偶校验有</p>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
</tr>
</thead>
<tbody><tr>
<td>奇</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>偶</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>1</td>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
</tbody></table>
<hr>
<p>或Pn采用异或的方式，全校验位即多加一个位子，当Pn有偶数个1时，则为0，奇数个1时则为1.</p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>408</tag>
      </tags>
  </entry>
  <entry>
    <title>408刷题笔记1</title>
    <url>/2020/03/30/note4081/</url>
    <content><![CDATA[<h1 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h1><p>计算机变化：电子管-&gt;晶体管-&gt;中小规模集成电路-&gt;超大规模集成电路</p>
<p>微型计算机的发展以微处理器技术为标志</p>
<p>机器语言是计算机唯一可以执行的语言</p>
<p>汇编语言采用助记符编写程序–&gt;助记符（mnemonic）是便于人们记忆、并能描述指令功能和指令操作数的符号，助记符是表明指令功能的英语单词或其缩写。</p>
<p>边翻译成机器语言边执行–&gt;解释型语言，不会产生目标代码文件</p>
<p>全部翻译成机器语言再执行–&gt;编译性语言，产生目标代码文件</p>
<p><img src="/2020/03/30/note4081/cbianyi.png" alt="c编译过程"></p>
<p>高级语言-&gt;汇编语言：编译</p>
<p>汇编语言-&gt;机器语言：汇编</p>
<p>使用二进制主要对应逻辑电路里的高电平和低电平，这是由物理器件的性能决定。</p>
<p>完整的计算机系统包括配套的硬件设备和软件设备</p>
<p>硬件设备包括外部设备和主机</p>
<p>主机包括运算器、存储器和控制器</p>
<p><img src="/2020/03/30/note4081/fengnuoyiman.png" alt="冯诺依曼计算机"></p>
<p>冯诺依曼计算机以<strong>运算器</strong>为中心，是单处理机，根本的特征采用<strong>存储程序</strong>原理，基本工作方式是<strong>控制流驱动</strong>方式。</p>
<p>指令和数据都存在存储器中，冯诺依曼计算机中CPU区分指令和数据的方式是依据指令周期的不同阶段，在取指阶段取的是指令，执行阶段取的是数据。只有CPU确定是指令时才送去译码。</p>
<p><img src="/2020/03/30/note4081/xiandaijisuanji.png" alt="现代计算机"></p>
<p>软硬件实现逻辑上等效不等价，软件灵活、硬件高效。</p>
<p><img src="/2020/03/30/note4081/jisuajineibutu.png" alt="计算机组成框图"></p>
<table>
<thead>
<tr>
<th>术语</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>ALU(Arithmetic logic unit)</td>
<td>算术逻辑单元</td>
</tr>
<tr>
<td>ACC(Accumulation register)</td>
<td>累加器</td>
</tr>
<tr>
<td>MQ(Multiplier-Quotient Register)</td>
<td>乘商寄存器</td>
</tr>
<tr>
<td>X</td>
<td>操作数寄存器</td>
</tr>
<tr>
<td>IX</td>
<td>变址寄存器，*运算器中未显示，可不必有</td>
</tr>
<tr>
<td>BR(Buffer Register)</td>
<td>数据缓冲器：基址寄存器，*运算器中未显示，可不必有</td>
</tr>
<tr>
<td>CU</td>
<td>控制单元</td>
</tr>
<tr>
<td>IR(Instruction Register)</td>
<td>指令寄存器：存放当前欲执行的指令</td>
</tr>
<tr>
<td>PC(Program Counter)</td>
<td>程序计数器：存放下一条指令的地址</td>
</tr>
<tr>
<td>MDR(Data Register)</td>
<td>数据寄存器：存放从存储单元取来的数据</td>
</tr>
<tr>
<td>MAR(Address Register)</td>
<td>地址寄存器：存放欲访问的存储单元地址</td>
</tr>
<tr>
<td>Ad(Address)</td>
<td>形式地址</td>
</tr>
<tr>
<td>ID(Instruction Decoder)</td>
<td>指令译码器</td>
</tr>
<tr>
<td>AD(Address Decoder)</td>
<td>地址译码器，一般属于主存</td>
</tr>
</tbody></table>
<p><img src="/2020/03/30/note4081/cunchuti.png" alt="存储体"></p>
<p>现代计算机中MAR和MDR集成到CPU中</p>
<p>MAR-&gt;地址码长度，2^n</p>
<p>MDR-&gt;存储字长，一次可以处理的数据</p>
<p><img src="/2020/03/30/note4081/yunsuanqi.png" alt="运算器"></p>
<p><img src="/2020/03/30/note4081/kongzhiqi.png" alt="控制器"></p>
<p>过程：</p>
<ul>
<li>把程序和数据装入主存储器</li>
<li>从程序的起始地址运行程序</li>
<li>用程序的首地址从存储器中取出第一条指令，各部件协作执行指令，计算下一条指令地址</li>
<li>用新的指令地址读第二条指令</li>
</ul>
<p>取数据的例子：</p>
<ul>
<li>取指令：PC-&gt;MAR-&gt;M-&gt;MDR-&gt;IR</li>
<li>分析指令：OP(IR)-&gt;CU</li>
<li>执行指令(取数据)：Ad(IR)-&gt;MAR-&gt;M-&gt;MDR-&gt;ACC</li>
<li>计算下一条指令：PC+1-&gt;PC</li>
</ul>
<p>CPU存取速度：寄存器&gt;Cache(SRAM制造)&gt;内存(DRAM制造)</p>
<p>数据库系统=数据库+数据库管理系统（系统程序）+应用系统+管理员</p>
<p>相联存储器既可以按地址寻址也可以按内容寻址（通常是某些字段）</p>
<p>存储程序原理：将指令以代码的形式实现输入的主存储器中，然后按其在存储器中的首地址执行第一条指令，之后按照顺序执行，直至结束。</p>
<p>计算机功能：数据传送功能、数据存储功能、数据处理功能、操作控制功能、操作判断功能。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/low5252/article/details/104406148" target="_blank" rel="noopener">CSDN-水无垠</a></p>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>408</tag>
      </tags>
  </entry>
  <entry>
    <title>01背包问题</title>
    <url>/2020/03/25/01KnapsackProblem/</url>
    <content><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>给定 5块石头和一个承重为 15的背包，石头i的重量是 weight，其价值为 value 。</p>
<h1 id="怎么装使得背包里物品的总价值最大"><a href="#怎么装使得背包里物品的总价值最大" class="headerlink" title="怎么装使得背包里物品的总价值最大"></a>怎么装使得背包里物品的总价值最大</h1><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> weight[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">6</span>&#125;;<span class="comment">//0表示占位，从1开始</span></span><br><span class="line">	<span class="keyword">int</span> value[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">12</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">3</span>,<span class="number">6</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> a[<span class="number">6</span>][<span class="number">16</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">15</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(weight[i]&gt;j)&#123;</span><br><span class="line">				a[i][j]=a[i<span class="number">-1</span>][j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				a[i][j]=<span class="built_in">max</span>(a[i<span class="number">-1</span>][j],a[i<span class="number">-1</span>][j-weight[i]]+value[i]);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"最大价值为"</span>&lt;&lt;a[<span class="number">5</span>][<span class="number">15</span>];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><p>我们有五个石头，其重量和价值如下</p>
<table>
<thead>
<tr>
<th></th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
</tr>
</thead>
<tbody><tr>
<td>重量</td>
<td>5</td>
<td>4</td>
<td>7</td>
<td>2</td>
<td>6</td>
</tr>
<tr>
<td>价值</td>
<td>12</td>
<td>3</td>
<td>10</td>
<td>3</td>
<td>6</td>
</tr>
</tbody></table>
<p>我们设定一个数组a，用它来记录背包容量从0-15时背包内可获得的物品最大价值.</p>
<p>其中</p>
<p>行表示物品的编号</p>
<p>列表示背包的可承受重量</p>
<p>第0行置为0，用来做第一个物品的基础计算值</p>
<p>第0列置为0，用来表示背包承重量为0时，物品最大价值为0</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>这样我们从第一个石头算起，其重量为5，价值为12</p>
<p>背包承重量依次增加，直到背包承重量为5时，方可放入第一个石头，其物品最大价值为12。</p>
<p>由于此时只看第一个石头，故后面均为12。</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>12</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>5</td>
<td>0</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>接着我们看第二个石头，其重量为4，价值为3</p>
<p>背包承重量从0增长，当背包承重量增长为4时可以放下.</p>
<p>当背包重量为5时，我们比较不放入和放入第二块石头的情况。</p>
<p>如果不放入那么价值就是和上一块保持一致，即总价值a{i}{j}=a{i-1}{j}。//markdown语法问题，用{代替[</p>
<p>如果放入那么就要留有足够的空间放入第二块石头，则此时背包剩余容量为j-weight{i}，背包剩余价值为a{i-1}{j-weight{i}}，总价值a{i}{j}=a{i-1}{j-weight{i}}+value{i}。</p>
<p>比较这两种情况取最大值填入表中。</p>
<p>以此类推第三块石头，第四块石头，第五块石头得到下表。</p>
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
<th>11</th>
<th>12</th>
<th>13</th>
<th>14</th>
<th>15</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>12</td>
</tr>
<tr>
<td>2</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>15</td>
<td>15</td>
<td>15</td>
<td>15</td>
<td>15</td>
<td>15</td>
<td>15</td>
</tr>
<tr>
<td>3</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>12</td>
<td>15</td>
<td>15</td>
<td>15</td>
<td>22</td>
<td>22</td>
<td>22</td>
<td>22</td>
</tr>
<tr>
<td>4</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>12</td>
<td>12</td>
<td>15</td>
<td>15</td>
<td>15</td>
<td>15</td>
<td>18</td>
<td>22</td>
<td>22</td>
<td>25</td>
<td>25</td>
</tr>
<tr>
<td>5</td>
<td>0</td>
<td>0</td>
<td>3</td>
<td>3</td>
<td>3</td>
<td>12</td>
<td>12</td>
<td>15</td>
<td>15</td>
<td>15</td>
<td>15</td>
<td>18</td>
<td>22</td>
<td>22</td>
<td>25</td>
<td>25</td>
</tr>
</tbody></table>
<p>则最大价值就为a{5}{15},即25。</p>
<h1 id="应该装哪几块石头"><a href="#应该装哪几块石头" class="headerlink" title="应该装哪几块石头"></a>应该装哪几块石头</h1><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stone</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> flag=<span class="number">15</span>;</span><br><span class="line">	<span class="keyword">int</span> isstone[<span class="number">6</span>]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">5</span>;i&gt;=<span class="number">1</span>;i--)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i][flag]==a[i<span class="number">-1</span>][flag])isstone[i]=<span class="number">0</span>;</span><br><span class="line">		<span class="keyword">else</span>&#123;</span><br><span class="line">			flag-=weight[i];</span><br><span class="line">			isstone[i]=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">cout</span>&lt;&lt;<span class="string">"为1的是放进去的石头"</span>&lt;&lt;isstone[i]&lt;&lt;<span class="string">" "</span>; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h2><p>从最后一个石头开始判断，flag记录当前背包没有确定石头的承重量，初始值为背包承重量。</p>
<p>如果a{i}{j}和a{i-1}{j}相等，说明第i块石头没有影响背包的价值变动，所以没有放进去，继续判断前一个石头。</p>
<p>如果a{i}{j}和a{i-1}{j}不相等，说明第i块石头影响了背包价值变动，所以放了进去，flag减去该石头的重量。在已经减去上一个已判断石头重量的基础上，继续判断前一个石头是否放进背包。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KnapsackProblem</tag>
      </tags>
  </entry>
  <entry>
    <title>设备管理</title>
    <url>/2020/03/16/osDeviceManager/</url>
    <content><![CDATA[<p>对计算机系统内所有设备实施有效管理</p>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ul>
<li>设备分配</li>
<li>设备传输控制</li>
<li>设备独立</li>
</ul>
<h1 id="I-O管理"><a href="#I-O管理" class="headerlink" title="I/O管理"></a>I/O管理</h1><table>
<thead>
<tr>
<th>I/O设备分类</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>按设备的使用特性分类</td>
<td>存储设备、人机交互设备(输入输出设备)、网络通信设备(网络接口、调制解调器)</td>
</tr>
<tr>
<td>按信息交换单位分类</td>
<td>字符设备(键盘、显示器)、块设备(磁盘)</td>
</tr>
<tr>
<td>按传输速率分类</td>
<td>低速设备(键盘、鼠标)、中速设备(打印机)、高速设备(磁带机、磁盘)</td>
</tr>
<tr>
<td>按设备共享属性分类</td>
<td>独占设备、共享设备、虚拟设备</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>I/O设备功能</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>设备分配</td>
<td>将I/O设备分配给哪个进程</td>
</tr>
<tr>
<td>设备处理</td>
<td>启动I/O操作，处理I/O的中断请求</td>
</tr>
<tr>
<td>缓冲管理</td>
<td>缓和CUP与I/O速度不匹配问题</td>
</tr>
<tr>
<td>设备独立性</td>
<td>应用程序独立于物理设备</td>
</tr>
</tbody></table>
<h2 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h2><p>当只有一个I/O时，它只有一个设备地址。当它控制多个I/O时，具有多个设备地址。</p>
<p>功能</p>
<ul>
<li>接收识别CPU的各种指令</li>
<li>实现CPU与设备控制器、设备控制器与设备之间的数据交换</li>
<li>记录设备的状态供CPU查询</li>
<li>识别所控制的每个设备的地址</li>
<li>对CPU输出的数据或设备向CPU输入的数据进行缓冲</li>
<li>对输入\输出数据进行差错控制</li>
</ul>
<h2 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h2><h3 id="程序直接控制方式"><a href="#程序直接控制方式" class="headerlink" title="程序直接控制方式"></a>程序直接控制方式</h3><p>CPU与I/O通信，需要不断测试I/O设备，利用率低，简单</p>
<h3 id="中断控制方式"><a href="#中断控制方式" class="headerlink" title="中断控制方式"></a>中断控制方式</h3><p>输入完成，向CPU发送中断信号，CPU执行中断处理程序，提高了CPU利用率，中断次数多，耗费大量CPU处理时间。</p>
<ul>
<li>唤醒被阻塞的驱动进程：signal操作</li>
<li>保护被中断进程的CPU环境：将处理器状态字PSW和程序计数器PC压入栈中加以保存，CPU寄存器也压入栈中</li>
<li>转入想要的设备处理程序</li>
<li>中断处理</li>
<li>恢复被中断进程的现场</li>
</ul>
<h3 id="DMA控制方式"><a href="#DMA控制方式" class="headerlink" title="DMA控制方式"></a>DMA控制方式</h3><ul>
<li>数据传输的基本单位是数据块</li>
<li>数据是单向传输</li>
<li>仅在传送一个或多个数据块的开始和结束时才需要CPU干预，传送一批数据后才中断CPU</li>
<li>组成：<ul>
<li>命令/状态寄存器（CR）接收从CPU发来的I/O命令或有关控制信息</li>
<li>内存地址寄存器（MAR）用于存放数据从设备传送到内存或从内存到设备的内存地址</li>
<li>数据寄存器（DR）用于暂存从设备到内存或从内存到设备的数据</li>
<li>数据计数器（DC）存放本次要传送的字数</li>
</ul>
</li>
<li>优点：与CPU并行</li>
<li>缺点：起始地址，传送数据长度等都由CPU控制，每台设备需要DMA控制器，设备增加，不经济</li>
</ul>
<h3 id="通道控制方式"><a href="#通道控制方式" class="headerlink" title="通道控制方式"></a>通道控制方式</h3><ul>
<li>起始地址，传送数据长度等都由通道管理，一个通道可以控制多台设备</li>
<li>字节多路通道：以字节为单位，交叉轮流为多个设备服务</li>
<li>数组选择通道：可以连接多台高速设备，只含有一个分配型子通道，利用率低</li>
<li>数组多路通道：广泛连接中高低速设备，含有多个非分配型子通道</li>
<li>优点：可以与CPU并行</li>
<li>缺点：成本高</li>
</ul>
<h2 id="软件层次结构"><a href="#软件层次结构" class="headerlink" title="软件层次结构"></a>软件层次结构</h2><ul>
<li>硬件</li>
<li>中断处理程序<ul>
<li>见上面中断控制方式</li>
</ul>
</li>
<li>设备驱动程序<ul>
<li>将参数要求转化为具体要求</li>
<li>检查I/O的合法性</li>
<li>读出和检查设备的状态</li>
<li>传送必要参数</li>
<li>设置必要方式</li>
<li>启动I/O设备</li>
</ul>
</li>
<li>设备独立性软件<ul>
<li>向用户空间软件提供统一的接口</li>
</ul>
</li>
<li>用户层软件</li>
</ul>
<h1 id="高速缓存与缓冲区"><a href="#高速缓存与缓冲区" class="headerlink" title="高速缓存与缓冲区"></a>高速缓存与缓冲区</h1><p>配合CPU的速度</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>单缓冲：等待上一行输出完毕才能继续输出</p>
<p>双缓冲：前一个数据可以装入另一个缓冲区，两个轮换使用</p>
<p>循环缓冲：最后一个缓冲区指向第一个缓冲区构成循环，当需要数据是从缓冲区取出一个装满数据的缓冲区</p>
<p>缓冲池</p>
<ul>
<li>共多个队列共享，既可以输入也可以输出</li>
<li>三种状态<ul>
<li>空缓冲队列</li>
<li>装满输入数据的缓冲队列</li>
<li>装满输出数据的缓冲队列</li>
</ul>
</li>
<li>四个工作缓冲区<ul>
<li>收容输入数据的工作缓冲区</li>
<li>提取输入数据的工作缓冲区</li>
<li>收容输出数据的工作缓冲区</li>
<li>提取输出数据的工作缓冲区</li>
</ul>
</li>
</ul>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>存放数据不同：高速缓存存放低速设备的一个备份，缓冲区则存放低速到高速的一个数据</li>
<li>目的不同：高速缓存存放经常使用的数据，缓冲区解决速度不匹配</li>
</ul>
<h1 id="设备分配与回收"><a href="#设备分配与回收" class="headerlink" title="设备分配与回收"></a>设备分配与回收</h1><h2 id="设备管理中的数据结构"><a href="#设备管理中的数据结构" class="headerlink" title="设备管理中的数据结构"></a>设备管理中的数据结构</h2><ul>
<li>设备控制表DCT：用来指示设备当前状态</li>
<li>设备控制器控制表COCT：反应设备控制器的使用状态</li>
<li>通道控制表CHCT：反应通道的状态</li>
<li>系统设备表SDT：已连接到系统中的所有物理设备</li>
</ul>
<h2 id="设备分配策略"><a href="#设备分配策略" class="headerlink" title="设备分配策略"></a>设备分配策略</h2><ul>
<li>设备的使用性质<ul>
<li>独享设备</li>
<li>共享分配</li>
<li>虚拟分配：针对虚拟设备</li>
</ul>
</li>
<li>设备分配算法<ul>
<li>先来先服务</li>
<li>优先级高者优先</li>
</ul>
</li>
<li>设备分配的安全性<ul>
<li>保证不发生死锁</li>
<li>静态分配：在作业开始前就一次性分配好</li>
<li>动态分配：根据需要进行设备分配</li>
</ul>
</li>
</ul>
<h2 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h2><ul>
<li>指应用程序独立于具体使用的物理设备</li>
<li>通过逻辑设备表来对应逻辑设备和物理设备</li>
</ul>
<h2 id="设备分配程序"><a href="#设备分配程序" class="headerlink" title="设备分配程序"></a>设备分配程序</h2><ul>
<li>单通路I/O系统的设备分配：分配设备-&gt;分配设备控制器-&gt;分配通道</li>
<li>多通路I/O系统的设备分配：一个设备与多个设备控制器相连，设备控制器也与多个通道相连<ul>
<li>根据设备类型检索系统控制表，找到第一个空闲设备，并检测分配的安全性</li>
<li>设备分配后设备控制表，找到第一个与已分配设备相连的空闲设备控制器，若无则返回上面，查找下一个空闲设备</li>
<li>同样方法查找通道，三个都空闲，就启动I/O设备传输信息</li>
</ul>
</li>
</ul>
<h2 id="设备的回收"><a href="#设备的回收" class="headerlink" title="设备的回收"></a>设备的回收</h2><h1 id="SPOOLing假脱机技术"><a href="#SPOOLing假脱机技术" class="headerlink" title="SPOOLing假脱机技术"></a>SPOOLing假脱机技术</h1><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>输入井和输出井</li>
<li>输入缓冲区和输出缓冲区</li>
<li>输入进程和输出进程</li>
</ul>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>提高了I/O速度</li>
<li>设备并没有分配给任何进程</li>
<li>实现虚拟设备功能：设备是逻辑上的设备</li>
<li>既是一种速度匹配技术，也是一种虚拟设备技术</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤操作系统</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>deviceManager</tag>
      </tags>
  </entry>
  <entry>
    <title>文件管理</title>
    <url>/2020/03/16/osFileManager/</url>
    <content><![CDATA[<p>负责信息管理，有效支持文件存储、检索和修改，解决文件共享、保密和保护问题</p>
<p>功能：目录管理、文件操作管理、文件保护</p>
<h1 id="文件的概念"><a href="#文件的概念" class="headerlink" title="文件的概念"></a>文件的概念</h1><p>具有文件名的一组相关元素集合，在文件系统中是一个最大的数据单位</p>
<table>
<thead>
<tr>
<th>组成</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>数据项</td>
<td>描述某一属性的值</td>
</tr>
<tr>
<td>记录</td>
<td>属性</td>
</tr>
<tr>
<td>文件</td>
<td>一组相关信息的集合</td>
</tr>
</tbody></table>
<p>属性：名称、标识符、文件类型、文件位置、文件大小、建立时间、用户标识。</p>
<h2 id="文件分类"><a href="#文件分类" class="headerlink" title="文件分类"></a>文件分类</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>按用途</td>
<td>系统文件、库文件、用户文件</td>
</tr>
<tr>
<td>按保护级别</td>
<td>只读文件、读写文件、执行文件、不保护文件</td>
</tr>
<tr>
<td>按信息流向分类</td>
<td>输入文件、输出文件、输入输出文件</td>
</tr>
<tr>
<td>按数据形式分类</td>
<td>源文件、目标文件(二进制文件)、可执行文件</td>
</tr>
</tbody></table>
<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><ul>
<li>创建文件</li>
<li>删除文件</li>
<li>读文件</li>
<li>写文件</li>
<li>截断文件</li>
<li>设置文件的读写位置</li>
</ul>
<h2 id="文件打开关闭操作"><a href="#文件打开关闭操作" class="headerlink" title="文件打开关闭操作"></a>文件打开关闭操作</h2><ul>
<li>打开文件<ul>
<li>文件指针</li>
<li>文件打开计数（多个进程可能会同时打开文件）</li>
<li>文件磁盘位置</li>
<li>访问权限</li>
</ul>
</li>
<li>关闭文件</li>
</ul>
<h2 id="文件的结构"><a href="#文件的结构" class="headerlink" title="文件的结构"></a>文件的结构</h2><h3 id="文件的逻辑结构"><a href="#文件的逻辑结构" class="headerlink" title="文件的逻辑结构"></a>文件的逻辑结构</h3><p>无结构的流式文件</p>
<p>有结构的记录式文件</p>
<ul>
<li>顺序文件<ul>
<li>最简单的一种结构</li>
<li>按长度分：定长记录顺序文件、变长记录顺序文件</li>
<li>按关键字分：串结构(与关键字顺序无关)、与关键字顺序有关</li>
<li>优点：存取快，随机访问</li>
<li>缺点：不会产生外部碎片</li>
</ul>
</li>
<li>索引文件<ul>
<li>建立一个索引表</li>
<li>优点：随机访问、易于开销</li>
<li>缺点：效率低、空间开销大</li>
</ul>
</li>
<li>索引顺序文件：为顺序结构分组，每组第一个建立索引表</li>
<li>直接文件、散列文件：关键字值决定物理地址</li>
</ul>
<h3 id="文件的物理结构"><a href="#文件的物理结构" class="headerlink" title="文件的物理结构"></a>文件的物理结构</h3><ul>
<li>连续分配</li>
<li>链接分配</li>
<li>索引分配</li>
</ul>
<h2 id="目录的结构"><a href="#目录的结构" class="headerlink" title="目录的结构"></a>目录的结构</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>实现按名存取</li>
<li>提高检索速度</li>
<li>允许文件同名：通过不同工作目录加以区分</li>
<li>允许文件共享</li>
</ul>
<h3 id="文件控制块"><a href="#文件控制块" class="headerlink" title="文件控制块"></a>文件控制块</h3><ul>
<li>文件名</li>
<li>文件的结构：逻辑结构是记录式（否定长、记录长度、个数）还是流式，物理结构是什么</li>
<li>文件的物理位置</li>
<li>存取控制信息：用户的权限</li>
<li>管理信息</li>
</ul>
<h3 id="索引节点"><a href="#索引节点" class="headerlink" title="索引节点"></a>索引节点</h3><ul>
<li>将文件名与文件描述信息分开</li>
<li>文件目录由文件名和指向具体文件的指针</li>
<li>磁盘索引节点：文件主标识符、文件类型、文件存取权限、文件物理地址、文件长度、文件连接计数、文件存取时间</li>
<li>内存索引节点：磁盘索引节点、索引节点编号、状态、访问计数、逻辑设备号、链接指针</li>
</ul>
<h3 id="单级目录结构"><a href="#单级目录结构" class="headerlink" title="单级目录结构"></a>单级目录结构</h3><ul>
<li>只建立一张用户表</li>
<li>不允许重名</li>
<li>查找效率慢</li>
</ul>
<h3 id="二级目录结构"><a href="#二级目录结构" class="headerlink" title="二级目录结构"></a>二级目录结构</h3><ul>
<li>主文件目录：系统中各个用户文件目录的情况</li>
<li>用户文件目录：每个用户单独一个目录</li>
</ul>
<h3 id="树形结构"><a href="#树形结构" class="headerlink" title="树形结构"></a>树形结构</h3><ul>
<li>第一级目录为根目录</li>
<li>非叶子节点为目录</li>
<li>叶子节点为文件</li>
<li>引入路径名\，当前目录..表示给的目录的父目录</li>
</ul>
<h3 id="图形结构"><a href="#图形结构" class="headerlink" title="图形结构"></a>图形结构</h3><ul>
<li>方便共享</li>
<li>每增加一个共享链时计数器+1，删除一个共享链计时器-1，当计数器为0时才删除文件</li>
</ul>
<h2 id="文件的共享"><a href="#文件的共享" class="headerlink" title="文件的共享"></a>文件的共享</h2><ul>
<li>节省大量的外存空间和主存空间</li>
<li>共享动机<ul>
<li>相互协作共同完成任务</li>
<li>远程计算机之间需要通信，需要远程文件系统的共享功能</li>
</ul>
</li>
<li>共享方式<ul>
<li>基于索引节点的共享方式（硬链接）：不同目录的文件指针指向同一文件</li>
<li>利用符号链实现文件共享（软连接）：只有所有者才有指针，其他用户只有路径名</li>
</ul>
</li>
</ul>
<h2 id="文件的保护"><a href="#文件的保护" class="headerlink" title="文件的保护"></a>文件的保护</h2><ul>
<li>访问类型（读写增加删除执行等）</li>
<li>访问控制：访问控制矩阵、访问控制表、用户权限表、密码与口令</li>
</ul>
<h1 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h1><h2 id="层次结构"><a href="#层次结构" class="headerlink" title="层次结构"></a>层次结构</h2><ul>
<li>用户接口（cmd等）</li>
<li>文件目录系统</li>
<li>存取控制验证（权限）</li>
<li>逻辑文件系统与文件信息缓冲区（获取文件的逻辑地址）</li>
<li>物理文件系统（获取文件的物理地址）</li>
</ul>
<h2 id="目录的实现"><a href="#目录的实现" class="headerlink" title="目录的实现"></a>目录的实现</h2><ul>
<li>线性表</li>
<li>散列表</li>
</ul>
<h2 id="文件的实现"><a href="#文件的实现" class="headerlink" title="文件的实现"></a>文件的实现</h2><p>外存分配方式</p>
<ul>
<li><p>连续分配</p>
</li>
<li><p>链接分配</p>
<ul>
<li>隐式分配：指针放在每一个物理块中</li>
<li>显示分配：指针放在内存的一张链接表中</li>
</ul>
</li>
<li><p>索引分配</p>
<ul>
<li>单级索引分配</li>
<li>两级索引分配</li>
<li>混合索引分配：既采用直接地址，也使用单级或两级索引分配</li>
</ul>
</li>
<li><p>文件存储空间管理</p>
<ul>
<li>空闲文件表<ul>
<li>将一个连续空闲区看作一个文件</li>
<li>若请求等于块数则全部分配</li>
<li>请求小于块数则部分留下</li>
</ul>
</li>
<li>空闲块链表：把所有空闲区域链起来，分配时一次从头开始</li>
<li>位示图法：1表示已分配，0表示未分配，分配时按照需要找到一组值为0的二进制</li>
<li>成组链接法：<ul>
<li>所有空闲区按每组100块分成若干组，所有盘号记录到前一组中，形成堆栈</li>
<li>分配空闲盘块的方法<ul>
<li>先查找第一组的盘块数，</li>
<li>若不止一块则将超级盘块中的空闲盘块数减一，将栈顶的盘块分配出去</li>
<li>若只剩一块且盘块号不是标记结束的0，则将该块的内容读入超级块中，将该块分配出去</li>
<li>若是0，则分配失败</li>
</ul>
</li>
<li>回收空闲盘块的方法<ul>
<li>若第一个不满100块，则只要在超级块的栈顶放入该空闲盘块的块号，并将磁盘块数+1</li>
<li>若已经有100块了，则先将第一组的盘块数和盘块号写入该空闲磁盘块中，再将盘块数=1，栈顶块号=该空闲盘口块号写入超级块中，原来第一组变为第二组</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="磁盘组织与管理"><a href="#磁盘组织与管理" class="headerlink" title="磁盘组织与管理"></a>磁盘组织与管理</h1><h2 id="物理结构"><a href="#物理结构" class="headerlink" title="物理结构"></a>物理结构</h2><p>柱面号、磁头号、扇区号</p>
<h2 id="信息"><a href="#信息" class="headerlink" title="信息"></a>信息</h2><ul>
<li>引导控制块（分区的第一块，没有操作系统则为空）</li>
<li>分区控制块（分区信息）</li>
<li>目录结构</li>
<li>文件控制块（文件信息）</li>
</ul>
<h2 id="访问时间"><a href="#访问时间" class="headerlink" title="访问时间"></a>访问时间</h2><ul>
<li>访问时间=寻道时间+旋转延迟+传输时间</li>
<li>寻道时间Ts=m*n+s(m:每移动一个磁道所需时间，s启动磁臂的时间、n移动几条磁道)</li>
<li>旋转延迟Tr=（1/r）/2（r旋转速度）</li>
<li>传输时间Tt=b/（rN）</li>
</ul>
<h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><ul>
<li>先来先服务算法FCFS：先来先服务</li>
<li>最短寻道时间优先算法SSTF：离磁头最近</li>
<li>扫描算法SCAN：</li>
<li>循环扫描算法C-SCAN：单向移动</li>
</ul>
<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><ul>
<li>磁盘格式化：空白盘分区并写入基础信息</li>
<li>引导块：计算机启动时需要运行初始化程序（自举程序），找到系统内核装入内存，开始操作系统的运行</li>
<li>坏扇区<ul>
<li>简单磁盘（IDE）手工处理</li>
<li>复杂磁盘（SCSI）维护一个磁盘坏块链表</li>
</ul>
</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤操作系统</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>fileManager</tag>
      </tags>
  </entry>
  <entry>
    <title>存储器（内存）管理</title>
    <url>/2020/03/16/osMemoryManager/</url>
    <content><![CDATA[<h1 id="内存管理概念"><a href="#内存管理概念" class="headerlink" title="内存管理概念"></a>内存管理概念</h1><p>用来对内存进行分配保护和扩充</p>
<p>功能：内存分配与回收、地址变换、内存保护、内存扩充</p>
<p>过程：编译-&gt;链接-&gt;装入</p>
<ul>
<li>静态链接：在程序运行前，先把各个目标模块及所需库链接成一个完整的可执行程序，以后不再拆开</li>
<li>装入时动态链接：边装入边链接</li>
<li>运行时动态链接：边运行边链接</li>
<li>绝对装入：在装入时就知道物理地址</li>
<li>可重定位装入：地址变换通常在装入时一次完成</li>
<li>动态运行装入：允许程序运行时在内存中移动位置，物理地址=基址寄存器+逻辑地址（逻辑地址是偏移地址，物理地址是内存中的地址）</li>
</ul>
<p>内存保护：防止一个作业有意无意破坏操作系统或其他作业</p>
<table>
<thead>
<tr>
<th>内存保护方法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>上下界寄存器方法</td>
<td>采用上下界分别存放作业结束地址和开始地址</td>
</tr>
<tr>
<td>基址（重定位寄存器）和限长寄存器（界地址寄存器）方法</td>
<td>限长寄存器与相对地址进行比较，超过则发生中断</td>
</tr>
<tr>
<td>存储保护键方法</td>
<td>给每个存储块分配一个单独的保护键，比较钥匙和锁是否匹配</td>
</tr>
</tbody></table>
<h1 id="交换与覆盖"><a href="#交换与覆盖" class="headerlink" title="交换与覆盖"></a>交换与覆盖</h1><table>
<thead>
<tr>
<th>技术</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>覆盖技术</td>
<td>解决程序不能全部装入内存中</td>
</tr>
<tr>
<td>交换技术</td>
<td>把暂时不用的程序或数据移入外存</td>
</tr>
</tbody></table>
<h1 id="分配管理方式"><a href="#分配管理方式" class="headerlink" title="分配管理方式"></a>分配管理方式</h1><h2 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h2><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><ul>
<li>将内存分为两个连续存储区域，一个给操作系统，一个给用户</li>
<li>采用静态分配，适合单道程序</li>
</ul>
<h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><ul>
<li>每个分区可以装入一道程序，分区大小事先固定</li>
<li>缺乏灵活性，以产生碎片</li>
</ul>
<h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><table>
<thead>
<tr>
<th>分区分配中的数据结构</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>空闲分区表</td>
<td>每个空闲分区表对应一个表项</td>
</tr>
<tr>
<td>空闲分区链</td>
<td>指向下一个 空闲分区的指针</td>
</tr>
</tbody></table>
<ul>
<li>空闲分区表：每个空闲分区表对应一个表项</li>
<li>空闲分区链：指向下一个 空闲分区的指针</li>
</ul>
<table>
<thead>
<tr>
<th>分区分配中的算法</th>
<th>解释</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>首次适应算法FF</td>
<td>按地址来，每次都从队头开始</td>
<td>保留了高位地址大的空闲区，无内部碎片</td>
<td>地位地址被划分，产生很多小的空闲区，无外部碎片</td>
</tr>
<tr>
<td>下次适应算法NF</td>
<td>按地址，循环，从上次空闲区下一个区开始</td>
<td>使空闲分区分布更加均匀</td>
<td>导致缺乏大的空闲分区</td>
</tr>
<tr>
<td>最佳适应算法BF</td>
<td>按容量大小从大开始，找到一个可以满足的最小区</td>
<td>总能分到最恰当的分区，并保留最大的</td>
<td>产生很多碎片</td>
</tr>
<tr>
<td>最差适应算法WF</td>
<td>按容量大小从小开始，找到按要求最大的</td>
<td>使分给作业后剩的空闲分区比较大</td>
<td>无法满足大作业的申请</td>
</tr>
</tbody></table>
<p>分区回收：合并上面，合并下面，合并上下</p>
<table>
<thead>
<tr>
<th>分区分配的动态管理</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>拼接技术</td>
<td>把已分配的移动到一端，碎片集中到一起</td>
</tr>
<tr>
<td>动态重定位分区分配技术</td>
<td>与上面的分配算法相同，并增加了拼接技术</td>
</tr>
</tbody></table>
<h2 id="非连续分配管理方式"><a href="#非连续分配管理方式" class="headerlink" title="非连续分配管理方式"></a>非连续分配管理方式</h2><h3 id="基本分页管理方式"><a href="#基本分页管理方式" class="headerlink" title="基本分页管理方式"></a>基本分页管理方式</h3><ul>
<li>页：用户作业地址空间被划分成若干大小相同区域，成为页或页面</li>
<li>页表：将页面与物理地址一一对应形成一张表</li>
</ul>
<p><img src="/2020/03/16/osMemoryManager/jibenfenyeguanli.png" alt="图片-基本分页管理方式"></p>
<ul>
<li>两级页表和多级页表<ul>
<li>页表大小计算</li>
<li>两级页表：外层页号，外层内页地址，页内地址</li>
<li>多级页表：增加级数，减小页表的大小</li>
</ul>
</li>
<li>页的保护与共享<ul>
<li>地址越界保护：用地址和长度来保护信息安全</li>
<li>访问控制信息保护</li>
</ul>
</li>
<li>有效访问时间计算<ul>
<li>没有快表EAT=2t（t访存一次消耗时间）</li>
<li>有快表EAT=a<em>b+(t+a)</em>(1-b)+t，（a访问快表时间，b快表命中率）</li>
</ul>
</li>
<li>优点：利用率高，实现了离散分配，便于存储访问控制，无外部碎片</li>
<li>缺点：硬件支持，内存访问效率下降，共享困难，内部碎片</li>
</ul>
<h3 id="基本分段管理方式"><a href="#基本分段管理方式" class="headerlink" title="基本分段管理方式"></a>基本分段管理方式</h3><ul>
<li><p>段：一组逻辑意义上相对完整的信息集合，逻辑地址结构由段号和段内位移组成</p>
</li>
<li><p>段表及地址变换：</p>
<ul>
<li>从逻辑地址A中取出前几位为段号S，后几位为段内偏移量W。</li>
<li>比较段号S和段表长度M，若S多M，则产生越界中断，否则继续执行。</li>
<li>段表中段号S对应的段表项地址 = 段表起始地址F + 段号S * 段表项长度，取出该段表项的前几位得到段长C。若段内偏移量&gt;=C，则产生越界中断，否则继续执行。</li>
<li>取出段表项中该段的起始地址b，计算 E = b + W，用得到的物理地址E去访问内存。</li>
</ul>
</li>
<li><p>段的共享与保护：与页相同</p>
</li>
<li><p>优点：便于模块化、程序化处理数据结构，便于动态链接和共享、无内部碎片，方便编程、信息共享、信息保护</p>
</li>
<li><p>缺点：需要硬件支持、为满足动态增长减少外部碎片需要拼接技术、分段最大尺寸受主存可用空间限制、有外部碎片</p>
</li>
<li><p>段与页区别</p>
<p><img src="/2020/03/16/osMemoryManager/duanyequbie.jpg" alt="图片-段页的区别"></p>
</li>
<li><p>基本段页式管理方式</p>
<p>页式存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享。如果将这两种存储管理方法结合起来，就形成了段页式存储管理方式。</p>
<p>在段页式系统中，作业的地址空间首先被分成若干个逻辑段，每段都有自己的段号，然后再将每一段分成若干个大小固定的页。对内存空间的管理仍然和分页存储管理一样，将其分成若干个和页面大小相同的存储块，对内存的分配以存储块为单位</p>
<p>结合了两者的优点，但内部碎片不是和页式一样少</p>
</li>
</ul>
<h1 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h1><p>可以让作业部分装入就可以运行的技术</p>
<table>
<thead>
<tr>
<th>特征</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>部分装入</td>
<td>启动程序，程序一部分装入内存</td>
</tr>
<tr>
<td>请求调入</td>
<td>当信息不在内存时，有操作系统将需要的部分调入</td>
</tr>
<tr>
<td>置换功能</td>
<td>将暂时不使用的调入外存</td>
</tr>
<tr>
<td>虚拟存储器</td>
<td>逻辑上扩充存储器空间</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>局部性原理</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>时间局部</td>
<td>一次或下次访问都集中在一个较短的时期内</td>
</tr>
<tr>
<td>控件局部</td>
<td>访问的内容和邻近的内容都集中在一个较小的区域内</td>
</tr>
</tbody></table>
<p>特点：离散性、多次性、对换性、虚拟性</p>
<p>软硬件支持</p>
<ul>
<li>相当数量的外存</li>
<li>一定容量的内存</li>
<li>中断机构：当访问不在内存中，实行中断</li>
<li>地址变换机构：动态实现虚地址到实地址变换</li>
<li>相关数据结构：段表或页表</li>
</ul>
<h2 id="请求分页存储管理系统"><a href="#请求分页存储管理系统" class="headerlink" title="请求分页存储管理系统"></a>请求分页存储管理系统</h2><h3 id="管理方式"><a href="#管理方式" class="headerlink" title="管理方式"></a>管理方式</h3><ul>
<li><p>请求分页=基本分页+请求调页功能+页面置换功能</p>
</li>
<li><p>页表结构</p>
<ul>
<li>页号和物理块号</li>
<li>状态位（存在位）：是否存在于主存</li>
<li>访问字段一段时间内被访问的次数</li>
<li>修改位：调入内存后是否被修改过</li>
</ul>
</li>
<li><p>缺页中断与地址变换</p>
<p><img src="/2020/03/16/osMemoryManager/queyezhongduan.jpg" alt="图片-缺页中断"></p>
</li>
</ul>
<h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><ul>
<li>最佳置换算法OPT：最先淘汰后面都不使用的</li>
<li>先进先出置换算法FIFO：</li>
<li>最近最少使用置换算法LRU：保留最近使用的</li>
<li>时钟置换算法CLOCK：从上一个被淘汰的页面开始遍历遇到访问位0就淘汰，将经过的访问位为1的都置为0</li>
<li>改进时钟置换算法CLOCK：同为0的页面优先淘汰未修改的。第一遍扫描不对经过的修改遇到访问位和过程位都为0的淘汰，若无第二遍对过程中访问位置0遇到访问位为0修改位为1淘汰，若无回到起始位重新执行1和2</li>
<li>最不常用置换算法LFU</li>
<li>页面缓冲算法PBA</li>
</ul>
<h3 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h3><ul>
<li>工作集论：让操作系统监视各进程的工作集，若内存有空，则再调一个进程进入内存。若超过，则选择一个进程对换到磁盘</li>
<li>页面分配策略<ul>
<li>固定分配局部置换：为每个进程分配固定的物理块</li>
<li>可变分配全局置换：维护一个空闲物理块，每当进程缺页时，就分配给它，当空闲物理块不够时，就从任何进程中随机取出一页</li>
<li>可变分配局部置换：为每个进程分配一定的物理块，当缺页中断时且无空闲物理块，只让进程换出自己的某个内存页，平凡缺页时就分配给它适当物理块，缺页率少时，适当减少物理块</li>
</ul>
</li>
<li>页面调入策略<ul>
<li>请求调页策略：只有用到时才被调入内存</li>
<li>预调页策略：预计不久之后会用到的调入内存</li>
</ul>
</li>
<li>从何处调入<ul>
<li>系统拥有足够的兑换空间：从对换区全部调入</li>
<li>系统缺少足够的对换空间：不被修改的从文件区调入，可能被修改的调到对换区调入</li>
<li>UNIX方式：与进程有关的都放入文件区，未运行的都在文件区，运行的且被换出的，由于是在对换区，下次仍从对换区调</li>
</ul>
</li>
</ul>
<h3 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h3><ul>
<li>Belady移除：FIFO随物理块增加缺页率增加</li>
<li>抖动现性：刚被调出又要被调入</li>
<li>缺页率：所需页面调入内存的次数/访问次数</li>
</ul>
<h3 id="有效访问时间计算"><a href="#有效访问时间计算" class="headerlink" title="有效访问时间计算"></a>有效访问时间计算</h3><ul>
<li>访问的页在主存中,且在快表中EAT=a+t</li>
<li>访问的页在主存中,但不在快表中EAT=T+2*(a+t)，（T处理缺页中断时间）</li>
<li>访问的页不在主存中,更不在快表中EAT=T+2*(a+t)</li>
<li>加入缺页率和命中快表的概率：EAT=a+b<em>t+(1-b)</em>[t+f<em>(T+a+t)+(1-f)</em>(a+t)]，（f缺页率）</li>
</ul>
<h2 id="请求分段存储管理系统"><a href="#请求分段存储管理系统" class="headerlink" title="请求分段存储管理系统"></a>请求分段存储管理系统</h2><p>与分页类似</p>
<h2 id="内存管理方式比较"><a href="#内存管理方式比较" class="headerlink" title="内存管理方式比较"></a>内存管理方式比较</h2><p><img src="/2020/03/16/osMemoryManager/neicunguanlibijiao.jpg" alt="图片-内存管理方式比较"></p>
<h2 id="内存管理地址的处理"><a href="#内存管理地址的处理" class="headerlink" title="内存管理地址的处理"></a>内存管理地址的处理</h2><p><img src="/2020/03/16/osMemoryManager/dizhichuli.jpg" alt="图片-内存管理地址的处理"></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤操作系统</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>memoryManager</tag>
      </tags>
  </entry>
  <entry>
    <title>处理器（进程）管理</title>
    <url>/2020/03/16/osProcessManager/</url>
    <content><![CDATA[<p>进程管理是对处理器的分配和运行实施有效管理，在多道程序下处理器的分配和运行以进程为单位。</p>
<p>主要功能：进程控制、进程同步、进程通信、进程调度</p>
<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>进程是资源分配的基本单位，也是独立运行的基本单位</p>
<h2 id="前驱图"><a href="#前驱图" class="headerlink" title="前驱图"></a>前驱图</h2><p>前驱图是一个有向无循环图，记为DAG。用于这种图可以描述多个程序或进程之间的执行顺序关系。</p>
<ul>
<li>〇 表示一个程序、进程或是语句的结点。</li>
<li>→ 表示结点间的执行顺序。</li>
<li>前驱图中不能存在循环，否则必然会产生不可能实现的前驱关系</li>
</ul>
<p><img src="/2020/03/16/osProcessManager/qianqutu.png" alt="图片-前驱图"></p>
<h2 id="程序的执行"><a href="#程序的执行" class="headerlink" title="程序的执行"></a>程序的执行</h2><table>
<thead>
<tr>
<th>顺序执行</th>
<th>并发执行</th>
</tr>
</thead>
<tbody><tr>
<td>顺序性</td>
<td>间断性：执行-暂停-执行</td>
</tr>
<tr>
<td>封闭性</td>
<td>失去封闭性：一个程序执行时会受其他程序影响</td>
</tr>
<tr>
<td>可再现性</td>
<td>不可再现性：并发执行结果具有再现性需要满足：R(p1)并W(p2)=空，R(p2)并W(p1)=空，W(p1)并W(p2)=空</td>
</tr>
</tbody></table>
<h2 id="进程的定义与描述"><a href="#进程的定义与描述" class="headerlink" title="进程的定义与描述"></a>进程的定义与描述</h2><p>定义</p>
<ul>
<li>进程是程序在处理器上的一次执行过程</li>
<li>进程是可以和别的进程并行执行计算</li>
<li>进程可定义为数据结构及能在其上进行操作的一个程序</li>
<li>进程是一个程序关于某个数据集合在处理器上顺序执行所发生的活动</li>
</ul>
<p>特征</p>
<ul>
<li>动态性</li>
<li>并发性</li>
<li>独立性：独立运行的基本单位、资源分配和调度的基本单位</li>
<li>异步性：以独立的不可预知的速度前进</li>
<li>结构特征：程序段、数据段、进程控制块</li>
</ul>
<h2 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h2><ul>
<li><p>进程控制块（PCB）：为每个进程定义的数据结构，是程序能够独立运行，是进程存在的唯一标志。</p>
<p>进程控制块（PCB）的组成：进程标识标识符(PID)、进程当前状态、进程队列指针、程序与数据地址、进程优先级、CPU现场保护区、通信信息、家族联系、占有资源清单。</p>
</li>
<li><p>程序段</p>
</li>
<li><p>数据段</p>
</li>
</ul>
<h2 id="进程与程序"><a href="#进程与程序" class="headerlink" title="进程与程序"></a>进程与程序</h2><table>
<thead>
<tr>
<th>进程</th>
<th>程序</th>
</tr>
</thead>
<tbody><tr>
<td>动态的</td>
<td>静止的</td>
</tr>
<tr>
<td>程序的执行</td>
<td>代码的集合</td>
</tr>
<tr>
<td>暂时的</td>
<td>永久的</td>
</tr>
<tr>
<td>通过调用，一个进程可以执行多个程序</td>
<td>通过多次执行，程序可以产生多个进程</td>
</tr>
<tr>
<td>并行性</td>
<td>无</td>
</tr>
<tr>
<td>组成不同</td>
<td>组成不同</td>
</tr>
</tbody></table>
<h2 id="进程与作业"><a href="#进程与作业" class="headerlink" title="进程与作业"></a>进程与作业</h2><table>
<thead>
<tr>
<th>进程</th>
<th>作业</th>
</tr>
</thead>
<tbody><tr>
<td>完成用户任务的执行实体</td>
<td>用户向计算机提交任务的任务实体</td>
</tr>
<tr>
<td>一个进程不能构成多个作业</td>
<td>一个作业必须至少一个进程组成</td>
</tr>
<tr>
<td>用在所有多道程序中</td>
<td>出现在批处理系统</td>
</tr>
</tbody></table>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><table>
<thead>
<tr>
<th>进程</th>
<th>线程</th>
</tr>
</thead>
<tbody><tr>
<td>拥有资源的独立单位</td>
<td>不拥有资源，可以访问资源</td>
</tr>
<tr>
<td>可以被处理器独立调度和分配的单元</td>
<td>独立调度的基本单位</td>
</tr>
<tr>
<td>包含线程</td>
<td>是进程内一个执行单元，是进程内可调度的一个实体，是程序中相对独立的控制流序列，不能单独运行，只能在进程中执行</td>
</tr>
</tbody></table>
<p>线程的实现</p>
<ul>
<li>内核级线程：一个线程被阻塞，不影响其他线程工作</li>
<li>用户级线程：一个线程被阻塞，整个进程都要等待。维护需要应用进程，不需要内核特权</li>
</ul>
<p>多线程模型</p>
<ul>
<li>多对一模型：多个用户级线程映射到一个内核级线程上，用户空间管理效率高，不能并行</li>
<li>一对多模型：内核级线程与用户级线程一一对应，当一个线程被阻塞，不影响其他线程</li>
<li>多对多模型：多用户级线程映射到多内核级线程上，打破对用户级的限制，使多个用户级线程真正意义上并行执行</li>
</ul>
<h2 id="进程状态与转换"><a href="#进程状态与转换" class="headerlink" title="进程状态与转换"></a>进程状态与转换</h2><ul>
<li>就绪状态</li>
<li>执行状态（运行状态）</li>
<li>阻塞状态（等待状态）</li>
<li>创建状态</li>
<li>结束状态</li>
</ul>
<p><img src="/2020/03/16/osProcessManager/zhuangtaizhuanhuan.jpg" alt="图片-状态与转换"></p>
<h2 id="进程的控制"><a href="#进程的控制" class="headerlink" title="进程的控制"></a>进程的控制</h2><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><p>创建原语</p>
<ul>
<li>用户登录</li>
<li>作业调度</li>
<li>请求服务</li>
<li>先向系统申请一个空闲PCB，并指定唯一的进程标识符</li>
<li>为新进程分配必要的资源</li>
<li>新进程PCB初始化</li>
<li>新进程PCB插入就绪队列</li>
</ul>
<h3 id="进程的撤销"><a href="#进程的撤销" class="headerlink" title="进程的撤销"></a>进程的撤销</h3><ul>
<li>先从PCB集合中找到被撤销的PCB</li>
<li>若该进程正在执行，则立即停止，设置重新调度标志，以便将处理器分配给其他进程</li>
<li>若撤销的进程有子孙进程，将子孙进程也予以撤销</li>
<li>回收撤销进程所占有的资源，归还给父进程或系统，回收它的PCB</li>
</ul>
<h3 id="进程的阻塞"><a href="#进程的阻塞" class="headerlink" title="进程的阻塞"></a>进程的阻塞</h3><ul>
<li>首先停止当前进程运行，中断处理器</li>
<li>保存该进程CPU现场以便可以重新调用</li>
<li>停止运行该进程，将状态改为阻塞状态</li>
<li>转到进程调度程序，从就绪队列中选一个新的进程投入运行</li>
</ul>
<h3 id="进程的唤醒"><a href="#进程的唤醒" class="headerlink" title="进程的唤醒"></a>进程的唤醒</h3><ul>
<li>将被唤醒的进程从相应的等待队列中移出</li>
<li>将状态改为就绪，并插入相应的就绪队列中</li>
</ul>
<h3 id="进程的切换"><a href="#进程的切换" class="headerlink" title="进程的切换"></a>进程的切换</h3><ul>
<li>保存处理及上下文</li>
<li>更新PCB</li>
<li>把进程PCB移入相应队列</li>
<li>选择另一个进程执行，更新其PCB</li>
<li>更新内存管理的数据结构</li>
<li>恢复处理器上下文</li>
</ul>
<h2 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h2><ul>
<li>共享存储器系统：在存储器中划分一大片区域，多线程可以共享便于信息传输</li>
<li>消息传递系统<ul>
<li>直接通信方式：发送进程把消息发给接收进程，并将消息挂在进程消息缓冲队列上，接收进程从消息缓冲队列中取得消息</li>
<li>间接通信方式：发送进程把消息把消息发到某个中间实体中，接收进程从中取得消息</li>
</ul>
</li>
<li>管道通信系统：连接读进程和写进程以实现他们之间通信的共享文件</li>
</ul>
<h1 id="处理器调度"><a href="#处理器调度" class="headerlink" title="处理器调度"></a>处理器调度</h1><h2 id="三级调度"><a href="#三级调度" class="headerlink" title="三级调度"></a>三级调度</h2><ul>
<li>高级调度（作业调度，宏观，长程）：从外存中选择一个作业进行资源分配，建立相应进程，几分钟一次</li>
<li>中级调度（中程调度或交换调度）：提高内存利用率和系统吞吐量，按照一定原则将处于外存对换区中的具备运行条件的进程调入内存，并修改其状态为就绪</li>
<li>低级调度（进程调度，微观，短程）：从就绪队列中取一个进程分配处理器给它，几十毫秒一次</li>
</ul>
<p><img src="/2020/03/16/osProcessManager/sanjidiaodu.jpg" alt="图片-调度"></p>
<h2 id="调度的基本原则"><a href="#调度的基本原则" class="headerlink" title="调度的基本原则"></a>调度的基本原则</h2><ul>
<li>CPU利用率</li>
<li>系统吞吐量：单位时间CPU完成作业的数量</li>
<li>响应时间</li>
<li>周转时间<ul>
<li>周转时间：作业i完成时间-作业i提交时间</li>
<li>平均周转时间：n个作业，周转时间之和/n</li>
<li>带权周转时间：周转时间/运行时间</li>
<li>平均带权周转时间：带权之和/n</li>
</ul>
</li>
</ul>
<h2 id="进程的调度"><a href="#进程的调度" class="headerlink" title="进程的调度"></a>进程的调度</h2><p>功能</p>
<ul>
<li>记录系统中所有进程的有关情况以及状态特征</li>
<li>选择获取处理器的进程</li>
<li>处理器分配</li>
</ul>
<p>原因</p>
<ul>
<li>进程运行结束</li>
<li>以某种原因，进程进入阻塞</li>
<li>执行完系统调用返回用户进程，准备调用新的用户进程</li>
<li>在抢占调度方式的系统中，更高优先级进程请求使用处理器</li>
<li>分时系统中，分给该进程的时间片以用完</li>
</ul>
<p>不能进行进程调度的情况</p>
<ul>
<li>处理中断的过程中</li>
<li>在操作系统内核程序临界区中</li>
<li>其他需要屏蔽中断程序的原子操作中</li>
</ul>
<p>进程调度方式</p>
<ul>
<li>抢占方式：可以在执行中暂停，分配给其他进程</li>
<li>非抢占方式：必须执行完毕或阻塞才可以分配其他进程</li>
</ul>
<h2 id="常见调度算法"><a href="#常见调度算法" class="headerlink" title="常见调度算法"></a>常见调度算法</h2><ul>
<li>先来先服务调度算法(作业调度，进程调度)</li>
<li>短作业优先调度算法(作业调度，进程调度)</li>
<li>优先级调度算法(作业调度，进程调度)<ul>
<li>按进程类确定</li>
<li>按作业资源确定</li>
<li>按用户类型和要求确定</li>
<li>根据占有CPU时间长短确定</li>
<li>根据就绪进程等待CPU的长度</li>
</ul>
</li>
<li>时间片轮转调度算法(进程调度)<ul>
<li>系统响应时间</li>
<li>就绪队列中的进程数目</li>
<li>系统的处理能力</li>
</ul>
</li>
<li>高响应比优先调度算法(作业调度)：作业响应时间/估计运行时间</li>
<li>多级队列调度算法(进程调度)</li>
<li>多级反馈队列调度算法(进程调度)</li>
</ul>
<h1 id="同步与互斥"><a href="#同步与互斥" class="headerlink" title="同步与互斥"></a>同步与互斥</h1><h2 id="制约关系"><a href="#制约关系" class="headerlink" title="制约关系"></a>制约关系</h2><ul>
<li>间接相互制约：多个同种进程互斥的共享某种资源</li>
<li>直接相互制约：进程间的合作</li>
</ul>
<h2 id="临界资源"><a href="#临界资源" class="headerlink" title="临界资源"></a>临界资源</h2><ul>
<li>同时仅允许一个进程使用</li>
<li>访问过程<ul>
<li>进入区</li>
<li>临界区：用于访问临界资源的代码</li>
<li>退出区：将正在访问的标志清除</li>
<li>剩余区</li>
</ul>
</li>
</ul>
<h2 id="遵循原则"><a href="#遵循原则" class="headerlink" title="遵循原则"></a>遵循原则</h2><ul>
<li>空闲让进：空闲时就可以进入</li>
<li>忙则等待</li>
<li>有限等待：有限时间等待</li>
<li>让权等待：优先进入</li>
</ul>
<h2 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h2><p>互斥是由程序共享资源所引起的，某一个资源不允许同时多个程序访问，那么解决方法是要么访问其他空闲的同种资源，要么等待这一资源。等待这一资源就要在操作系统实现互斥：当一个进程正在使用资源的时候，其他希望使用该资源的程序必须等待，当该进程使用完并释放资源后，才允许其他进程去访问此资源，我们称这种进程之间的互相制约关系叫做互斥。</p>
<h3 id="互斥的实现软件方法"><a href="#互斥的实现软件方法" class="headerlink" title="互斥的实现软件方法"></a>互斥的实现软件方法</h3><p>算法一：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">turn</span> = <span class="number">0</span>;</span><br><span class="line">P0: &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">turn</span> == <span class="number">0</span>)</span><br><span class="line">            P0的临界区代码CS0；</span><br><span class="line">            <span class="built_in">turn</span> = <span class="number">1</span>；</span><br><span class="line">            进程的其他代码codesegment1；</span><br><span class="line">           &#125;</span><br><span class="line">        <span class="keyword">while</span>(ture)；</span><br><span class="line">    &#125;</span><br><span class="line">P1: &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="built_in">turn</span> == <span class="number">1</span>)</span><br><span class="line">            P1的临界区代码CS1；</span><br><span class="line">            <span class="built_in">turn</span> = <span class="number">0</span>；</span><br><span class="line">            进程的其他代码codesegment2；</span><br><span class="line">           &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)；</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>算法二：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> <span class="keyword">boolean</span> &#123;<span class="literal">true</span>, <span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">boolean</span> flag[<span class="number">2</span>] = &#123;<span class="literal">false</span>, <span class="literal">false</span>&#125;;</span><br><span class="line">P0 &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> flag[<span class="number">1</span>];</span><br><span class="line">            flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">            CS0;</span><br><span class="line">            flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">            codesegment1;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">P1: &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> flag[<span class="number">0</span>];</span><br><span class="line">            flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            CS1;</span><br><span class="line">            flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">            codesegment2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>算法三：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">boolean</span>&#123;<span class="literal">false</span>, <span class="literal">true</span>&#125;;</span><br><span class="line"><span class="keyword">boolean</span> flag[<span class="number">2</span>] = &#123;<span class="literal">false</span>, <span class="literal">false</span>&#125;;</span><br><span class="line">P0 &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> flag[<span class="number">1</span>];</span><br><span class="line">        CS0;</span><br><span class="line">        flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">        codesegment1;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">P1: &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">while</span> flag[<span class="number">0</span>]; </span><br><span class="line">            CS1;</span><br><span class="line">            flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">            codesegment2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>算法四：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">boolean</span>&#123;<span class="literal">false</span>, <span class="literal">true</span>&#125;;</span><br><span class="line"><span class="keyword">boolean</span> flag[<span class="number">2</span>] = &#123;<span class="literal">false</span>, <span class="literal">false</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">turn</span>;</span><br><span class="line">P0 &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        flag[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">turn</span> = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> flag[<span class="number">1</span>] &amp;&amp; <span class="built_in">turn</span> == <span class="number">1</span>;</span><br><span class="line">        CS0;</span><br><span class="line">        flag[<span class="number">0</span>] = <span class="literal">false</span>;</span><br><span class="line">        codesegment1;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">P1: &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            flag[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">turn</span> = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> flag[<span class="number">0</span>] &amp;&amp; <span class="built_in">turn</span> == <span class="number">0</span>; </span><br><span class="line">            CS1;</span><br><span class="line">            flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">            codesegment2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="互斥的实现硬件方法"><a href="#互斥的实现硬件方法" class="headerlink" title="互斥的实现硬件方法"></a>互斥的实现硬件方法</h3><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><h3 id="原语的定义"><a href="#原语的定义" class="headerlink" title="原语的定义"></a>原语的定义</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    queueType <span class="built_in">queue</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semWait</span><span class="params">(semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.count--;</span><br><span class="line">    <span class="keyword">if</span>(s.count&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*把当前进程插入阻塞队列*/</span></span><br><span class="line">        <span class="comment">/*阻塞当前进程*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">semSignal</span><span class="params">(semaphore s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.count++;</span><br><span class="line">    <span class="keyword">if</span>(s.count&lt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*把进程从阻塞队列中移除*/</span></span><br><span class="line">        <span class="comment">/*把进程插入就绪队列*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li>整型信号量</li>
<li>记录型信号量</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>进程同步</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore N=<span class="number">0</span>;			<span class="comment">//设置信号量并设置初值为0</span></span><br><span class="line">P1()&#123;</span><br><span class="line">	……</span><br><span class="line">	S1;</span><br><span class="line">	V(N);</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br><span class="line">P2()&#123;</span><br><span class="line">	……</span><br><span class="line">	P(N);</span><br><span class="line">	S2;</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进程互斥</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore N=<span class="number">1</span>;</span><br><span class="line">P1()&#123;</span><br><span class="line">	……</span><br><span class="line">    P(N);</span><br><span class="line">    P1的临界区代码;</span><br><span class="line">	V(N);</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br><span class="line">P2()&#123;</span><br><span class="line">	……</span><br><span class="line">	P(N);</span><br><span class="line">	P2的临界区代码;</span><br><span class="line">	V(N);</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h2><h3 id="生产者消费者问题"><a href="#生产者消费者问题" class="headerlink" title="生产者消费者问题"></a>生产者消费者问题</h3><p>问题描述</p>
<p>一组生产者进程和一组消费者进程共享一个初始为空、大小为n的缓冲区，只有缓冲区没满时，生产者才能把消息放入到缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或者一个消费者从中取出消息。</p>
<p>问题分析</p>
<p>1) 关系分析。生产者和消费者对缓冲区互斥访问是互斥关系，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者才能消费，他们也是同步关系。</p>
<p> 2) 整理思路。这里比较简单，只有生产者和消费者两个进程，正好是这两个进程存在着互斥关系和同步关系。那么需要解决的是互斥和同步PV操作的位置。</p>
<p> 3) 信号量设置。信号量mutex作为互斥信号量，它用于控制互斥访问缓冲池，互斥信号量初值为1；信号量full用于记录当前缓冲池中“满”缓冲区数，初值为0。信号量empty 用于记录当前缓冲池中“空”缓冲区数，初值为n。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore mutex=<span class="number">1</span>; <span class="comment">//临界区互斥信号量</span></span><br><span class="line">semaphore empty=n;  <span class="comment">//空闲缓冲区</span></span><br><span class="line">semaphore full=<span class="number">0</span>;  <span class="comment">//缓冲区初始化为空</span></span><br><span class="line">producer ()<span class="comment">//生产者进程 </span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        produce an item in nextp;  <span class="comment">//生产数据</span></span><br><span class="line">        P(empty);  <span class="comment">//获取空缓冲区单元</span></span><br><span class="line">        P(mutex);  <span class="comment">//进入临界区.</span></span><br><span class="line">        add nextp to <span class="built_in">buffer</span>;  <span class="comment">//将数据放入缓冲区</span></span><br><span class="line">        V(mutex);  <span class="comment">//离开临界区,释放互斥信号量</span></span><br><span class="line">        V(full);  <span class="comment">//满缓冲区数加1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">consumer ()<span class="comment">//消费者进程</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        P(full);  <span class="comment">//获取满缓冲区单元</span></span><br><span class="line">        P(mutex);  <span class="comment">// 进入临界区</span></span><br><span class="line">        <span class="built_in">remove</span> an item from <span class="built_in">buffer</span>;  <span class="comment">//从缓冲区中取出数据</span></span><br><span class="line">        V (mutex);  <span class="comment">//离开临界区，释放互斥信号量</span></span><br><span class="line">        V (empty) ;  <span class="comment">//空缓冲区数加1</span></span><br><span class="line">        consume the item;  <span class="comment">//消费数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读者写者问题"><a href="#读者写者问题" class="headerlink" title="读者写者问题"></a>读者写者问题</h3><p>问题描述</p>
<p>有读者和写者两组并发进程，共享一个文件，当两个或以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：①允许多个读者可以同时对文件执行读操作；②只允许一个写者往文件中写信息；③任一写者在完成写操作之前不允许其他读者或写者工作；④写者执行写操作前，应让已有的读者和写者全部退出。</p>
<p>问题分析</p>
<p>1) 关系分析。由题目分析读者和写者是互斥的，写者和写者也是互斥的，而读者和读者不存在互斥问题。</p>
<p> 2) 整理思路。两个进程，即读者和写者。写者是比较简单的，它和任何进程互斥，用互斥信号量的P操作、V操作即可解决。读者的问题比较复杂，它必须实现与写者互斥的同时还要实现与其他读者的同步，因此，仅仅简单的一对P操作、V操作是无法解决的。那么，在这里用到了一个计数器，用它来判断当前是否有读者读文件。当有读者的时候写者是无法写文件的，此时读者会一直占用文件，当没有读者的时候写者才可以写文件。同时这里不同读者对计数器的访问也应该是互斥的。</p>
<p> 3) 信号量设置。首先设置信号量count为计数器，用来记录当前读者数量，初值为0; 设置mutex为互斥信号量，用于保护更新count变量时的互斥；设置互斥信号量rw用于保证读者和写者的互斥访问。</p>
<p>读者优先</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;  <span class="comment">//用于记录当前的读者数量，初值为0</span></span><br><span class="line">semaphore mutex=<span class="number">1</span>;  <span class="comment">//用于保护更新count变量时的互斥</span></span><br><span class="line">semaphore rw=<span class="number">1</span>;  <span class="comment">//用于保证读者和写者互斥地访问文件</span></span><br><span class="line">reader () &#123;  <span class="comment">// 读者进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P (mutex) ;  <span class="comment">//互斥访问count变量</span></span><br><span class="line">        <span class="keyword">if</span> (count==<span class="number">0</span>)  <span class="comment">//当第一个读进程读共享文件时</span></span><br><span class="line">            P(rw);  <span class="comment">//阻止写进程写</span></span><br><span class="line">        count++;  <span class="comment">//读者计数器加1</span></span><br><span class="line">        V (mutex) ;  <span class="comment">//释放互斥变量count，允许其他读者使用count</span></span><br><span class="line">        reading;  <span class="comment">//读取</span></span><br><span class="line">        P (mutex) ;  <span class="comment">//申请互斥访问count变量，对其进行操作</span></span><br><span class="line">        count--; <span class="comment">//读者计数器减1</span></span><br><span class="line">        <span class="keyword">if</span> (count==<span class="number">0</span>)  <span class="comment">//当最后一个读进程读完共享文件</span></span><br><span class="line">            V(rw) ;  <span class="comment">//允许写进程写</span></span><br><span class="line">        V (mutex) ;  <span class="comment">//释放互斥变量 count，允许其他读者使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">writer () &#123;  <span class="comment">//写者进程</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)&#123;</span><br><span class="line">        P(rw); <span class="comment">// 互斥访问共享文件</span></span><br><span class="line">        Writing;  <span class="comment">//写入</span></span><br><span class="line">        V(rw) ;  <span class="comment">//释放共享文件，允许其他进程读写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的算法中，读进程是优先的，也就是说，当存在读进程时，写操作将被延迟，并且只要有一个读进程活跃，随后而来的读进程都将被允许访问文件。这样的方式下，会导致写进程可能长时间等待，且存在写进程“饿死”的情况。</p>
<p>公平情况算法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 读者队列初始值为0，其他资源初始值为1*/</span></span><br><span class="line"><span class="keyword">int</span> readCount = <span class="number">0</span>;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;<span class="comment">//控制互斥访问数据区</span></span><br><span class="line">semaphore wmutex = <span class="number">1</span>;<span class="comment">//读者互斥访问readCount</span></span><br><span class="line">semaphore rmutex = <span class="number">1</span>; <span class="comment">//存在写者时禁止新的读者进入</span></span><br><span class="line">reader()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      P(wmutex);<span class="comment">//检测是否有写者存在，无写者时进入</span></span><br><span class="line">      P(rmutex);  <span class="comment">//申请使用readCount</span></span><br><span class="line">      <span class="keyword">if</span>(!readCount)<span class="comment">//如果此为第一个读者，则阻止写者进入</span></span><br><span class="line">         P(mutex);</span><br><span class="line">      readCount++;<span class="comment">//读者数量加1</span></span><br><span class="line">      V(rmutex);<span class="comment">//释放readCount的使用权，允许其他读者使用</span></span><br><span class="line">      V(wmutex);<span class="comment">//恢复wmutex</span></span><br><span class="line">      进行读操作</span><br><span class="line">      P(rmutex);  <span class="comment">//申请使用readCount，要对其进行操作</span></span><br><span class="line">      readCount--;<span class="comment">//读者数量减一</span></span><br><span class="line">      <span class="keyword">if</span>(!readCount)<span class="comment">//如果没有读者，则释放数据区，允许写者进入</span></span><br><span class="line">         V(mutex);</span><br><span class="line">    V(rmutex); <span class="comment">//释放readCount的使用权，允许其他读者使用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">writer()</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">     &#123;</span><br><span class="line">        P(wmutex);     <span class="comment">//检测是否有其他写者存在，无写者时进入</span></span><br><span class="line">        P(mutex);       <span class="comment">//申请对数据区进行访问</span></span><br><span class="line">        进行写操作</span><br><span class="line">        V(mutex);   <span class="comment">//释放数据区，允许其他进程读写</span></span><br><span class="line">        V(wmutex); <span class="comment">//恢复wmutex</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>写者优先</p>
<p> 如果希望写进程优先，即当有读进程正在读共享文件时，有写进程请求访问，这时应禁止后续读进程的请求，等待到已在共享文件的读进程执行完毕则立即让写进程执行，只有在无写进程执行的情况下才允许读进程再次运行。为此，增加一个信号量并且在上面的程序中 writer()和reader()函数中各增加一对PV操作，就可以得到写进程优先的解决程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> wcount = <span class="number">0</span>;  <span class="comment">//用于记录写者数量 </span></span><br><span class="line"><span class="keyword">int</span> rcount = <span class="number">0</span>;   <span class="comment">//用于记录读者数量</span></span><br><span class="line">semaphore rmutex = <span class="number">1</span>;   <span class="comment">//用于读者进程互斥修改rcount</span></span><br><span class="line">semaphore wmutex = <span class="number">1</span>;   <span class="comment">//用于写者进程互斥修改wcount</span></span><br><span class="line">semaphore file = <span class="number">1</span>;    <span class="comment">//用于读者写者互斥访问数据区</span></span><br><span class="line">semphore  readable = <span class="number">1</span>;     <span class="comment">//表示当前是否有写者</span></span><br><span class="line">reader()</span><br><span class="line">&#123;</span><br><span class="line">    P(readable);<span class="comment">//检查是否存在写者，若没有则占用，进行后续操作 </span></span><br><span class="line">    P(rmutex);<span class="comment">//占用rmutex，准备修改rcount</span></span><br><span class="line">    <span class="keyword">if</span>(rcount == <span class="number">0</span>)<span class="comment">//若第一个为读者，则占用数据区</span></span><br><span class="line">        P(file);   <span class="comment">//申请文件资源 </span></span><br><span class="line">    rcount++;<span class="comment">//读者数量加一</span></span><br><span class="line">    V(rmutex);<span class="comment">//释放rmutex，允许其他读者访问rcount  </span></span><br><span class="line">    V(readable); <span class="comment">//释放readable，允许其他读者或写者占用</span></span><br><span class="line">    读操作</span><br><span class="line">    P(rmutex);<span class="comment">//占用rmutex，准备修改rcount</span></span><br><span class="line">    rcount--;<span class="comment">//读者数量减一</span></span><br><span class="line">    <span class="keyword">if</span>(rcount == <span class="number">0</span>)<span class="comment">//若为最后一个读者，则释放数据区</span></span><br><span class="line">        V(file);</span><br><span class="line">    V(rmutex);<span class="comment">//释放rmutex，允许其他读者访问rcount  </span></span><br><span class="line">&#125;</span><br><span class="line">writer()</span><br><span class="line">&#123;</span><br><span class="line">    P(wmutex);<span class="comment">//占用wmutex，准备修改wcount</span></span><br><span class="line">    <span class="keyword">if</span>(wcount == <span class="number">0</span>)<span class="comment">//若第一个为写者，则阻止后续读者进入</span></span><br><span class="line">        P(readable);</span><br><span class="line">    wcount++;<span class="comment">//写者数量加一</span></span><br><span class="line">    V(wmutex);<span class="comment">//释放wmutex，允许其他写者修改wmutex    </span></span><br><span class="line">    P(file);<span class="comment">//等待当前正在操作的读者或写者完成后，占用数据区</span></span><br><span class="line">    写操作</span><br><span class="line">    V(file);<span class="comment">//写完释放数据区 </span></span><br><span class="line">    P(wmutex);<span class="comment">//占用wmutex，准备修改wcount</span></span><br><span class="line">    wcount--;<span class="comment">//写者数量减一</span></span><br><span class="line">    <span class="keyword">if</span>(wcount == <span class="number">0</span>)<span class="comment">//若最后一个为写者，则允许读者进入</span></span><br><span class="line">        V(readable);</span><br><span class="line">    V(wmutex);<span class="comment">//释放wmutex，允许其他写者修改wmutex </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>哲学家进餐问题</p>
<p>问题描述</p>
<p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭，如图2-10所示。哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿的时候，才试图拿起左、 右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>
<p>问题分析</p>
<p>1) 关系分析。5名哲学家与左右邻居对其中间筷子的访问是互斥关系。</p>
<p> 2) 整理思路。显然这里有五个进程。本题的关键是如何让一个哲学家拿到左右两个筷子而不造成死锁或者饥饿现象。那么解决方法有两个，一个是让他们同时拿两个筷子；二是对每个哲学家的动作制定规则，避免饥饿或者死锁现象的发生。</p>
<p> 3) 信号量设置。定义互斥信号量数组Ch0PstiCk[5] = {l, 1, 1, 1, 1}用于对5个筷子的互斥访问。</p>
<p> 对哲学家按顺序从0～4编号，哲学家i左边的筷子的编号为i，哲学家右边的筷子的编号为(i+l)%5。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;; <span class="comment">//定义信号量数组chopstick[5],并初始化</span></span><br><span class="line">Pi()&#123;  <span class="comment">//i号哲学家的进程</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        P (chopstick[i] ) ; <span class="comment">//取左边筷子</span></span><br><span class="line">        P (chopstick[(i+<span class="number">1</span>) %<span class="number">5</span>] ) ；  <span class="comment">//取右边篌子</span></span><br><span class="line">        eat;  <span class="comment">//进餐</span></span><br><span class="line">        V(chopstick[i]) ; <span class="comment">//放回左边筷子</span></span><br><span class="line">        V(chopstick[(i+l)%<span class="number">5</span>]);  <span class="comment">//放回右边筷子</span></span><br><span class="line">        think;  <span class="comment">//思考</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了防止死锁的发生，可以对哲学家进程施加一些限制条件，比如至多允许四个哲学家同时进餐;仅当一个哲学家左右两边的筷子都可用时才允许他抓起筷子;对哲学家顺序编号，要求奇数号哲学家先抓左边的筷子，然后再转他右边的筷子，而偶数号哲学家刚好相反。正解制定规则如下：假设釆用第二种方法，当一个哲学家左右两边的筷子都可用时，才允许他抓起筷子。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>]=&#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">philosopher(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		思考;</span><br><span class="line">        想吃饭;</span><br><span class="line">		<span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>) <span class="comment">//偶数哲学家，先拿起右边的筷子后左边的。</span></span><br><span class="line">		&#123;</span><br><span class="line">			P (chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line">			P (chopstick[i]) ;</span><br><span class="line">			进餐</span><br><span class="line">			V (chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line">			V (chopstick[i]) ;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="comment">//奇数哲学家，先拿起左边的筷子后右边的。</span></span><br><span class="line">		&#123;</span><br><span class="line">			P (chopstick[i]) ;</span><br><span class="line">			P (chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line">			进餐</span><br><span class="line">			V (chopstick[i]) ;</span><br><span class="line">			V (chopstick[(i + <span class="number">1</span>)%<span class="number">5</span>]) ;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理发师问题</p>
<p>问题描述</p>
<p>一个理发店由一个有几张椅子的等待室和一个放有一张理发椅的理发室组成。<br>     1． 若没有要理发的顾客，则理发师去睡觉；<br>     2． 若一顾客进入理发店，理发师正在为别人理发，且等待室有空椅子，则该顾客就找张椅子按顺序坐下；<br>     3． 若一顾客进入理发店，理发师在睡觉，则叫醒理发师为该顾客理发；<br>     4． 若一顾客进入理发店且所有椅子都被占用了，则该顾客就离开。<br>问题分析<br>引入3个信号量和一个控制变量：<br>    1)控制变量waiting用来记录等候理发的顾客数，初值均为0;<br>    2)信号量customers用来记录等候理发的顾客数，并用作阻塞理发师进程，初值为0;<br>    3)信号量barbers用来记录正在等候顾客的理发师数，并用作阻塞顾客进程，初值为0（刚开始时理发师在睡觉,所以理发师这个资源数目为0）;<br>    4)信号量mutex用于互斥，初值为1. </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">萝卜坑</span><br></pre></td></tr></table></figure>

<h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><ul>
<li>定义了一个数据结构和能为并发进程所执行的一组操作</li>
<li>把分散在各个进程中互斥访问公共变量的临界区集中起来，提供对他们的保护</li>
<li>局部于管程的数据只能被局部与管程的过程访问</li>
<li>一个进程只有调用管程内的过程才能进入管程访问共享数据</li>
<li>每次仅允许一个进程在管程内执行某个过程</li>
</ul>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><ul>
<li>参与死锁的进程至少两个</li>
<li>每个参与死锁的进程均等待资源</li>
<li>参与死锁的进程至少有两个进程占有资源</li>
<li>死锁进程是系统中当前进程集合的一个子集</li>
</ul>
<p>产生原因：资源竞争</p>
<h3 id="资源的分类"><a href="#资源的分类" class="headerlink" title="资源的分类"></a>资源的分类</h3><ul>
<li>不可剥夺资源：只有当进程不再使用时才释放，其他进程不可强行剥夺</li>
<li>可剥夺资源：另一个进程可以强行把该资源剥夺归己用</li>
</ul>
<h3 id="必要条件"><a href="#必要条件" class="headerlink" title="必要条件"></a>必要条件</h3><ul>
<li>互斥条件：一段时间内某个资源仅为一个进程拥有</li>
<li>不可剥夺条件：未使用完毕时，其他资源不可剥夺</li>
<li>请求与保持条件：每次申请等待新资源，继续占有原来拥有的资源</li>
<li>环路等待条件：一个进程已经获取的资源为下一个进程所请求</li>
</ul>
<h3 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h3><p>鸵鸟算法：视而不见</p>
<p>死锁的预防</p>
<ul>
<li>互斥条件：允许多进程同时访问</li>
<li>不可剥夺条件：一个进程新资源不能立即满足，需要释放已有资源</li>
<li>请求与保持条件：预先静态分配，新资源未产生前不给予使用</li>
<li>环路等待条件：采用有序资源分配法</li>
</ul>
<p>死锁的避免</p>
<ul>
<li>安全状态与不安全状态：分配资源时先计算资源使用的安全性</li>
<li>银行家算法<ul>
<li>可利用资源相邻：Available</li>
<li>最大需求矩阵：Max</li>
<li>分配矩阵：Allocation</li>
<li>需求矩阵：Need</li>
<li>Need[i][j]=Max[i][j]-Allocation[i][j]</li>
</ul>
</li>
</ul>
<p>死锁的检测与解除</p>
<ul>
<li><p>资源分配图（圆圈代表进程，方框标识每类资源）</p>
<p><img src="/2020/03/16/osProcessManager/ziyuanfenpei.jpg" alt="图片-资源分配图"></p>
</li>
<li><p>死锁检测算法</p>
<p><img src="/2020/03/16/osProcessManager/sisuojiance.jpg" alt="图片-死锁检测算法"></p>
</li>
</ul>
<p>死锁与饿死</p>
<ul>
<li>死锁的进程都处于等待状态，忙时等待的进程并非处于等待状态又可能饿死</li>
<li>死锁进程不会释放资源，饿死进程释放不会分配给自己的资源</li>
<li>死锁进程发生循环等待，饿死进程不会</li>
<li>死锁涉及多个进程，饿死进程可能只有一个</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤操作系统</p>
<p><a href="c.biancheng.net/cpp/html/2600.html">C语言中文网</a></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>processManager</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统基本概念</title>
    <url>/2020/03/16/osBasicConcept/</url>
    <content><![CDATA[<h1 id="观点"><a href="#观点" class="headerlink" title="观点"></a>观点</h1><table>
<thead>
<tr>
<th>观点分类</th>
<th>功能</th>
<th>举例</th>
</tr>
</thead>
<tbody><tr>
<td>用户观点</td>
<td>根部不同计算机设计的不同操作系统，目的是方便用户使用</td>
<td>主机、显示器、键盘</td>
</tr>
<tr>
<td>系统观点</td>
<td>资源管理程序，目的是进行处理器管理、存储器管理、设备管理、信息管理</td>
<td>存储器、处理器、外设和信息</td>
</tr>
<tr>
<td>进程观点</td>
<td>若干可以独立运行的程序和一个对这些程序进行协调的核心所组成</td>
<td>用户进程、系统进程</td>
</tr>
<tr>
<td>虚拟机观点</td>
<td>操作系统为用户使用计算机提供了许多服务功能和良好的工作环境</td>
<td></td>
</tr>
</tbody></table>
<h1 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h1><table>
<thead>
<tr>
<th>特征</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>并发性</td>
<td>并行性指两个或多个事件在同一时刻发生，并发性指两个或多个事件在同一时间间隔内发生</td>
</tr>
<tr>
<td>共享性</td>
<td>根据同一时刻是否可以被多人使用，是互斥共享，可以同时访问</td>
</tr>
<tr>
<td>虚拟性</td>
<td>把一个物理上的实体变为若干个逻辑上的对应物，如多道程序设计技术</td>
</tr>
<tr>
<td>异步性</td>
<td>时间不同步</td>
</tr>
</tbody></table>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><p>裸机上的第一层软件，提供计算机用户与计算机硬件系统之间的接口，可以有效的控制和管理计算机系统中的各种硬件和软件资源，便于合理的组织计算机系统工作流程。</p>
<p>五大基本功能</p>
<ul>
<li><p>处理器（进程）管理</p>
</li>
<li><p>存储器（内存）管理</p>
</li>
<li><p>文件管理</p>
</li>
<li><p>设备管理</p>
</li>
<li><p>用户接口</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>用户命令接口</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>联机命令接口又称交互式命令接口</td>
<td>分时操作系统：用户输入命令需等待处理完成才能输入下一条命令</td>
</tr>
<tr>
<td>脱机命令接口又称批处理命令接口</td>
<td>适用于批处理系统：由一组作业控制命令组成，用户期间不能干预 程序接口（系统调用） 图形接口</td>
</tr>
</tbody></table>
<h1 id="发展"><a href="#发展" class="headerlink" title="发展"></a>发展</h1><h2 id="无操作系统阶段"><a href="#无操作系统阶段" class="headerlink" title="无操作系统阶段"></a>无操作系统阶段</h2><ul>
<li>手工输入输出</li>
<li>脱机输入、输出技术</li>
</ul>
<h2 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h2><p>属于操作系统前身，具有自动性、顺序性、单道性。</p>
<h2 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h2><ul>
<li>多道</li>
<li>宏观上并行</li>
<li>微观上串行</li>
<li>如何分配处理器，如何回收，如何利用率高</li>
<li>如何为每道程序分配必要的内存空间，各得其所又不相互干扰，不因其他程序异常而受影响</li>
<li>系统中可能有多种类型的I/O设备共多道程序共享，应如何分配这些I/O设备，如何做到既方便用户对设备的使用，又能提高设备利用率</li>
<li>怎样保证所存放大量程序既便于用户使用，又保证数据的安全性和一致性</li>
<li>对于不同类型的作业（计算型、I\O型、有的重要紧迫，有的需要及时响应）如何组织</li>
</ul>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><h2 id="批处理操作系统"><a href="#批处理操作系统" class="headerlink" title="批处理操作系统"></a>批处理操作系统</h2><ul>
<li>脱机使用，获得结果前不进行交互</li>
<li>成批处理：作业分批提交，监督程序负责每批作业间的自动调度</li>
<li>多道程序运行：选取多个作业调入内存并组织运行</li>
</ul>
<h2 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h2><ul>
<li>实现方法<ul>
<li>简单分时操作系统，每个作业运行一个时间片，轮流从外存调入内存</li>
<li>具有前台和后台的分时操作系统，前台存放时间片调入调出的作业流，当前台正在调入调出，或无调入调出时，在运行后台，给它分配更长时间</li>
<li>多道分时操作系统，在内存中排队，轮流使用</li>
</ul>
</li>
<li>特征：多路性、交互性、独占性、及时性</li>
</ul>
<h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><ul>
<li><p>实时控制系统：以计算机为中心的生产过程控制系统</p>
</li>
<li><p>实时信息处理系统：接受从远程端发来的信息请求</p>
</li>
<li><p>嵌入式操作系统</p>
</li>
<li><p>集群系统：两个或多个独立的系统耦合起来</p>
</li>
<li><p>网络操作系统：将物理上分散的具有自制功能的多个计算机系统互连起来</p>
</li>
<li><p>分布式操作系统：多个分散的处理单元经互联网连接而成</p>
</li>
</ul>
<h1 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h1><h2 id="态"><a href="#态" class="headerlink" title="态"></a>态</h2><table>
<thead>
<tr>
<th>态</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>核心态（管态、系统态）</td>
<td>具有较高的特权，能执行包括特权指令的一切指令</td>
</tr>
<tr>
<td>用户态（目态）</td>
<td>只能执行规定指令</td>
</tr>
</tbody></table>
<p>核心态具有较高的特权，能执行包括特权指令的一切指令</p>
<ul>
<li>特权指令：I/O指令、中断屏蔽指令、清内存指令、存储保护指令、设置时钟指令</li>
<li>内核指令<ul>
<li>时钟管理：通过时钟管理实现进程的切换（如时间片轮转调度）</li>
<li>中断机制</li>
<li>源语（一些关闭中断的小程序）<ul>
<li>处于操作系统底层，最接近硬件部分</li>
<li>具有原子性</li>
<li>运行时间短，调用频繁</li>
</ul>
</li>
<li>系统控制的数据结构及处理</li>
</ul>
</li>
</ul>
<h2 id="中断与异常"><a href="#中断与异常" class="headerlink" title="中断与异常"></a>中断与异常</h2><table>
<thead>
<tr>
<th>中断与异常</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>中断</td>
<td>内中断</td>
</tr>
<tr>
<td>异常</td>
<td>外中断</td>
</tr>
</tbody></table>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><ul>
<li>程序接口或应用编程接口</li>
<li>准备并传递系统调用所需参数</li>
<li>通过陷入指令进入操作系统的系统内核</li>
<li>从用户态进入内核态执行相应的系统函数</li>
<li>将处理结果返回用户进程，从内核态返回用户态</li>
</ul>
<h1 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h1><table>
<thead>
<tr>
<th>体系结构</th>
<th>功能</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>模块组合结构</td>
<td>每个模块根据要完成的功能划分</td>
<td>结构紧密、接口简单直接、系统效率高</td>
<td>不容易把握模块独立性</td>
</tr>
<tr>
<td>层次结构</td>
<td>使模块调用从无序到有序，模块间只存在单向调用和单向依赖</td>
<td>模块间组织和依赖关系清晰明了</td>
<td>无法进行有效的分层</td>
</tr>
<tr>
<td>微内核结构</td>
<td>只在内核留下基本功能</td>
<td>服务独立的运行在用户进程中，失败也不会引起整个进程崩溃</td>
<td>效率低，微内核本身成为瓶颈</td>
</tr>
</tbody></table>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤操作系统</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>basicConcept</tag>
      </tags>
  </entry>
  <entry>
    <title>应用层相关知识点</title>
    <url>/2020/03/15/netApplicationLayer/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>用户对用户</li>
<li>任务：提供系统与用户的接口</li>
<li>功能：文件传输、访问和管理、电子邮件服务</li>
<li>协议：FTP、SMTP、POP3、HTTP</li>
</ul>
<h1 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h1><table>
<thead>
<tr>
<th>模型</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>C/S（客户/服务器模型）</td>
<td>各计算机地位不平等，网络管理工作有少数服务器承担，可扩展性不佳。</td>
</tr>
<tr>
<td>P2P</td>
<td>计算机任务可以分配到个节点上，系统可扩展性好，网络更加健壮。</td>
</tr>
</tbody></table>
<h1 id="DNS系统"><a href="#DNS系统" class="headerlink" title="DNS系统"></a>DNS系统</h1><h2 id="层次域名空间"><a href="#层次域名空间" class="headerlink" title="层次域名空间"></a>层次域名空间</h2><p>采用了层次树状结构的命名法，即域名。</p>
<p>结构：。。。.二级域名.一级域名.顶级域名</p>
<table>
<thead>
<tr>
<th>顶级域名</th>
<th>内容</th>
</tr>
</thead>
<tbody><tr>
<td>国家顶级域名</td>
<td>.cn中国 .us美国 .uk英国</td>
</tr>
<tr>
<td>通用顶级域名</td>
<td>.com公司和企业 .net网络服务机构 .org非营利向组织 .edu美国专用的教育机构 .gov美国专用的政府部门 .mil美国专用的军事部门 .int国际组织</td>
</tr>
<tr>
<td>基础结构顶级域名arpa</td>
<td>用于反向域名解析，又称反向域名</td>
</tr>
</tbody></table>
<h2 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h2><table>
<thead>
<tr>
<th>域名服务器</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>根域名服务器</td>
<td>是最重要的域名服务器，所有根域名服务器都知道顶级域名服务器的域名和IP地址，本地域名服务器只要无法解析，就求助于根域名服务器，告诉本地域名服务器上一级域名服务器的地址。</td>
</tr>
<tr>
<td>顶级域名服务器</td>
<td>管辖在该顶级域名服务器注册的所有二级服务器，当收到dns请求时，给出结果或者下一步请求的域名服务器的地址。</td>
</tr>
<tr>
<td>权限域名服务器（授权域名服务器）</td>
<td>负责一个区的域名服务，给出结果或下一步应当访问的权限域名服务器。</td>
</tr>
<tr>
<td>本地域名服务器</td>
<td>非常重要，主机发送dns请求时就会将查询请求报文发送给本地域名服务器。</td>
</tr>
</tbody></table>
<h2 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h2><table>
<thead>
<tr>
<th>分类</th>
<th>解析过程</th>
</tr>
</thead>
<tbody><tr>
<td>迭代查询</td>
<td>根域名服务器收到查询请求，要么给出查询结果，要么告诉本地域名服务器下一步向哪个域名服务器进行查询。</td>
</tr>
<tr>
<td>递归查询</td>
<td>本地域名服务器只请求一次，后面几次都是在其他几个域名服务器之间进行的。</td>
</tr>
</tbody></table>
<h1 id="FTP文件传输"><a href="#FTP文件传输" class="headerlink" title="FTP文件传输"></a>FTP文件传输</h1><p>工作原理</p>
<ul>
<li>TCP可靠传输，C/S模型</li>
<li>打开21端口</li>
<li>等待客户进程发出请求</li>
<li>启动从属程序处理请求，从属程序可能会创造一些新的进程</li>
<li>主程序等待其他客户进程发出请求</li>
<li>主程序与从属程序并发进行</li>
</ul>
<table>
<thead>
<tr>
<th>连接分类</th>
<th>端口</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>控制连接</td>
<td>21</td>
<td>客户端通过这个连接发送各种操作请求</td>
</tr>
<tr>
<td>数据连接</td>
<td>20</td>
<td>在文件传输请求后创建数据传送和接收进程，并在传输完成后关闭</td>
</tr>
</tbody></table>
<h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><h2 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h2><ul>
<li>用户代理<ul>
<li>用户与电子邮件系统的接口，如outlook</li>
</ul>
</li>
<li>邮件服务器<ul>
<li>发送接收邮件，报告邮件传输情况</li>
</ul>
</li>
<li>电子邮件使用协议<ul>
<li>SMTP,POP3</li>
</ul>
</li>
</ul>
<h2 id="发送接收过程"><a href="#发送接收过程" class="headerlink" title="发送接收过程"></a>发送接收过程</h2><ul>
<li>发件人调用用户代理来编辑要发送的邮件</li>
<li>发件人通过用户代理把邮件传送给发送端邮件服务器<ul>
<li>客户端建立TCP连接服务器</li>
<li>服务器发送身份信息，确认连接已经建立</li>
<li>客户端发送身份信息，服务器确认收到</li>
<li>客户端发送邮件接收者地址，服务器确认收到</li>
<li>客户端发送邮件发送者地址，服务器确认收到</li>
<li>客户端请求发送邮件内容，服务器确认准备好</li>
<li>客户端发送邮件内容，最有以一个仅包含.的行结束，服务器发回数据已收到的确认</li>
</ul>
</li>
<li>邮件服务器将邮件放入邮件缓存队列，等待发送</li>
<li>发送端的SMTP进程发现邮件缓存中有邮件，就向接收端SMTP进程建立TCP连接</li>
<li>TCP建立后开始传输邮件，完成后TCP关闭连接</li>
<li>接收端SMTP将邮件放入收件人邮箱</li>
<li>收件人调用用户代理，使用POP3(IMAP)从邮箱中取回<ul>
<li>客户端建立TCP连接至服务器</li>
<li>服务器发送身份信息，确认链接已经建立</li>
<li>客户端发送USER命令+用户名，服务器确认收到</li>
<li>客户端发送PASS命令+用户密码，服务器确认收到</li>
<li>客户端发送LIST命令，服务器返回当前邮件箱的邮件个数列表</li>
<li>客户端发送RETR命令，服务器发回相应的邮件内容</li>
<li>客户端接受完邮件后，选择是否发送DELE命令+邮件编号，通知服务器从邮箱中删除相应的邮件</li>
</ul>
</li>
</ul>
<h2 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h2><ul>
<li>To:收件人邮箱地址</li>
<li>Subject：邮件主题</li>
<li>收件人邮箱名@邮箱所在主机域名</li>
<li>MIME<ul>
<li>SMTP只限于传送一定长度的7为ASCII编</li>
<li>MIME意图继续使用目前的RFC 822格式但增加邮件主体的结构，定义传送非ASCII码规则<ul>
<li>quoted-printable<ul>
<li>用=加两个十六进制字符，表示非ASCIII</li>
<li>如，汉字系统两字代码为11000……011，共32位，就表示为=CF=B5=CD=B3</li>
</ul>
</li>
<li>base64<ul>
<li>共64个值，字母大小写，+ / == =</li>
<li>将24位二进制代码划分四个六位组，转化为对应的base64编码，并以这些字符的二进制ASCII编码发送</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><table>
<thead>
<tr>
<th>协议</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SMTP简单邮件传输协议</td>
<td>端口号25，TCP连接，连接建立/邮件发送/连接释放</td>
</tr>
<tr>
<td>POP3邮局协议版本3</td>
<td>在用户计算机中运行POP客户程序，在ISP服务器中运行POP服务程序，用户从POP服务器读取邮件，POP服务器就将该邮件删去。</td>
</tr>
</tbody></table>
<h1 id="WWW万维网"><a href="#WWW万维网" class="headerlink" title="WWW万维网"></a>WWW万维网</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ul>
<li>一个大规模联机式的信息贮藏所</li>
<li>用统一资源定位符来标识URL的各种文档，&lt;协议&gt;://&lt;主机&gt;:&lt;端口号&gt;/&lt;路径&gt;</li>
</ul>
<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ul>
<li>Web用户使用浏览器指定URL与Web服务器建立连接，并发送浏览请求</li>
<li>Web服务器吧URL转化为文件路径，并返回信息给Web浏览器</li>
<li>通信完成，关闭连接</li>
</ul>
<h2 id="HTTP超文本传送协议"><a href="#HTTP超文本传送协议" class="headerlink" title="HTTP超文本传送协议"></a>HTTP超文本传送协议</h2><p>端口80，是TCP可靠连接</p>
<p>报文：</p>
<ul>
<li>请求报文：客户向服务器发送请求报文</li>
<li>响应报文：从服务器到客户的回答</li>
<li>内容<ul>
<li>开始行，区别请求报文(请求行，方法、目标URL)和响应报文(状态行，版本、状态码)</li>
<li>首部行，说明浏览器，服务器，报文主体的一些信息</li>
<li>实体主体，不一定有</li>
</ul>
</li>
<li>方法<ul>
<li>GET：请求读取由URL所标识的信息</li>
<li>HEAD：读取由URL所标识的信息首部</li>
<li>POST：给服务器添加信息</li>
<li>CONNECT：用于代理服务器</li>
</ul>
</li>
<li>工作方式<ul>
<li>非持久连接：每个网页元素都需要单独建立一次TCP三次握手</li>
<li>持久连接：发送响应后仍保持这条连接</li>
</ul>
</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤计算机网络</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>applicationLayer</tag>
      </tags>
  </entry>
  <entry>
    <title>传输层相关知识点</title>
    <url>/2020/03/15/netTransportLayer/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>应用对应用、进程对进程</li>
<li>单位：(segments段)报文段TCP、用户数据报UDP</li>
<li>任务：负责主机中两个进程之间的通信</li>
<li>功能<ul>
<li>为端到端连接提供可靠的传输服务</li>
<li>为端到端连接提供流量控制、差错控制、服务质量等管理服务</li>
<li>提供应用进程间的逻辑通信</li>
<li>差错检测</li>
<li>提供无连接和面向连接的服务</li>
<li>复用和分用</li>
<li>单独TCP的有：连接管理、流量控制与拥塞控制</li>
</ul>
</li>
</ul>
<h1 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h1><p>传输层按端口号寻址，类似数据链路层按mac，网络层按ip</p>
<p>熟知端口号：0~1023</p>
<table>
<thead>
<tr>
<th>应用</th>
<th>端口</th>
</tr>
</thead>
<tbody><tr>
<td>FTP</td>
<td>21,20</td>
</tr>
<tr>
<td>TELNET</td>
<td>23</td>
</tr>
<tr>
<td>SMTP</td>
<td>25</td>
</tr>
<tr>
<td>DNS</td>
<td>53</td>
</tr>
<tr>
<td>TFTP</td>
<td>69</td>
</tr>
<tr>
<td>HTTP</td>
<td>80</td>
</tr>
<tr>
<td>SNMP</td>
<td>161</td>
</tr>
</tbody></table>
<p>登记端口号：1024~49151（为没有熟知端口号的程序使用、须在IANA登记）</p>
<p>客户端端口或短暂端口：49152~65535</p>
<p>套接字：（主机IP地址，端口号）唯一标识了网络中的某台主机上的某个应用进程</p>
<h1 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul>
<li>传输数据前无需建立连接，数据到达后也无需确认</li>
<li>不可靠交付</li>
<li>报文头部短，传输开销小，时延较短</li>
<li>不需维持复杂的连接状态表</li>
<li>用户数据报只有8个字节的首部开销</li>
<li>网络拥塞不会使源主机的发送速率降低</li>
<li>支持一对一、一对多、多对多、多对一的交互通信</li>
</ul>
<h2 id="数据包组成"><a href="#数据包组成" class="headerlink" title="数据包组成"></a>数据包组成</h2><p>源端口、目的端口、长度、校验和</p>
<h2 id="UDP校验"><a href="#UDP校验" class="headerlink" title="UDP校验"></a>UDP校验</h2><ul>
<li>只提供差错校验，计算校验时在用户数据报之前加上12B的伪首部</li>
<li>伪首部包括源IP地址字段、目的IP地址字段、全0字段、协议字段、UDP长度字段</li>
<li>伪首部只用于验证校验和，既不向下传送，也不向上传递</li>
<li>二进制反码运算求和，无差错时其结果全为1<ul>
<li>从低位到高位逐列运算</li>
<li>0+0=0 1+0=1 1+1=0进1</li>
<li>最高位产生进位，最后结果加1</li>
</ul>
</li>
</ul>
<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h2><ul>
<li>面向连接，不提供广播或多播服务</li>
<li>可靠交付</li>
<li>报文段头部长，传输开销大</li>
</ul>
<h2 id="报文段组成"><a href="#报文段组成" class="headerlink" title="报文段组成"></a>报文段组成</h2><p><img src="/2020/03/15/netTransportLayer/baowenduan.png" alt="baowenduan"></p>
<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><ul>
<li>两个套接字：{socket1，socket2}={(IP1:port1),(IP2:port2)}</li>
<li>三次握手</li>
<li>四次释放</li>
</ul>
<h2 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h2><p>TCP数据编号与确认</p>
<ul>
<li>将传送的报文看成是字节组成的数据流，每个字节对应一个序号</li>
<li>建立连接时双方要商定初始序号，报文首部中的序号字段数值，表示该报文段中的数据部分的第一个 字节的序号</li>
<li>确认是对接收到的数据最高序号表示确认</li>
<li>接收端返回的序号是已收到的数据最高序号加1，表示接收端期望下次收到的数据中第一个数据字节的序号</li>
</ul>
<p>TCP的重传机制</p>
<ul>
<li>每发送一个报文段，就对设置一次计时器，如果规定时间内没有收到确认，就重传该报文</li>
<li>计算超时计时器的重传时间<ul>
<li>RTT<ul>
<li>记录每个报文段发出的时间以及收到相应的确认报文段的时间，这两个时间之差就是报文段的往返时延</li>
<li>将各报文段的往返时延样本加权平均，就得出报文段的平均往返时延RTT</li>
<li>每侧量到一个新的往返时延样本，就按下式重新计算一次平均往返时延RTT=(1-a)<em>(旧的RTT)+a</em>(新的往返时延样本)</li>
<li>超时重传时间ROT:新的(ROT)=b*(RTT)</li>
</ul>
</li>
<li>Karn<ul>
<li>新的(ROT)=c*旧的(ROT)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><ul>
<li>利用滑动窗口控制实现流量控制</li>
<li>TCP为每个报文设有一个持续计数器，只要收到对方的零窗口通知就启动持续计时器，时间到就发送一个零窗口探测报文段，对方在探测这个报文段时就给出了现在的窗口值，若是零就重新计时，若不是就打破死锁僵局</li>
<li>三种机制<ul>
<li>TCP维持一个变量，等于最大报文段长度MSS，只要缓存中存放的数据达到MSS字节时，就组装成一个TCP报文段发送出去</li>
<li>由发送方应用进程指名要求发送报文段，即TCP的推动Push操作</li>
<li>发送方的一个计时器期限到了，就把已有的缓存数据装入报文段，但长度不超过MSS并发送出去</li>
</ul>
</li>
</ul>
<p><img src="/2020/03/15/netTransportLayer/liuliangkongzhi.jpg" alt="图片-流量控制"></p>
<h2 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h2><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul>
<li>目的：使网络能够承受现有的网络负荷</li>
<li>是一个全局过程，涉及所有主机路由器以及与降低网络传输性能有关的所有因素</li>
<li>指给定发送端和接收端之间的点对点通信量的控制</li>
<li>分组丢失是网络发生拥塞的征兆而不是原因</li>
<li>拥塞本身成为引起网络性能恶化甚至发生死锁的原因</li>
</ul>
<h3 id="控制分类"><a href="#控制分类" class="headerlink" title="控制分类"></a>控制分类</h3><table>
<thead>
<tr>
<th>控制分类</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>闭环控制</td>
<td>事先将有关发生拥塞的因素考虑周到，力求网络在工作中不发生拥塞</td>
</tr>
<tr>
<td>开环控制</td>
<td>监测网络系统以便检测到拥塞何时何处发生、将拥塞发生的信息传送到可采取行动的地方、调整网络的运行以解决问题</td>
</tr>
</tbody></table>
<h3 id="四种算法"><a href="#四种算法" class="headerlink" title="四种算法"></a>四种算法</h3><p>TCP要求发送端维护两个窗口</p>
<ul>
<li>接收端窗口rwnd：接收端根据其目前接受缓存大小所需诺的最新窗口值，反映了接收端的容量，有接收端将其放在报文首部的字段通知发送端</li>
<li>拥塞窗口cwnd：发送端根据自己估计的网络拥塞程度而设置的窗口值，反映了网络的当前容量</li>
<li>rwnd&lt;cwnd时：发送窗口的上限值是接受方的接受能力限制发送窗口的最大值</li>
<li>rwnd&gt;cwnd时：发送窗口的上限值是网络拥塞限制发送窗口的最大值</li>
</ul>
<h4 id="慢开始算法"><a href="#慢开始算法" class="headerlink" title="慢开始算法"></a>慢开始算法</h4><ul>
<li><p>开始发送报文段时先设置cwnd=1，即设置最大报文段长度MSS的数值</p>
</li>
<li><p>每收到一个对新的报文段的确认后，将拥塞窗口加1，即增加一个MSS的数值</p>
</li>
</ul>
<p><img src="/2020/03/15/netTransportLayer/mankaishi.jpg" alt="图片-慢开始算法"></p>
<h4 id="拥塞避免算法"><a href="#拥塞避免算法" class="headerlink" title="拥塞避免算法"></a>拥塞避免算法</h4><ul>
<li><p>慢开始门限ssthresh</p>
</li>
<li><p>TCP连接进行初始化时，拥塞窗口cwnd=1，慢开始门限初始值设为16个字节ssthresh=16，发送端不能超过拥塞窗口cwnd和接收端窗口rwnd的最小值</p>
</li>
<li><p>执行慢开始算法，cwnd=1，发送第一个报文段M0</p>
</li>
<li><p>发送端每收到一个确认，cwnd++，cwnd=2，发送端接着发送M1M2</p>
</li>
<li><p>发送端收到两个确认，cwnd+=2，cwnd=4，发送端接着可以发四个M</p>
</li>
<li><p>如此按指数增长</p>
</li>
<li><p>当cwnd==ssthresh时，改为执行拥塞避免算法 ，是线性增长的</p>
</li>
<li><p>假定拥塞窗口增长到24时，网络出现超时，表明网络拥塞了</p>
</li>
<li><p>ssthresh变为发送窗口数值的一半，为12，cwnd=1，并执行慢开始算法</p>
</li>
<li><p>当cwnd==ssthresh时执行拥塞避免算法</p>
</li>
</ul>
<p><img src="/2020/03/15/netTransportLayer/yongsebimian.jpg" alt="图片-拥塞避免"></p>
<h4 id="快重传算法"><a href="#快重传算法" class="headerlink" title="快重传算法"></a>快重传算法</h4><ul>
<li><p>要求接收方每收到一个失序的报文段后就立即发出重复确认</p>
</li>
<li><p>只要发送方收到三个重复确认就应当立即重传对方尚未收到的报文段</p>
</li>
</ul>
<p><img src="/2020/03/15/netTransportLayer/kuaichongchuan.jpg" alt="图片-快重传"></p>
<h4 id="快恢复算法"><a href="#快恢复算法" class="headerlink" title="快恢复算法"></a>快恢复算法</h4><ul>
<li><p>当发送方收到3个重复的确认时，就执行乘法减小，把慢开始门限ssthresh设置为当前拥塞窗口的一半，接下去不执行慢开始算法</p>
</li>
<li><p>由于发送方现在认为网络很可能没有发生拥塞，所以不执行慢开始算法，而是将ssthresh设置为当前拥塞窗口的一半，然后开始执行拥塞避免算法</p>
</li>
</ul>
<p><img src="/2020/03/15/netTransportLayer/kuaihuifu.jpg" alt="图片-快恢复"></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤计算机网络</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>transportLayer</tag>
      </tags>
  </entry>
  <entry>
    <title>网络层相关知识点</title>
    <url>/2020/03/15/netNetworkLayer/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>主机对主机</li>
<li>单位：Packets包：数据报</li>
<li>硬件：路由器</li>
<li>任务：将传输层传下来的报文段封装成分组，选择适当的路由，是传输层传下来的分组能够交付到目的主机</li>
<li>功能<ul>
<li>为传输层提供服务</li>
<li>组包和拆包</li>
<li>路由选择：确定进来的分组应该被传送到哪一条路线上</li>
<li>分组转发：将IP数据报从适合的端口转发出去</li>
<li>拥塞控制：开环控制、闭环控制</li>
<li>异构网络互连：各种网络协议不同，但是让用户看起来是一个整体</li>
</ul>
</li>
<li>协议：ICMP、ARP、RARP、IP、IGMP</li>
</ul>
<h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><h3 id="数据报"><a href="#数据报" class="headerlink" title="数据报"></a>数据报</h3><ul>
<li>总长度：数据包的总长是MAC地址数据部分，1500B，如果超出则分片</li>
<li>标志：MF合并数据报、DF=1不可以分片，当数据报过大时，返回ICMP告知最大传输单位、DF=0可以分片传输</li>
</ul>
<h3 id="地址分类"><a href="#地址分类" class="headerlink" title="地址分类"></a>地址分类</h3><table>
<thead>
<tr>
<th>类别</th>
<th>地址</th>
<th>私有地址</th>
</tr>
</thead>
<tbody><tr>
<td>网络号</td>
<td>0.0.0.0</td>
<td>\</td>
</tr>
<tr>
<td>广播地址</td>
<td>255.255.255.255</td>
<td>\</td>
</tr>
<tr>
<td>A类</td>
<td>1.0.0.0~126.255.255.255</td>
<td>10.0.0.0~10.255.255.255</td>
</tr>
<tr>
<td>B类</td>
<td>128.1.0.0~191.255.255.255</td>
<td>172.16.0.0~172.31.255.255</td>
</tr>
<tr>
<td>C类</td>
<td>192.0.1.0~223.255.255.255</td>
<td>192.168.0.0~192.168.255.255</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>特殊地址</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>网络地址</td>
<td></td>
</tr>
<tr>
<td>直接广播地址</td>
<td>主机号全为1，该组所有主机都会收到，只能做目的地址</td>
</tr>
<tr>
<td>受限广播地址</td>
<td>全1，用于定义当前网络</td>
</tr>
<tr>
<td>这个网络上的这个主机</td>
<td>全0，主机为了发现自己的IP地址，使用全0作为源地址，全1作为目的地址</td>
</tr>
<tr>
<td>这个网络上的特定主机</td>
<td>用于某个主机向同一网络上的其他主机发送报文</td>
</tr>
<tr>
<td>回环地址</td>
<td>127开头，用来测试机器的软件，客户机进程用回环地址给同样机器上的服务器进程发送请求</td>
</tr>
</tbody></table>
<h3 id="NAT-内外网转换"><a href="#NAT-内外网转换" class="headerlink" title="NAT(内外网转换)"></a>NAT(内外网转换)</h3><ul>
<li>节省IP地址</li>
<li>隐藏内部真实IP</li>
<li>TCP负载均衡</li>
<li>两网合并，解决内网地址冲突问题</li>
</ul>
<h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><p>子网划分</p>
<ul>
<li>由两级变为三级</li>
<li>IP地址：{&lt;网络号&gt;,&lt;子网号&gt;,&lt;主机号&gt;}</li>
</ul>
<p>子网掩码</p>
<ul>
<li>用子网掩码表示网络号长度</li>
</ul>
<h3 id="CIDR无分类编址"><a href="#CIDR无分类编址" class="headerlink" title="CIDR无分类编址"></a>CIDR无分类编址</h3><p>IP地址：{&lt;网络前缀&gt;,&lt;主机号&gt;}，类似于子网掩码</p>
<h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><ul>
<li>解决同一局域网主机或路由器IP地址和硬件地址的映射问题</li>
<li>每个主机中都有ARP高速缓存，用来存放所有局域网上的各主机和路由器的IP地址到硬件地址的映射表</li>
<li>ARP请求分组是广播发送的，响应分组是普通的单播</li>
<li>四种情况<ul>
<li>发送方是主机or路由器，要把IP数据报发送到本网络上的主机，这时用ARP找到目的主机的硬件地址</li>
<li>发送方是主机or路由器，要把IP数据报发送到另一个网络上的主机，这时用ARP找到本网络上的一个路由器的硬件地址，然后交给路由器</li>
</ul>
</li>
</ul>
<h3 id="DHCP动态主机配置协议"><a href="#DHCP动态主机配置协议" class="headerlink" title="DHCP动态主机配置协议"></a>DHCP动态主机配置协议</h3><ul>
<li>动态分配IP地址</li>
<li>允许一台计算机加入新的网络获取IP地址，不需要手工参与</li>
<li>是应用层协议，使用UDP传输</li>
<li>分配的IP地址是临时的，只能在一段时间内（租用期）使用</li>
</ul>
<p>过程</p>
<ul>
<li>DHCP客户机广播“DHCP发现”消息，试图找到网络中的DHCP服务器，服务器获取一个IP地址</li>
<li>DHCP服务器收到“DHCP发现”消息，就向网络提供“DHCP提供”消息，其中包括提供DHCP客户机的IP地址和相关配置信息</li>
<li>DHCP客户机收到“DHCP提供”消息，如果接收DHCP提供的相关参数，则广播“DHCP请求”消息向DHCP服务器请求提供IP地址</li>
<li>DHCP服务器广播“DHCP确认”消息，分配IP地址给DHCP客户机</li>
<li>当有多个客户机请求时，DHCP通常选择最先到达的信息</li>
</ul>
<h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><p>差错报告报文</p>
<table>
<thead>
<tr>
<th>差错报告报文</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>终点不可达</td>
<td>路由或主机不能交付数据时，使源点知道终点不可达</td>
</tr>
<tr>
<td>源站抑制</td>
<td>路由或主机由于拥塞而丢弃数据报时，向源点发送，使源点发送速率变慢</td>
</tr>
<tr>
<td>时间超时</td>
<td>当IP分组TTL值被减为0后，路由器除了要丢弃该分组还要向源点发送时间超时；当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，向源点发送时间超时</td>
</tr>
<tr>
<td>参数问题</td>
<td>路由器或目的主机收到的数据报的首部中有字段的值不正确时，就丢弃该数据报，并向源点发送，现在一般不发</td>
</tr>
<tr>
<td>改变路由</td>
<td>重定向，路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给其他的路由器</td>
</tr>
</tbody></table>
<p>询问报文</p>
<ul>
<li>有回送请求和回答报文</li>
<li>时间戳请求和回答报文</li>
<li>掩码地址请求和回答报文</li>
<li>路由器询问和通告报文</li>
</ul>
<p>不发送报告的几种情况</p>
<ul>
<li>对ICMP差错报告报文不再发送ICMP差错报告报文</li>
<li>对第一分片的数据报片的所有后续数据报片都不发送ICMP差错报告报文</li>
<li>对具有组播地址的数据报片都不发送ICMP差错报告报文</li>
<li>对具有特殊地址的数据报片（127.0.0.0或0.0.0.0）不发送ICMP差错报告报文</li>
</ul>
<h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>特点</p>
<ul>
<li>128位</li>
<li>十六进制表示，四个一位用冒号隔开，四个全0可写为一个0，连着几个冒号都是0，可不写，但要确定个数只能出现一次</li>
<li>划分层次多</li>
<li>首部格式灵活：减少为8个段，更快处理分组，改善吞吐率</li>
<li>改进的选项：以前必要的现在可选了，加快分组处理速度</li>
<li>允许协议继续扩充</li>
<li>支持即插即用</li>
<li>支持资源的预分配</li>
</ul>
<p>三种地址类型：单播、组播、广播</p>
<h1 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h1><table>
<thead>
<tr>
<th>路由算法</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>动态路由</td>
<td>自动学习</td>
</tr>
<tr>
<td>静态路由</td>
<td>手动配置</td>
</tr>
</tbody></table>
<h2 id="内部网关协议IGP"><a href="#内部网关协议IGP" class="headerlink" title="内部网关协议IGP"></a>内部网关协议IGP</h2><p>一个自治系统内部所使用的路由选择协议称为内部网关协议IGP，路由选择称为域内路由选择，具体协议有RIP、OSPF。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>RIP</th>
<th>OSPF</th>
</tr>
</thead>
<tbody><tr>
<td>算法</td>
<td>距离-向量路由算法</td>
<td>链路状态路由算法</td>
</tr>
<tr>
<td>协议参数</td>
<td>用于表示目的网络远近的参数为跳数，即到达目的网络所经过的路由器个数，最大为15</td>
<td>表示的目的网络的数为虚拟值，与链路的带宽相等，不受物理跳数的限制，适合大型网络</td>
</tr>
<tr>
<td>收敛速度</td>
<td>将整个路由表作为路由信息广播至网络中，周期为30s，占用资源，影响收敛</td>
<td>路由信息比较少，广播非周期性，收敛效果好</td>
</tr>
<tr>
<td>分层</td>
<td>网络是平面概念，无区域或边界的定义</td>
<td>网络或自治系统可以划分很多区域，每个区域通过OSPF边界路由相连</td>
</tr>
<tr>
<td>负载平衡</td>
<td>只安装一条路径传输数据</td>
<td>同一个目的网络有多条相同代价的路径，可以将通信量分配给这几条路径</td>
</tr>
<tr>
<td>灵活性</td>
<td>无</td>
<td>对不同链路根据IP分组不同服务类型而设置不同代价</td>
</tr>
<tr>
<td></td>
<td>不以组播地址发送报文</td>
<td>以组播地址发送报文</td>
</tr>
<tr>
<td></td>
<td>采用跳数作为距离的代价</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>将一个自治系统再划分为若干更小的范围，成为区域。</td>
</tr>
<tr>
<td></td>
<td>是被动的，基于谣言的，靠邻居路由判断，仅和邻居交换信息</td>
<td>是独立决策的，会主动测试所有邻接节点的状态，定期的将链路状态传播给其他所有节点，说明本路由器和哪些路由器相邻以及该链路的度量</td>
</tr>
<tr>
<td></td>
<td>交换的信息是当前本路由器所知道的信息，即自己的路由表，并按照固定的时间交换路由信息</td>
<td>使用洪泛法，通过所有输出端口向所有邻接路由，发送的信息是本路由器相邻的所有路由的链路状态，但只是路由器所知道的部分信息。只有链路状态都发生变化时，路由器才用洪泛法向所有路由器发送信息</td>
</tr>
</tbody></table>
<h3 id="RIP距离矢量选择协议"><a href="#RIP距离矢量选择协议" class="headerlink" title="RIP距离矢量选择协议"></a>RIP距离矢量选择协议</h3><ul>
<li><p>先修改此RIP报文中所有项目，把下一跳字段中的地址都改为X，并把所有距离字段+1</p>
</li>
<li><p>对修改后的RIP报文中的每一个项目执行如图操作</p>
<p><img src="/2020/03/15/netNetworkLayer/rip.jpg" alt="图片-RIP执行过程"></p>
</li>
<li><p>若3min还没收到相邻路由器的更新路由表则把相邻路由器记为不可达路由，记为16，若120s后仍未收到更新的报文，则删除</p>
</li>
</ul>
<p>报文格式：首部、路由</p>
<p>优点：简单、开销小、收敛过程较快</p>
<p>缺点</p>
<ul>
<li>RIP限制了网络的规模，它能使用的最大距离为15</li>
<li>路由器之间交换的路由信息是路由器中的最完整路由表，随网络规模增加，开销也增加</li>
<li>当网络出现故障时，经过较长的时间才能将此信息传送到所有的路由器，即坏消息传播的慢，更新过程的收敛时间长</li>
</ul>
<h3 id="OSPF链路状态协议"><a href="#OSPF链路状态协议" class="headerlink" title="OSPF链路状态协议"></a>OSPF链路状态协议</h3><table>
<thead>
<tr>
<th>分组类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>问候分组</td>
<td>发现和维持邻站的可达性</td>
</tr>
<tr>
<td>数据库描述分组</td>
<td>向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息</td>
</tr>
<tr>
<td>链路状态请求分组</td>
<td>向对方请求某些链路的详细信息</td>
</tr>
<tr>
<td>链路状态更新分组</td>
<td>用洪泛法对全网更新链路状态</td>
</tr>
<tr>
<td>链路状态确认分组</td>
<td>对链路更新分组的确认</td>
</tr>
</tbody></table>
<h2 id="外部网关协议EGP"><a href="#外部网关协议EGP" class="headerlink" title="外部网关协议EGP"></a>外部网关协议EGP</h2><p>自治系统之间使用的路由选择协议成为外部网关协议EGP，路由选择成为域间路由选择</p>
<h2 id="边界网关协议BGP"><a href="#边界网关协议BGP" class="headerlink" title="边界网关协议BGP"></a>边界网关协议BGP</h2><ul>
<li>不同自治系统之间交换路由信息的协议</li>
<li>路径向量路由选择协议</li>
<li>寻找一条相对来说比较好的路由</li>
<li>特点<ul>
<li>交换路由信息的节点数量级是自治系统数的量级，比自治系统中的网络数少很多</li>
<li>每一个自治系统中BGP发言人的数目很少，系统不过分复杂</li>
<li>支持CIDR，其路由表包括目的网络前缀、下一跳路由器、到达该目的网络所要经过的各个自治系统序列</li>
<li>再BGP刚运行时，BGP的邻站是交换整个的BGP路由表，但以后只需在变化部分更新</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>报文</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>打开报文</td>
<td>用来与相邻的另一个BGP发言人建立关系</td>
</tr>
<tr>
<td>更新报文</td>
<td>用来发送某一路由信息以及列出要撤销的多条路由</td>
</tr>
<tr>
<td>保活报文</td>
<td>用来确认打开报文和周期性的证实邻站关系</td>
</tr>
<tr>
<td>通知报文</td>
<td>用来发送检测到的差错</td>
</tr>
</tbody></table>
<p><img src="/2020/03/15/netNetworkLayer/xieyi.jpg" alt="图片-路由协议"></p>
<h1 id="IP组播"><a href="#IP组播" class="headerlink" title="IP组播"></a>IP组播</h1><p>需要支持组播协议的路由器，使用D类地址224.0.0.0~239.255.255.255,前缀1110，只能用于目的地址，尽最大努力交付，不提供可靠传输，不产生ICMP，并非所有D类地址都可以组播。</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul>
<li>只在本局域网上进行硬件组播</li>
<li>在因特网的范围内进行组播</li>
</ul>
<h2 id="组播地址换算MAC"><a href="#组播地址换算MAC" class="headerlink" title="组播地址换算MAC"></a>组播地址换算MAC</h2><ul>
<li>IP地址化为二进制，取最后23位</li>
<li>第24位为0</li>
<li>四位一组换为十六进制</li>
<li>在前面加上固定首部01-00-5E</li>
</ul>
<h1 id="移动IP"><a href="#移动IP" class="headerlink" title="移动IP"></a>移动IP</h1><p>实现权限漫游的功能</p>
<table>
<thead>
<tr>
<th>功能实体</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>移动节点</td>
<td>具有永久IP地址的移动节点</td>
</tr>
<tr>
<td>本地代理</td>
<td>有一个端口与移动节点本地链路相连的路由器，根据移动用户的转交地址，采用隧道技术转交移动节点的数据报</td>
</tr>
<tr>
<td>外部代理</td>
<td>移动节点的漫游链路上的路由节点，他通知本地用户代理自己的转交地址，是移动节点漫游链路的默认路由器</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>四大技术</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>代理搜索</td>
<td>知道自己是否正在漫游</td>
</tr>
<tr>
<td>申请转交地址</td>
<td>移动节点到外网时从外代理处得到的临时地址</td>
</tr>
<tr>
<td>登录</td>
<td>移动节点到达外网的一系列认证、注册、建立隧道的过程</td>
</tr>
<tr>
<td>隧道</td>
<td>本地代理与外部代理之间建立的双向数据通道</td>
</tr>
</tbody></table>
<p>过程</p>
<ul>
<li>移动节点在本地网时，按传统的TCP/IP进行通信</li>
<li>移动节点漫游到一个外地网络时，仍按使用固定的IP地址进行通信，为了能够收到通信对端发给它的IP分组，移动节点需要向本地代理注册当前的位置地址，这个位置地址就是转交地址，移动IP的转交地址可以是外部代理的地址或动态配置的一个地址</li>
<li>本地代理收到来自转交地址的注册后，就会构建一条通向转交地址的隧道，将截获的发给移动节点的IP分组通过隧道传送到转交地址处</li>
<li>在转交地址处解除隧道封装，恢复出原始的IP分组，最后送到移动节点，这样移动节点在外网就能够收到这些送给它的IP分组了</li>
<li>移动节点在外网通过外网的路由器或者外代理向通信对端发送IP数据报</li>
<li>当移动节点来到另一个网络时，只需要向本地代理更新注册的转交地址，就可以继续通信了</li>
<li>当移动节点回到本地网时，移动节点想本地代理注销转交地址，这时移动节点又将使用传统的TCP/IP方式进行通信</li>
</ul>
<h1 id="网络层设备，路由器"><a href="#网络层设备，路由器" class="headerlink" title="网络层设备，路由器"></a>网络层设备，路由器</h1><p>路由选择部分：</p>
<ul>
<li>核心部件：路由选择处理器</li>
<li>根据所选定的路由选择协议构造出路由表，同时经常或定期的和相邻路由器交换路由信息不断更新和维护路由表</li>
</ul>
<p>分组转发部分</p>
<ul>
<li><p>组成：一组输入端口、交换结构、一组输出端口</p>
</li>
<li><p>交换方法：通过存储器进行交换、通过总线进行交换、通过互联网络进行交换</p>
</li>
<li><p>过程：从输入端口进。查找转发表，或排队等待。进入交换接口。进行缓存，并在数据链路层处理模块中给分组加上数据链路层的首部尾部。交给物理层发送到外部线路。</p>
</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤计算机网络</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>networkLayer</tag>
      </tags>
  </entry>
  <entry>
    <title>数据链路层相关知识点</title>
    <url>/2020/03/15/netDataLinkLayer/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>单位：Frames帧</li>
<li>硬件：交换机、网桥</li>
<li>任务：将网络层传下来的数据报封装成帧</li>
<li>协议：PHP、HDLC</li>
<li>功能</li>
</ul>
<table>
<thead>
<tr>
<th>功能</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>链路管理</td>
<td>链路连接的建立、拆除、分离</td>
</tr>
<tr>
<td>帧定界和帧同步</td>
<td>接收方确定收到的比特流中一帧的开始位置与结束位置</td>
</tr>
<tr>
<td>差错检测</td>
<td>使接收方确定收到的数据就是发送方发送的数据</td>
</tr>
<tr>
<td>透明传输</td>
<td>不管什么样的比特组合都应当在链路中传送</td>
</tr>
</tbody></table>
<h1 id="组帧"><a href="#组帧" class="headerlink" title="组帧"></a>组帧</h1><table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>字符计数法</td>
<td>用一个字符表示帧的开始，一个计数字段表示该帧包含的字节数，从而推断出帧的结束位和下一个帧开始位</td>
</tr>
<tr>
<td>字节填充的首尾界符法</td>
<td>从128个ASCII码中的33个键盘不能输入的字符中挑出两个作为起始和结束标志。当传输文件不是键盘输入的,文件中会出现起始和结束标志,因此使用字节填充的首尾界符法，SOH–&gt;ESCx,EOT–&gt;ESCy,ESC–&gt;ESCz</td>
</tr>
<tr>
<td>比特填充的首尾标志法</td>
<td>首尾标志为01111110 文件中每连续5个1,则后面加入1个0</td>
</tr>
<tr>
<td>物理编码违例法</td>
<td>利用物理介质上编码违法方式来区分开始和结束</td>
</tr>
</tbody></table>
<h1 id="差错检测"><a href="#差错检测" class="headerlink" title="差错检测"></a>差错检测</h1><h2 id="检错编码"><a href="#检错编码" class="headerlink" title="检错编码"></a>检错编码</h2><ul>
<li><p>奇偶校验码</p>
<ul>
<li>奇校验码:添加一位校验码,使得整个码字里面的1个数是奇数</li>
<li>偶校验码:添加一位校验码,使得整个码字里面的1个数是偶数</li>
</ul>
</li>
<li><p>循环冗余码CRC</p>
<p><img src="/2020/03/15/netDataLinkLayer/crc.jpg" alt="图片-CRC计算过程"></p>
</li>
</ul>
<h2 id="纠错编码"><a href="#纠错编码" class="headerlink" title="纠错编码"></a>纠错编码</h2><p>海明码（Hamming Code）是一个可以有多个校验位，具有检测并纠正一位错误代码的纠错码，所以它也仅用于信道特性比较好的环境中，如以太局域网中，因为如果信道特性不好的情况下，出现的错误通常不是一位。<br>海明码的基本思想是将有效信息按某种规律分成若干组，每组安排一个校验位进行奇偶性测试，然后产生多位检测信息，并从中得出具体的出错位置，最后通过对错误位取反来将其纠正。<br>要采用海明码纠错，需要按以下步骤来进行：计算校验位数→确定校验码位置→确定校验码→实现校验和纠错。</p>
<h1 id="传输机制"><a href="#传输机制" class="headerlink" title="传输机制"></a>传输机制</h1><h2 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h2><table>
<thead>
<tr>
<th>流量控制</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>停止-等待流量控制</td>
<td>发送方发送一个帧,得到应答后再发送下一个帧,否则一直等待</td>
</tr>
<tr>
<td>滑动窗口流量控制</td>
<td>允许发送多个帧,得到一个应答窗口向前滑动一个帧。当窗口满了,发送方会强行关闭网络层,直到有一个空闲缓冲区出来</td>
</tr>
</tbody></table>
<h2 id="可靠传输机制"><a href="#可靠传输机制" class="headerlink" title="可靠传输机制"></a>可靠传输机制</h2><p>利用传输层TCP</p>
<h2 id="滑动窗口机制"><a href="#滑动窗口机制" class="headerlink" title="滑动窗口机制"></a>滑动窗口机制</h2><table>
<thead>
<tr>
<th>协议</th>
<th>窗口状态</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>停止-等待协议</td>
<td>发送窗口=1,接收窗口=1</td>
<td>可靠传输（确认：发送确认帧超时，重传：一段时间没有响应就会重新发送）；数据帧破坏（如果帧正确则接收，不正确则丢弃，发送方未收到确认帧等待一段时间后再次发送）；确认帧被破坏（发送方在帧中加入标识，接收方判断是新帧还是旧帧）</td>
</tr>
<tr>
<td>后退N帧协议(GBN)</td>
<td>发送窗口&gt;1,接收窗口=1</td>
<td>滑动窗口中，某帧出错，则其及后续帧丢弃，发送方重传</td>
</tr>
<tr>
<td>选择重传协议(SR)</td>
<td>发送窗口&gt;1,接收窗口&gt;1</td>
<td>某帧出错，其后续帧存入接收方缓存中，发送方重发出错帧</td>
</tr>
</tbody></table>
<h1 id="介质访问控制"><a href="#介质访问控制" class="headerlink" title="介质访问控制"></a>介质访问控制</h1><p>介质访问控制(medium access control)简称MAC。 是解决当局域网中共用信道的使用产生竞争时，如何分配信道的使用权问题。</p>
<h2 id="信道划分介质访问控制"><a href="#信道划分介质访问控制" class="headerlink" title="信道划分介质访问控制"></a>信道划分介质访问控制</h2><ul>
<li>频分多路复用：道路变宽</li>
<li>时分多路复用：时间分割</li>
<li>波分多路复用：波段分割</li>
<li>码分多路复用：碎片数据✖码片向量，-1表示比特0，1表示比特1，0表示没有数据</li>
</ul>
<h2 id="随机访问介质访问控制"><a href="#随机访问介质访问控制" class="headerlink" title="随机访问介质访问控制"></a>随机访问介质访问控制</h2><ul>
<li><p>随机接入(争用型)</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>ALOHA</td>
<td>不经过任何检测就发送数据，没有收到确认则继续发送</td>
</tr>
<tr>
<td>CSMA</td>
<td>1-坚持CSMA：发送节点监听到空闲时，立即发送数据，否则继续监听；p-坚持CSMA：发送节点监听到空闲时，依概率p发送数据，以概率（1-p）延迟一段时间并重新监听；非坚持CSMA：发送节点一旦监听到空闲时，就立即发送数据，否则延迟一段时间重新监听。</td>
</tr>
<tr>
<td>CSMA/CD</td>
<td>过程：发送数据之前检测总线是否有其他计算机发送数据，若无则发送数据，发送时继续监听，若出现冲突则随机时间后继续发送，适合有线网络，是被动型。</td>
</tr>
<tr>
<td>CSMA/CA</td>
<td>过程：发送数据之前检测总线是否有其他计算机发送数据，若无则发送数据，一段时间后检查对方是否发回帧确认，若没有继续重发，适合无线型网络，是主动型。</td>
</tr>
</tbody></table>
</li>
<li><p>受控接入：不能随便发送某数据，得到某种东西才能发送</p>
</li>
</ul>
<h2 id="轮询访问介质访问控制"><a href="#轮询访问介质访问控制" class="headerlink" title="轮询访问介质访问控制"></a>轮询访问介质访问控制</h2><ul>
<li>过程：用户不能随机发送数据，通过一个集中控制的监控站经过轮询过程后再决定信道的分配</li>
<li>令牌环局域网</li>
<li>令牌传递协议</li>
</ul>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="局域网"><a href="#局域网" class="headerlink" title="局域网"></a>局域网</h2><h3 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h3><p>工作原理：采用总线拓扑结构，无连接工作方式，不对发送的数据进行编号，也不要求对方发送确认。</p>
<p>MAC帧如下：</p>
<p><img src="/2020/03/15/netDataLinkLayer/maczhen.jpg" alt="图片-MAC帧"></p>
<ul>
<li><p>前导码：前同步符、帧开始定界符</p>
</li>
<li><p>目的地址、源地址：目的地址前八位最后一位为0，发给某一工作站；最后一位为1，其余不全为1，发给一组工作站；全为1，广播地址，发给所有工作站。</p>
</li>
</ul>
<p>传输介质，其中10指10Mbit/s，base基带信号</p>
<p><img src="/2020/03/15/netDataLinkLayer/10base.jpg" alt="图片-各种以太网"></p>
<p>高速以太网：100Base-T以太网、吉比特以太网、10吉比特以太网</p>
<p>无线局域网</p>
<ul>
<li>有固定基础设施的无线局域网（BSS基站）</li>
<li>无固定基础设施的无线局域网（自主网络）</li>
</ul>
<p>IEEE802.11</p>
<ul>
<li>物理层：跳频扩频（FHSS）、直接序列扩频（DSS）、红外线（IR）</li>
<li>MAC层：分布协调功能（DCF）、点协调功能（PCF）、CSMA/CD、确认机制</li>
</ul>
<h3 id="令牌环网"><a href="#令牌环网" class="headerlink" title="令牌环网"></a>令牌环网</h3><ul>
<li>当网络空闲时，环路中只有令牌在网络中循环传递</li>
<li>令牌传递到数据要发送的节点，修改令牌标志位，附加要传输的数据</li>
<li>数据延环路继续传输，直到遇到接收节点</li>
<li>接收节点复制数据，令牌继续传，传回发送节点</li>
<li>发送节点检查数据是否出错，出错重传，没有就产生一个新令牌，继续在令牌环上游荡</li>
</ul>
<h2 id="广域网"><a href="#广域网" class="headerlink" title="广域网"></a>广域网</h2><h3 id="PPP"><a href="#PPP" class="headerlink" title="PPP"></a>PPP</h3><p>是面向字节的协议，只负责检错、是不可靠传输、点对点通讯、全双工链路。</p>
<p>过程：用户拨号接入ISP，调制解调器对拨号做出确认，并建立一条物理连接，计算机向路由器发送一系列LCP分组，网络控制协议NCP给个人计算机分配一个临时IP，接入网络成功。</p>
<p><img src="/2020/03/15/netDataLinkLayer/ppp.jpg" alt="图片-PPP"></p>
<h3 id="HDLC协议"><a href="#HDLC协议" class="headerlink" title="HDLC协议"></a>HDLC协议</h3><p>是面向比特的协议</p>
<p>基本配置</p>
<ul>
<li>非平衡配置：由一个主机控制整个链路</li>
<li>平衡配置：链路两端的两个站是复合站，每个复合站可以平等的发起数据，不需要得到对方复合站的允许</li>
</ul>
<p><img src="/2020/03/15/netDataLinkLayer/HDCL.jpg" alt="图片-HDCL"></p>
<h1 id="物理设备"><a href="#物理设备" class="headerlink" title="物理设备"></a>物理设备</h1><h2 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h2><p>网桥至少有两个端口，每个端口与一个网段相连，接收到数据存储到缓存中，若为出错，则查找转发表从别的端口转发出去</p>
<ul>
<li>优点：过滤通信量、扩大物理范围、提高可靠性、可连接至不同物理层、不同MAC层和不同速率的以太网上</li>
<li>缺点：存储转发增加了时延、在MAC子层并没有流量控制功能、具有不同MAC子层的网段桥接在一起时时延更大、适合用户数量不多，通信量小的局域网</li>
</ul>
<table>
<thead>
<tr>
<th>分类</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>透明网桥</td>
<td>指不知道要经过哪几个网桥，自主学习转发表，新增或更新（源地址、进入的接口和时间）</td>
</tr>
<tr>
<td>源选径网桥</td>
<td>对外广播，选择最佳路由</td>
</tr>
</tbody></table>
<h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><ul>
<li>实质：多端口网桥</li>
<li>直通式交换：只检查帧的目的地址，收到后立马被转发出去</li>
<li>存储转发式交换：先存储在高速缓存中，检查数据是否正确，查找转发表，转发</li>
</ul>
<h2 id="网桥与交换机对比"><a href="#网桥与交换机对比" class="headerlink" title="网桥与交换机对比"></a>网桥与交换机对比</h2><ul>
<li>网桥有两个端口，交换机多个</li>
<li>网桥连接到局域网网段，交换机连接主机或HUB</li>
<li>网桥一对计算机同时通讯，交换机允许多对</li>
<li>网桥存储转发，以太网有直通转发和存储转发</li>
</ul>
<h2 id="冲突域与广播域总结"><a href="#冲突域与广播域总结" class="headerlink" title="冲突域与广播域总结"></a>冲突域与广播域总结</h2><p><img src="/2020/03/15/netDataLinkLayer/chongtu.jpg" alt="图片-冲突域与广播域"></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤计算机网络</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>dataLinkLayer</tag>
      </tags>
  </entry>
  <entry>
    <title>物理层的相关知识点</title>
    <url>/2020/03/15/netPhysicalLayer/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>单位：Bits比特</li>
<li>硬件：集线器、中继器</li>
<li>任务：透明的传输比特流</li>
<li>功能：为数据端设备提供传输数据的通路</li>
</ul>
<h1 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h1><table>
<thead>
<tr>
<th>概念</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>信号</td>
<td>数据的电气或电磁表现（基带信号：数字信号0和1；宽带信号：模拟信号）</td>
</tr>
<tr>
<td>信源</td>
<td>信息的源泉</td>
</tr>
<tr>
<td>信道</td>
<td>信息传送的道路</td>
</tr>
<tr>
<td>信宿</td>
<td>信息的归宿地</td>
</tr>
<tr>
<td>带宽</td>
<td>通信线路允许通过的信号频带范围Hz、 网络通信线路所能传输数据的能力bit/s</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>通信方式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>同步</td>
<td>接收端和发送端时钟频率相同</td>
</tr>
<tr>
<td>异步</td>
<td>以字节为单位 增加一个起始比特和终止比特 可以任意间隔发送下一个字节</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>通信模式</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>单工</td>
<td>只有一个方向</td>
</tr>
<tr>
<td>半双工</td>
<td>两个方向但不能同时进行</td>
</tr>
<tr>
<td>全双工</td>
<td>两个方向可以同时进行</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>速率</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>波特率（码元传输速率）</td>
<td>脉冲个数哦或信号变化的次数 表示单位时间内数字通信系统所传输的码元个数</td>
</tr>
<tr>
<td>比特率（信息传输速率）</td>
<td>单位时间内数字通信系统所传输的二进制码元个数 一码元通过变化表示0和1，后来可以携带4比特</td>
</tr>
</tbody></table>
<h1 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h1><h2 id="奈奎斯特定理"><a href="#奈奎斯特定理" class="headerlink" title="奈奎斯特定理"></a>奈奎斯特定理</h2><p>奈奎斯特定律是一种信息速率，根据奈奎斯特定律，信道的极限速率（码元速率）等于信道带宽（低通信道）等于信道带宽（理论状态）。</p>
<p>在理想低通的条件下(没有噪声)，带宽有限的信道，极限码元速率是2W 波特。<br>W是信道带宽，单位是Hz。每个码元离散状态的数目用V表示，则极限传输速率 = 2Wlog2V</p>
<h2 id="香农定理"><a href="#香农定理" class="headerlink" title="香农定理"></a>香农定理</h2><p>香农定理是指在带宽受限且有高斯白噪声干扰的信道极限传输速率。</p>
<p>信道的极限传输速率 = Wlog2(1+S/N)Wlog2(1+S/N)<br>具体来说，香农定理主要围绕的是S/N的计算考察，S表示信道传输信号的平均功率。</p>
<h1 id="编码与调制"><a href="#编码与调制" class="headerlink" title="编码与调制"></a>编码与调制</h1><h2 id="编码-模拟变数字"><a href="#编码-模拟变数字" class="headerlink" title="编码(模拟变数字)"></a>编码(模拟变数字)</h2><p>数字数据编码为数字信号</p>
<p>模拟数据编码为数字信号：采样-&gt;量化-&gt;编码</p>
<p><img src="/2020/03/15/netPhysicalLayer/bianma.jpg" alt="图片-编码方式"></p>
<table>
<thead>
<tr>
<th>编码方式</th>
<th>规则</th>
</tr>
</thead>
<tbody><tr>
<td>非归零码(NRZ)</td>
<td>低电平0，高电平1</td>
</tr>
<tr>
<td>曼彻斯特编码</td>
<td>中间跳变，从高到低跳变表示“1”，从低到高跳变表示“0”</td>
</tr>
<tr>
<td>差分曼彻斯特编码</td>
<td>开始时跳变为“0”，无跳变为“1”。中间跳变，初始为1</td>
</tr>
</tbody></table>
<h2 id="调制-数字变模拟"><a href="#调制-数字变模拟" class="headerlink" title="调制(数字变模拟)"></a>调制(数字变模拟)</h2><p>数字数据编码为模拟信号</p>
<p>模拟数据编码为模拟信号</p>
<table>
<thead>
<tr>
<th>调制名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>带通调制(载波调制)</td>
<td>改变频率范围，调幅、调频、调相</td>
</tr>
<tr>
<td>基带调制</td>
<td>改变波形</td>
</tr>
</tbody></table>
<h1 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h1><p><img src="/2020/03/15/netPhysicalLayer/shujuchuanshu.jpg" alt="图片-数据传输方式"></p>
<table>
<thead>
<tr>
<th>传输方式</th>
<th>描述</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>电路交换</td>
<td>建立一条被双方占有的物理通路</td>
<td>通信时延小、实时性强、有序传输、使用范围广、控制简单、避免冲突</td>
<td>建立连接时间长、信道利用率低、缺乏统一标准、灵活性差</td>
</tr>
<tr>
<td>报文交换</td>
<td>数据交换单位是报文，报文携带有目的地址和源地址等信息，采用存储转发方式</td>
<td>无需建立连接、动态分配线路、提高可靠性、提高线路利用率、提供多目标服务</td>
<td>有转发时延 要求网络节点有较大的存储缓存空间</td>
</tr>
<tr>
<td>分组交换</td>
<td>仍采用存储转发方式，将较长的报文分割为若干个较短的分组，逐个的转发出去</td>
<td>加速传输 简化存储管理 减少出错率和重发数据量</td>
<td>存在传输时延 可能出现失序、丢失、重复分组等现象</td>
</tr>
</tbody></table>
<h1 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h1><table>
<thead>
<tr>
<th>报文</th>
<th>过程</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td>数据报</td>
<td>主机A先将分组逐个的发往与它相连的交换机1,1将A发来的分组缓存 1查找转发表,不同时刻转发表的内容可能不同,或转发给234 直到分组到达主机B</td>
<td>发送分组前无需建立连接 分组首部包含的是目的地址 尽最大努力交付,不保证可靠性,无序到达 减少延迟,提高了吞吐量 不独占某一链路,资源利用率高</td>
</tr>
<tr>
<td>虚电路</td>
<td>在发送前和主机建立一条虚连接 主机A发出特殊呼叫请求,B发送呼叫应答进行确认,虚电路建立成功 分组走相同路径 传输结束,主机发送释放请求</td>
<td>通讯必须建立连接 走相同路径,按序到达 分组首部包含的是虚电路标识符 路由失效时受影响</td>
</tr>
</tbody></table>
<h1 id="传输介质"><a href="#传输介质" class="headerlink" title="传输介质"></a>传输介质</h1><p>传输介质在物理层之下,不属于模型中</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>机械特性、电气特性、功能特性</p>
<h2 id="材质"><a href="#材质" class="headerlink" title="材质"></a>材质</h2><h3 id="双绞线"><a href="#双绞线" class="headerlink" title="双绞线"></a>双绞线</h3><p>无屏蔽双绞线</p>
<ul>
<li>标准<ul>
<li>标准568A：绿白-1，绿-2，橙白-3，蓝-4，蓝白-5，橙-6，棕白-7，棕-8。</li>
<li>标准568B：橙白-1，橙-2，绿白-3，蓝-4，蓝白-5，绿-6，棕白-7，棕-8。</li>
</ul>
</li>
<li>平行线：两端相同</li>
<li>交叉线：一端568A,一段568B</li>
</ul>
<p>屏蔽双绞线：加了一层金属网,较硬</p>
<h3 id="同轴电缆"><a href="#同轴电缆" class="headerlink" title="同轴电缆"></a>同轴电缆</h3><p>同轴电缆（CoaxialCable）是指有两个同心导体，而导体和屏蔽层又共用同一轴心的电缆。</p>
<h3 id="光纤"><a href="#光纤" class="headerlink" title="光纤"></a>光纤</h3><p>单模光纤：使用昂贵的半导体激光器,不发生反射,适合远距离传输</p>
<p>多模光纤：使用发光二极管,传输过程中会逐渐展宽失真,适合近距离传输</p>
<h1 id="物理设备"><a href="#物理设备" class="headerlink" title="物理设备"></a>物理设备</h1><h2 id="中继器"><a href="#中继器" class="headerlink" title="中继器"></a>中继器</h2><ul>
<li>放大器放大的是模拟信号,中继器放大数字信号</li>
</ul>
<h2 id="集线器"><a href="#集线器" class="headerlink" title="集线器"></a>集线器</h2><ul>
<li>计算机连接到集线器上,集线器对信号进行收发广播,每台电脑都会收到,不是发给自己的不予理睬</li>
<li>集线器不能隔离冲突域</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤计算机网络</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>physicalLayer</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络基本概念</title>
    <url>/2020/03/15/netBasicConcept/</url>
    <content><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>一些互联自治的计算机系统的集合</p>
<h1 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h1><h2 id="物理组成"><a href="#物理组成" class="headerlink" title="物理组成"></a>物理组成</h2><h3 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h3><ul>
<li>主机</li>
<li>通讯处理机（前端处理器）</li>
<li>通讯线路<ul>
<li>有线</li>
<li>无线</li>
</ul>
</li>
<li>交换设备<ul>
<li>交换机</li>
<li>路由器</li>
<li>etc</li>
</ul>
</li>
</ul>
<h3 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h3><p>实现资源共享的软件和工具，如：QQ</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>一种规则</p>
<h2 id="工作方式组成"><a href="#工作方式组成" class="headerlink" title="工作方式组成"></a>工作方式组成</h2><h3 id="边缘部分"><a href="#边缘部分" class="headerlink" title="边缘部分"></a>边缘部分</h3><ul>
<li>组成：所有连接在互联网上供用户直接使用的主机</li>
<li>作用：通信、资源共享</li>
</ul>
<h3 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h3><ul>
<li>组成大量的网络和连接这些网络的路由器</li>
<li>作用：提供连通性和交换服务</li>
</ul>
<h2 id="功能组成"><a href="#功能组成" class="headerlink" title="功能组成"></a>功能组成</h2><h3 id="通讯子网"><a href="#通讯子网" class="headerlink" title="通讯子网"></a>通讯子网</h3><ul>
<li>组成：传输介质、通信设备、响应的网络协议</li>
<li>作用：提供数据传输、交换和控制能力，实现信息通讯</li>
</ul>
<h3 id="资源子网"><a href="#资源子网" class="headerlink" title="资源子网"></a>资源子网</h3><ul>
<li>组成：主机、终端、各类软件资源和信息资源</li>
<li>作用：负责全网的数据处理业务，像网络用户提供各种网络资源与服务</li>
</ul>
<h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><ul>
<li>数据通信（最基本，最重要）</li>
<li>资源共享</li>
<li>分布式处理</li>
<li>信息综合处理</li>
<li>负载均衡</li>
<li>提高可靠性</li>
</ul>
<h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><h2 id="分布范围"><a href="#分布范围" class="headerlink" title="分布范围"></a>分布范围</h2><ul>
<li>广域网</li>
<li>城域网</li>
<li>局域网</li>
<li>个人区域网</li>
</ul>
<h2 id="拓扑结构"><a href="#拓扑结构" class="headerlink" title="拓扑结构"></a>拓扑结构</h2><ul>
<li><p>星形网络</p>
</li>
<li><p>总线型网络</p>
</li>
<li><p>环形网络</p>
</li>
<li><p>网状形网络</p>
</li>
</ul>
<h2 id="传输技术"><a href="#传输技术" class="headerlink" title="传输技术"></a>传输技术</h2><ul>
<li>广播式网络</li>
<li>点对点网络</li>
</ul>
<h2 id="使用者"><a href="#使用者" class="headerlink" title="使用者"></a>使用者</h2><ul>
<li>公用网</li>
<li>专用网</li>
</ul>
<h2 id="数据交换技术"><a href="#数据交换技术" class="headerlink" title="数据交换技术"></a>数据交换技术</h2><ul>
<li>电路交换网</li>
<li>报文交换网</li>
<li>分组交换网</li>
</ul>
<h1 id="相关组织"><a href="#相关组织" class="headerlink" title="相关组织"></a>相关组织</h1><ul>
<li>ISO国际标准化组织</li>
<li>ITU国际电信联盟</li>
<li>IEEE美国电气和电子工程师协会</li>
</ul>
<h1 id="参考模型"><a href="#参考模型" class="headerlink" title="参考模型"></a>参考模型</h1><h2 id="ISO-OSI"><a href="#ISO-OSI" class="headerlink" title="ISO/OSI"></a>ISO/OSI</h2><ul>
<li>应用层</li>
<li>表示层</li>
<li>会话层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
<h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><ul>
<li>应用层</li>
<li>传输层</li>
<li>互联网层</li>
<li>网络接收层</li>
</ul>
<h2 id="5层模型"><a href="#5层模型" class="headerlink" title="5层模型"></a>5层模型</h2><ul>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>
<h1 id="性能指标"><a href="#性能指标" class="headerlink" title="性能指标"></a>性能指标</h1><h2 id="时延（总时延为四者之和）"><a href="#时延（总时延为四者之和）" class="headerlink" title="时延（总时延为四者之和）"></a>时延（总时延为四者之和）</h2><ul>
<li>发送时延（传输时延）<ul>
<li>主机或路由器发送数据所需要的时间，从第一位开始发送到最后一位发送完毕</li>
<li>发送时延=数据帧长度（bit）/发送速率（bit/s）</li>
</ul>
</li>
<li>传播时延<ul>
<li>电磁波在信道中传播一定的距离所需要的时间</li>
<li>传播时延=信道长度（m）/电磁波在信道上的传播速度（m/s）</li>
</ul>
</li>
<li>处理时延<ul>
<li>主机在路由器在接收到分组时进行处理所需要的时间</li>
</ul>
</li>
<li>排队时延<ul>
<li>进入路由器在输入队列排队等待处理</li>
<li>确定转发接口后，在输出队列等待转发</li>
</ul>
</li>
</ul>
<h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><ul>
<li>时延带宽积=传播时延*带宽</li>
</ul>
<h2 id="往返时间"><a href="#往返时间" class="headerlink" title="往返时间"></a>往返时间</h2><ul>
<li>从发送方开始发送数据，到发送方收到接收方的确认消息</li>
</ul>
<h2 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h2><ul>
<li>信道利用率<ul>
<li>某信道有%的时间是被利用的</li>
</ul>
</li>
<li>网络利用率<ul>
<li>全网络信道利用率加权平均值</li>
</ul>
</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>天勤计算网络</p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>conception</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络参考模型</title>
    <url>/2020/03/15/networkReferenceModel/</url>
    <content><![CDATA[<p>将网络分层有利于让整个流程更加清晰，复杂的问题简单化。计算机网络参考模型常见的有三种：</p>
<p><img src="/2020/03/15/networkReferenceModel/cankaomoxing.jpg" alt="图片-三个参考模型"></p>
<p><a href="https://wenku.baidu.com/view/f7593b88974bcf84b9d528ea81c758f5f61f29f4.html" target="_blank" rel="noopener">图片改编自百度文库</a></p>
<h1 id="OSI七层参考模型"><a href="#OSI七层参考模型" class="headerlink" title="OSI七层参考模型"></a>OSI七层参考模型</h1><p>OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO组织在1985年研究的网络互联模型。该体系结构标准定义了网络互联的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层和应用层），即OSI开放系统互连参考模型。</p>
<p>OSI 将计算机网络体系结构划分为七层，每层都可以提供抽象良好的接口，能够提供面向连接和无连接两种通信服务机制。是一种使各种不同的计算机和网络在世界范围内实现互联的标准框架。OSI 虽然层级多，由于功能细化，便于排障。不过由于种种原因，没有得以推行，只能作为一种适合学习的模型。</p>
<p><img src="/2020/03/15/networkReferenceModel/OSItujie.jpg" alt="图片-图解OSI"></p>
<p><a href="http://www.colasoft.com.cn/download/document.php" target="_blank" rel="noopener">图片来自科来</a></p>
<h1 id="TCP-IP四层参考模型"><a href="#TCP-IP四层参考模型" class="headerlink" title="TCP/IP四层参考模型"></a>TCP/IP四层参考模型</h1><p>TCP/IP参考模型是计算机网络的祖父ARPANET和其后继的因特网使用的参考模型。ARPANET是由美国国防部DoD（U.S.Department of Defense）赞助的研究网络。逐渐地它通过租用的电话线连结了数百所大学和政府部门。当无线网络和卫星出现以后，现有的协议在和它们相连的时候出现了问题，所以需要一种新的参考体系结构。</p>
<p>这个体系结构在它的两个主要协议出现以后，即先有的TCP和IP协议，后有的模型，被称为TCP/IP参考模型（TCP/IP reference model）。基于TCP/IP的参考模型将协议分成四个层次，它们分别是：网络访问层、网际互联层（主机到主机）、传输层、和应用层，能够提供面向连接和无连接两种通信服务机制。由于出现的早，更为众人所采用，是偏向于实践的模型。</p>
<h1 id="教学五层模型"><a href="#教学五层模型" class="headerlink" title="教学五层模型"></a>教学五层模型</h1><p>为了便于学习，便出现了TCP/IP模型分化出来的模型，即教学五层模型。这个模型在工业界是没有的，主要是方便教学使用。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>对象</th>
<th>单位</th>
<th>功能</th>
<th>协议</th>
</tr>
</thead>
<tbody><tr>
<td>应用层</td>
<td>用户对用户</td>
<td></td>
<td>文件传输、访问和管理、电子邮件服务</td>
<td>FTP 、SMTP、POP3、HTTP、DNS、TFTP、SNMP</td>
</tr>
<tr>
<td>传输层</td>
<td>应用对应用、进程对进程</td>
<td>(segments段)报文段TCP、用户数据报UDP，报文</td>
<td>为端到端连接提供可靠的传输服务，为端到端连接提供流量控制、差错控制、服务质量等管理服务，提供应用进程间的逻辑通信，差错检测，提供无连接和面向连接的服务，复用和分用，TCP:连接管理 流量控制与拥塞控制</td>
<td>TCP、UDP</td>
</tr>
<tr>
<td>网络层</td>
<td>主机对主机</td>
<td>Packets包：数据报，分组</td>
<td>组包和拆包、路由选择、分组转发、拥塞控制、异构网络互连</td>
<td>ICMP、ARP、RARP、IP、IGMP</td>
</tr>
<tr>
<td>数据链路层</td>
<td></td>
<td>Frames帧</td>
<td>链路管理、帧定界和帧同步、差错检测、透明传输</td>
<td>PHP、HDLC</td>
</tr>
<tr>
<td>物理层</td>
<td></td>
<td>Bits比特</td>
<td>提供传输数据的通路</td>
<td></td>
</tr>
</tbody></table>
<p>以前学习的时候参考天勤做了一个思维大纲图，欢迎来看，<a href="https://mubu.com/doc/5PAGbmxGYrg" target="_blank" rel="noopener">计算机网络</a></p>
<h1 id="数据封装拆解过程"><a href="#数据封装拆解过程" class="headerlink" title="数据封装拆解过程"></a>数据封装拆解过程</h1><p>从应用层的数据到物理层的比特率，每向下一层数据都会被进一步封装，就像洋葱一样，只有它的芯才是真正的要表达的数据，那一层一层的是传输时的信息，比如下一步要传递给谁？它的地址是多少？</p>
<p><img src="/2020/03/15/networkReferenceModel/fengzhuang.png" alt="图片-数据封装"></p>
<p><a href="https://wenku.baidu.com/view/f7593b88974bcf84b9d528ea81c758f5f61f29f4.html" target="_blank" rel="noopener">图片改编自百度文库</a></p>
<p>现实生活中，我们不可能一根网线就可把数据发送给对方，中间要经过多个路由器、交换机。</p>
<p><img src="/2020/03/15/networkReferenceModel/2020-03-15-networkReferenceModel%5Cliudongguocheng.png" alt="图片-数据流动过程"></p>
<p><a href="https://wenku.baidu.com/view/f7593b88974bcf84b9d528ea81c758f5f61f29f4.html" target="_blank" rel="noopener">图片改编自百度文库</a></p>
<p>每次需要经过交换机时MAC头部就会被拆解，并被更换为新的MAC头部。每次需要经过路由器时，MAC头部被拆解并向上提交至网络层，IP头部也会被拆解并更换为新的IP头部，然后向下提交加上新的MAC头部。以此类推，最后到达了目标主机。再逐层拆解最后洋葱被拨的只剩芯了，这也是我们真正想要发送的数据。</p>
<p><img src="/2020/03/15/networkReferenceModel/jiefeng.png" alt="图片-数据解封过程"></p>
<p><a href="https://wenku.baidu.com/view/f7593b88974bcf84b9d528ea81c758f5f61f29f4.html" target="_blank" rel="noopener">图片改编自百度文库</a></p>
<p>最后这是一张表述每一层所对应物理设备，当然这并不是绝对的，因为现实生活中也会有网络层交换机。</p>
<p><img src="/2020/03/15/networkReferenceModel/shebei.png" alt="图片-对应设备"></p>
<p><a href="https://wenku.baidu.com/view/f7593b88974bcf84b9d528ea81c758f5f61f29f4.html" target="_blank" rel="noopener">图片改编自百度文库</a></p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://wenku.baidu.com/view/f7593b88974bcf84b9d528ea81c758f5f61f29f4.html" target="_blank" rel="noopener">百度文库-01-计算机网络参考模型</a></p>
<p><a href="[https://baike.baidu.com/item/OSI%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B](https://baike.baidu.com/item/OSI参考模型)">百度百科-OSI参考模型</a></p>
<p><a href="https://www.jianshu.com/p/348df1dde9bd" target="_blank" rel="noopener">简书-计算机网络-参考模型</a></p>
<p><a href="https://zhidao.baidu.com/question/573470632.html" target="_blank" rel="noopener">百度知道</a></p>
<p><a href="[https://baike.baidu.com/item/TCP%2FIP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B](https://baike.baidu.com/item/TCP%2FIP参考模型)">百度百科-TCP/IP参考模型</a></p>
<p><a href="https://www.cnblogs.com/lsdb/p/9564094.html" target="_blank" rel="noopener">博客园-努力改个网名</a></p>
<p><a href>天勤计算机网络</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>OSI - TCP/IP</tag>
        <tag>五层模型</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS域名解析过程</title>
    <url>/2020/03/14/dnsProcess/</url>
    <content><![CDATA[<p>DNS域名解析过程大致分为两种：</p>
<h1 id="迭代查询"><a href="#迭代查询" class="headerlink" title="迭代查询"></a>迭代查询</h1><p>所谓迭代查询是指：根域名服务器收到查询请求，要么给出查询结果，要么告诉本地域名服务器下一步向哪个域名服务器进行查询。</p>
<p>主要是本地域名服务器向根域名服务器查询信息时所采用的方式。</p>
<h1 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h1><p>所谓递归查询是指：本地域名服务器只请求一次，后面几次都是在其他几个域名服务器之间进行的。</p>
<p>主要是主机向本地域名服务器查询信息时所采用的方式。当主机需要查询IP时，本地域名服务器不知道域名所对应的IP地址，那么本地域名服务器就以DNS客户的身份，向其他根域名服务器发送查询请求报文，而不是让主机自己进行下一步查询。</p>
<h1 id="访问度娘的过程"><a href="#访问度娘的过程" class="headerlink" title="访问度娘的过程"></a>访问度娘的过程</h1><pre><code>①本机向local dns请求www.baidu.com
②local dns向根域请求www.baidu.com，根域返回com.域的服务器IP
③向com.域请求www.baidu.com，com.域返回baidu.com域的服务器IP
④向baidu.com请求www.baidu.com，返回cname www.a.shifen.com和a.shifen.com域的服务器IP
⑤向root域请求www.a.shifen.com
⑥向com.域请求www.a.shife.com
⑦向shifen.com请求
⑧向a.shifen.com域请求
⑨拿到www.a.shifen.com的IP
⑩localdns返回本机www.baidu.com cname www.a.shifen.com 以及 www.a.shifen.com的IP</code></pre><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/crazw/article/details/8986504" target="_blank" rel="noopener">CSDN-Crazw_jia</a></p>
<p><a href="https://blog.csdn.net/Daputao_net/article/details/81203531" target="_blank" rel="noopener">CSDN-Daputao_net</a></p>
<p><a href="https://www.cnblogs.com/qingdaofu/p/7399670.html" target="_blank" rel="noopener">博客园-皈依之路</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>dns</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP的头信息</title>
    <url>/2020/03/14/httpHeads/</url>
    <content><![CDATA[<p>HTTP头信息主要包括通用头、请求头、响应头、实体头。</p>
<p><img src="/2020/03/14/httpHeads/qingqiutou.png" alt="qingqiutou"><br><img src="/2020/03/14/httpHeads/xiangyingtou.png" alt="xiangyingtou"></p>
<h1 id="通用头部"><a href="#通用头部" class="headerlink" title="通用头部"></a>通用头部</h1><p>通用头域包含请求和响应消息都支持的头域，通用头域包含缓存头部Cache-Control、Pragma及信息性头部Connection、Date、Transfer-Encoding、Update、Via。</p>
<table>
<thead>
<tr>
<th align="left">应答头</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Cache-Control</td>
<td align="left">指定请求和响应遵循的缓存机制</td>
</tr>
<tr>
<td align="left">Pragma</td>
<td align="left">用来包含实现特定的指令</td>
</tr>
<tr>
<td align="left">Connection</td>
<td align="left">表示是否需要持久连接</td>
</tr>
<tr>
<td align="left">Date</td>
<td align="left">指定请求和响应遵循的缓存机制</td>
</tr>
<tr>
<td align="left">Cache-Control</td>
<td align="left">表示消息发送的时间</td>
</tr>
<tr>
<td align="left">Transfer-Encoding</td>
<td align="left">服务器表明自己对本响应消息体作了怎样的编码</td>
</tr>
<tr>
<td align="left">Upgrade</td>
<td align="left">指定另一种可能完全不同的协议</td>
</tr>
<tr>
<td align="left">Via</td>
<td align="left">列出该响应经过了哪些代理服务器，他们用什么协议发送的请求</td>
</tr>
</tbody></table>
<h1 id="请求头部"><a href="#请求头部" class="headerlink" title="请求头部"></a>请求头部</h1><p>请求头用于说明是谁或什么在发送请求、请求源于何处，或者客户端的喜好及能力。服务器可以根据请求头部给出的客户端信息，试着为客户端提供更好的响应。请求头域可能包含下列字段Accept、Accept-Charset、Accept- Encoding、Accept-Language、Authorization、From、Host、If-Modified-Since、If-Match、If-None-Match、If-Range、If-Range、If-Unmodified-Since、Max-Forwards、Proxy-Authorization、Range、Referer、User-Agent。对请求头域的扩展要求通讯双方都支持，如果存在不支持的请求头域，一般将会作为实体头域处理。</p>
<table>
<thead>
<tr>
<th align="left">应答头</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Accept</td>
<td align="left">告诉WEB服务器自己接受什么介质类型</td>
</tr>
<tr>
<td align="left">Accept-Charset</td>
<td align="left">浏览器告诉服务器自己能接收的字符集</td>
</tr>
<tr>
<td align="left">Accept-Encoding</td>
<td align="left">浏览器申明自己接收的编码方法</td>
</tr>
<tr>
<td align="left">Accept-Language</td>
<td align="left">浏览器申明自己接收的语言</td>
</tr>
<tr>
<td align="left">Authorization</td>
<td align="left">客户端接收到服务器的WWW-Authenticate响应时，用该头部来回应服务器自己的身份验证信息</td>
</tr>
<tr>
<td align="left">If-Match</td>
<td align="left">如果对象的ETag没有改变，即对象没有改变，才执行请求的动作</td>
</tr>
<tr>
<td align="left">If-None-Match</td>
<td align="left">如果对象的ETag改变了，才执行请求的动作</td>
</tr>
<tr>
<td align="left">If-Modified-Since</td>
<td align="left">如果请求的对象在该头部指定的时间之后修改了，才执行请求的动作，否则返回代码304，告诉浏览器该对象没有修改</td>
</tr>
<tr>
<td align="left">If-Unmodified-Since</td>
<td align="left">如果请求的对象在该头部指定的时间之后没修改过，才执行请求的动作</td>
</tr>
<tr>
<td align="left">If-Range</td>
<td align="left">浏览器告诉 WEB 服务器，如果我请求的对象没有改变，就把我缺少的部分给我，如果对象改变了，就把整个对象给我</td>
</tr>
<tr>
<td align="left">Range</td>
<td align="left">浏览器告诉 WEB 服务器自己想取对象的哪部分</td>
</tr>
<tr>
<td align="left">Proxy-Authenticate</td>
<td align="left">代理服务器响应浏览器，要求其提供代理身份验证信息</td>
</tr>
<tr>
<td align="left">Host</td>
<td align="left">客户端指定自己想访问的WEB服务器的域名/IP 地址和端口号</td>
</tr>
<tr>
<td align="left">Referer</td>
<td align="left">浏览器向WEB 服务器表明自己是从哪个网页URL获得点击当前请求中的网址/URL</td>
</tr>
<tr>
<td align="left">User-Agent</td>
<td align="left">浏览器表明自己的身份</td>
</tr>
</tbody></table>
<h1 id="响应头部"><a href="#响应头部" class="headerlink" title="响应头部"></a>响应头部</h1><p>响应头向客户端提供一些额外信息，比如谁在发送响应、响应者的功能，甚至与响应相关的一些特殊指令。这些头部有助于客户端处理响应，并在将来发起更好的请求。响应头域包含Age、Location、Proxy-Authenticate、Public、Retry- After、Server、Vary、Warning、WWW-Authenticate。对响应头域的扩展要求通讯双方都支持，如果存在不支持的响应头域，一般将会作为实体头域处理。</p>
<table>
<thead>
<tr>
<th align="left">应答头</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Age</td>
<td align="left">当代理服务器用自己缓存的实体去响应请求时，用该头部表明该实体从产生到现在经过多长时间了</td>
</tr>
<tr>
<td align="left">Server</td>
<td align="left">WEB 服务器表明自己是什么软件及版本等信息</td>
</tr>
<tr>
<td align="left">Accept-Ranges</td>
<td align="left">WEB服务器表明自己是否接受获取其某个实体的一部分的请求</td>
</tr>
<tr>
<td align="left">Vary</td>
<td align="left">WEB服务器用该头部的内容告诉 Cache 服务器，在什么条件下才能用本响应所返回的对象响应后续的请求</td>
</tr>
</tbody></table>
<h1 id="实体头部"><a href="#实体头部" class="headerlink" title="实体头部"></a>实体头部</h1><p>实体头部提供了有关实体及其内容的大量信息，从有关对象类型的信息，到能够对资源使用的各种有效的请求方法。总之，实体头部可以告知接收者它在对什么进行处理。请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括信息性头部Allow、Location，内容头部Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type，缓存头部Etag、Expires、Last-Modified、extension-header。</p>
<table>
<thead>
<tr>
<th align="left">应答头</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Allow</td>
<td align="left">服务器支持哪些请求方法</td>
</tr>
<tr>
<td align="left">Location</td>
<td align="left">表示客户应当到哪里去提取文档，用于将接收端定位到资源的位置（URL）上</td>
</tr>
<tr>
<td align="left">Content-Base</td>
<td align="left">解析主体中的相对URL时使用的基础URL</td>
</tr>
<tr>
<td align="left">Content-Encoding</td>
<td align="left">WEB服务器表明自己使用了什么压缩方法压缩响应中的对象</td>
</tr>
<tr>
<td align="left">Content-Language</td>
<td align="left">WEB 服务器告诉浏览器理解主体时最适宜使用的自然语言</td>
</tr>
<tr>
<td align="left">Content-Length</td>
<td align="left">WEB服务器告诉浏览器自己响应的对象的长度或尺寸</td>
</tr>
<tr>
<td align="left">Content-Location</td>
<td align="left">资源实际所处的位置</td>
</tr>
<tr>
<td align="left">Content-MD5</td>
<td align="left">主体的MD5校验和</td>
</tr>
<tr>
<td align="left">Content-Range</td>
<td align="left">传送的范围</td>
</tr>
<tr>
<td align="left">Content-Type</td>
<td align="left">WEB 服务器告诉浏览器自己响应的对象的类型</td>
</tr>
<tr>
<td align="left">Etag</td>
<td align="left">供WEB服务器判断一个对象是否改变了</td>
</tr>
<tr>
<td align="left">Expires</td>
<td align="left">WEB服务器表明该实体将在什么时候过期，对于过期了的对象，只有在跟WEB服务器验证了其有效性后，才能用来响应客户请求</td>
</tr>
<tr>
<td align="left">Last-Modified</td>
<td align="left">WEB服务器认为对象的最后修改时间</td>
</tr>
</tbody></table>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://blog.csdn.net/wangzhen_csdn/article/details/80776991" target="_blank" rel="noopener">CSDN-wangzhibo_csdn</a><br><a href="https://segmentfault.com/q/1010000010814115" target="_blank" rel="noopener">segmentfault-某熊猫桑</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>三次握手与四次挥手</title>
    <url>/2020/03/14/tcpConnect/</url>
    <content><![CDATA[<h1 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h1><p>当获取IP之后，客户端就会发送一个报文段给服务器，开启三次握手。</p>
<p><img src="/2020/03/14/tcpConnect/baowenduan.png" alt="baowenduan"></p>
<p>其中确认号下面那个犄角旮旯里：</p>
<blockquote>
<p>URG(urgent)：紧急，为1时表示有紧急数据，应正确传送。<br>ACK(acknowledgement)：确认，为1时确认字号才有效，一旦TCP连接建立，就必须把ACK置为1。<br>PSH(push)：传送，为1时表示尽快交付，不必把整个缓存都填满后再交付。<br>RST(reset)：重置，为1时表示连接中出现严重差错，必须释放连接，重新建立。<br>SYN(synchronous)：建立联机，为1时表示这是一个连接请求或连接接受报文。<br>FIN(finish)：结束，为1时表示此报文段的发送端的数据已发送完毕，要求释放传输连接。</p>
<p>Sequence number(seq)：顺序号码<br>Acknowledge number(ack)：确认号码</p>
</blockquote>
<p><img src="/2020/03/14/tcpConnect/sanciwoshou.png" alt="sanciwoshou"></p>
<p><a href="https://www.bilibili.com/video/av52745283?from=search&seid=12199868811481081570" target="_blank" rel="noopener">图片来源：B站-计算机网络第36讲</a></p>
<p>三次握手功能如下：</p>
<blockquote>
<p>客户端：服大大，我要发数据给你哇，你快来接收啦。<br>服务器：好的，老客你发吧。<br>客户端：嗯嗯，那我发了。</p>
</blockquote>
<p>那为什么是三次握手呢？</p>
<p>这就要考虑到传输时丢包的问题，即当服务器发送给客户端的数据丢包了，如果只有两次握手，服务器是无法确认客户端是否能收到自己的回复。所以第三次握手的作用就是，如果服务器收不到客户端对自己的回复，那么它就会继续发送，直到确认客户端收到了自己的回复。</p>
<blockquote>
<p>客户端：服大大，我要发数据给你哇，你快来接收啦。<br>客户端：（？？？没收到？再来一次）<br>客户端：服大大，我要发数据给你哇，你快来接收啦。<br>服务器：好的，老客你发吧。<br>服务器：（？？？怎么不回我，可能又丢包了，那再发一次吧）<br>服务器：好的，老客你发吧。<br>客户端：嗯嗯，那我发了。<br>服务器：（收到了老客的回复，说明我们的TCP连接已经建立）<br>客户端：（不管服大大有没有收到这条消息，我都认为我们的TCP连接已经建立）</p>
</blockquote>
<p>当然这也只是比较理想的一种情况，现实中这些传递的包可能会卡在路上过了很久之后才传过来，这个时候很有可能客户端与服务器都传输完数据了。如果只有两次握手的话，那么很有可能会再次唤起服务器，造成资源的浪费。  </p>
<p><img src="/2020/03/14/tcpConnect/erciwoshou.png" alt="erciwoshou"></p>
<p><a href="https://www.bilibili.com/video/av52745283?from=search&seid=12199868811481081570" target="_blank" rel="noopener">图片来源：B站-计算机网络第36讲</a></p>
<blockquote>
<p>客户端：服大大，我要发数据给你哇，你快来接收啦。（1）<br>客户端：（？？？没收到？再来一次）<br>客户端：服大大，我要发数据给你哇，你快来接收啦。（2）<br>服务器：好的，老客你发吧。（2）<br>客户端与服务器开心的发完数据，并且关闭了连接。<br>服务器：你怎么又来了？（1）<br>服务器建立连接（1）<br>服务器等待客户端传输请求（1）<br>服务器：我等（1）<br>服务器：我等（1）<br>服务器：我等等等（1）<br>……<br>服务器：？？……？？（1）<br>服务器亡（1）</p>
</blockquote>
<h1 id="传输数据"><a href="#传输数据" class="headerlink" title="传输数据"></a>传输数据</h1><p>握手成功后，开始传输数据，数据被分为多个分节，一次数据的传输需要2个TCP包。数据发送包，接收方应答包。</p>
<p>如果已经建立了连接，客户端突然出现故障。TCP设有一个保活计时器，服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h1 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h1><p><img src="/2020/03/14/tcpConnect/sicihuishou.png" alt="sicihuishou"></p>
<p><a href="https://www.bilibili.com/video/av52745283?from=search&seid=12199868811481081570" target="_blank" rel="noopener">图片来源：B站-计算机网络第36讲</a></p>
<blockquote>
<p>客户端发完数据<br>客户端：服大大，我数据发完了。(停止发送数据，进入终止等待1状态)<br>服务器：好的，我知道了。(进入关闭等待状态)<br>客户端收到回复进入终止等待2状态<br>服务器发完数据<br>服务器：老客啊，我也发完了。(进入最后确认状态)<br>客户端接收完数据：好的。(客户端进入时间等待状态，服务器进入CLOSED状态)<br>2*MSL(最长报文段寿命Maximum Segment Lifetime)时间后，客户端进入CLOSED状态。</p>
</blockquote>
<p>客户端等待2MSL的原因：</p>
<p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p>
<p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.zhihu.com/question/24853633" target="_blank" rel="noopener">知乎-TCP 为什么是三次握手，而不是两次或四次？</a></p>
<p><a href="https://www.bilibili.com/video/av52745283?from=search&seid=12199868811481081570" target="_blank" rel="noopener">B站-计算机网络第36讲</a></p>
<p><a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">CSDN-小书go</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP请求方法</title>
    <url>/2020/03/14/httpMethods/</url>
    <content><![CDATA[<p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。</p>
<p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p>
<p>所以HTTP目前为止一共有九种请求方法。</p>
<h1 id="HEAD-获取报头"><a href="#HEAD-获取报头" class="headerlink" title="HEAD(获取报头)"></a>HEAD(获取报头)</h1><blockquote>
<p>The <strong>HTTP <code>HEAD</code> method</strong> requests the headers that are returned if the specified resource would be requested with an HTTP <code>GET</code> method. Such a request can be done before deciding to download a large resource to save bandwidth, for example.</p>
<p>A response to a <code>HEAD</code> method should not have a body. If so, it must be ignored. Even so, entity headers describing the content of the body, like <code>Content-Length</code> may be included in the response. They don’t relate to the body of the <code>HEAD</code> response, which should be empty, but to the body which a similar request using the <code>GET</code>method would have returned as a response.</p>
</blockquote>
<p>HEAD与GET方法类似，但是它不会返回消息体，用来获取报头，通常用来测试超链接的有效性、可用性。</p>
<h1 id="GET-查询"><a href="#GET-查询" class="headerlink" title="GET(查询)"></a>GET(查询)</h1><blockquote>
<p>The <strong>HTTP <code>GET</code> method</strong> requests a representation of the specified resource. Requests using <code>GET</code> should only retrieve data.</p>
</blockquote>
<p>HTTP协议规定GET是获取资源的方法，通过URL提交，在地址栏中可以看到，其所提交的数据最多只能有1024个字节。GET有利于资源的传播，其请求在Ajax环境下不会被缓存，有利于减轻服务器的压力。</p>
<h1 id="POST-新增"><a href="#POST-新增" class="headerlink" title="POST(新增)"></a>POST(新增)</h1><blockquote>
<p>The <strong>HTTP <code>POST</code> method</strong> sends data to the server. The type of the body of the request is indicated by the Content-Type header.</p>
</blockquote>
<p>HTTP协议规定POST是创建资源的方法，其内容是在HTTP请求的body里实现，POST传输数据时不会在URL里显示，可以传输较为大量的数据，在Ajax环境下会被缓存，非幂等的，多次访问都会产生影响。</p>
<h1 id="PUT-修改"><a href="#PUT-修改" class="headerlink" title="PUT(修改)"></a>PUT(修改)</h1><blockquote>
<p>The <strong>HTTP PUT request method</strong> creates a new resource or replaces a representation of the target resource with the request payload.</p>
<p>The difference between <code>PUT</code> and <code>POST</code> is that <code>PUT</code>is idempotent: calling it once or several times successively has the same effect (that is no side effect), where successive identical <code>POST</code> may have additional effects, like passing an order several times.</p>
</blockquote>
<p>HTTP协议规定PUT是更新资源的方法,<code>PUT</code>是幂等的方法，即调用一次与调用多次是等价的。</p>
<h1 id="PATCH-修改"><a href="#PATCH-修改" class="headerlink" title="PATCH(修改)"></a>PATCH(修改)</h1><blockquote>
<p>The <strong>HTTP PATCH request method</strong> applies partial modifications to a resource.</p>
<p>The HTTP <code>PUT</code>method only allows complete replacement of a document. Unlike <code>PUT</code>, <code>PATCH</code> is not idempotent, meaning successive identical patch requests <em>may</em> have different effects. However, it is possible to issue <code>PATCH</code> requests in such a way as to be idempotent.</p>
<p>PATCH (like PUT) may have side-effects on other resources.</p>
<p>To find out whether a server supports <code>PATCH</code>, a server can advertise its support by adding it to the list in the Allow or Access-Control-Allow-Methods(for CORS) response headers.</p>
</blockquote>
<p>HTTP协议规定PATCH是修改资源的方法，是对PUT方法的补充，用来对已知资源进行局部更新，但PATCH与POST一样是非幂等的。</p>
<h1 id="DELETE-删除"><a href="#DELETE-删除" class="headerlink" title="DELETE(删除)"></a>DELETE(删除)</h1><blockquote>
<p>The <strong>HTTP DELETE request method</strong> deletes the specified resource.</p>
</blockquote>
<p>HTTP协议规定DELETE是删除资源的方法.</p>
<h1 id="CONNECT-代理"><a href="#CONNECT-代理" class="headerlink" title="CONNECT(代理)"></a>CONNECT(代理)</h1><blockquote>
<p>The <strong>HTTP <code>CONNECT</code> method</strong> starts two-way communications with the requested resource. It can be used to open a tunnel.</p>
<p>For example, the <code>CONNECT</code> method can be used to access websites that use SSL (HTTPS). The client asks an HTTP Proxy server to tunnel the TCP connection to the desired destination. The server then proceeds to make the connection on behalf of the client. Once the connection has been established by the server, the Proxy server continues to proxy the TCP stream to and from the client.</p>
</blockquote>
<p><code>CONNECT</code>在网页开发中一般不会被用到，其作用是将服务器作为代理(访问中介)，让服务器代替用户访问别的资源，然后再将该资源返回给用户，这样用户就可以访问到只有服务器才能访问的网站(比如翻墙 )，它直接使用TCP去连接。</p>
<h1 id="TRACE-测试"><a href="#TRACE-测试" class="headerlink" title="TRACE(测试)"></a>TRACE(测试)</h1><blockquote>
<p>The <strong>HTTP <code>TRACE</code> method</strong> performs a message loop-back test along the path to the target resource, providing a useful debugging mechanism.</p>
</blockquote>
<p>回显服务器收到的请求，主要用于测试或诊断。</p>
<h1 id="OPTIONS-测试"><a href="#OPTIONS-测试" class="headerlink" title="OPTIONS(测试)"></a>OPTIONS(测试)</h1><blockquote>
<p>The <strong>HTTP <code>OPTIONS</code> method</strong> is used to describe the communication options for the target resource. The client can specify a URL for the OPTIONS method, or an asterisk (*) to refer to the entire server.</p>
<p> For Example, to find out which request methods a server supports, one can use curl and issue an OPTIONS request.</p>
</blockquote>
<p>通过该方法传回该资源所支持的所有HTTP请求，也可以测试服务器是否可以正常使用。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods" target="_blank" rel="noopener">MDN</a></p>
<p><a href="https://www.runoob.com/http/http-methods.html" target="_blank" rel="noopener">菜鸟联盟</a></p>
<p><a href="https://blog.csdn.net/kobejayandy/article/details/24606521" target="_blank" rel="noopener">CSDN-kobejayandy</a></p>
<p><a href="https://www.jianshu.com/p/93727598b564" target="_blank" rel="noopener">简书-5onghua</a></p>
<p><a href="https://www.zhihu.com/question/31640769" target="_blank" rel="noopener">知乎</a></p>
<p><a href="https://www.cnblogs.com/liuzhenbo/p/11045048.html" target="_blank" rel="noopener">博客园-心田居士</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP状态码</title>
    <url>/2020/03/13/httpStatusCode/</url>
    <content><![CDATA[<h1 id="什么是HTTP状态码？"><a href="#什么是HTTP状态码？" class="headerlink" title="什么是HTTP状态码？"></a>什么是HTTP状态码？</h1><p>所谓的HTTP状态码就是表示网页服务器超文本传输协议(HyperText Transfer protocol)响应状态的3位十进制数字代码，它由<a href="https://tools.ietf.org/html/rfc2616" target="_blank" rel="noopener">RFC2616</a>规范定义，并由互联网号码分配局(Internet Assigned Numbers Authority)维护。当浏览者访问一个网页时，浏览器会向服务器发送请求，服务器会返回一个包含HTTP状态码的信息头(server head)响应网页请求。</p>
<p>换句话说HTTP状态码就是统一标准被大家都认可的一个表示网页与服务器之间通信状态的一个东西。</p>
<h1 id="常用状态码"><a href="#常用状态码" class="headerlink" title="常用状态码"></a>常用状态码</h1><ul>
<li>200 - 请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL</li>
<li>404 - 请求的资源（网页等）不存在</li>
<li>500 - 内部服务器错误</li>
</ul>
<h1 id="HTTP状态码的分类"><a href="#HTTP状态码的分类" class="headerlink" title="HTTP状态码的分类"></a>HTTP状态码的分类</h1><p>HTTP状态码由三个十进制组成，只有第一个十进制定义了分类，后面两个无分类作用，其具体分类如下：</p>
<h2 id="1-信息"><a href="#1-信息" class="headerlink" title="1** 信息"></a>1** 信息</h2><p>服务器收到请求，需要请求者继续执行操作。</p>
<p>服务器：老客啊，你到底想干啥？？？</p>
<table>
<thead>
<tr>
<th align="left">状态码</th>
<th align="left">状态码英文名称</th>
<th align="left">中文描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">100</td>
<td align="left">Continue</td>
<td align="left">继续。客户端应继续其请求</td>
</tr>
<tr>
<td align="left">101</td>
<td align="left">Switching Protocols</td>
<td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td>
</tr>
</tbody></table>
<h2 id="2-成功"><a href="#2-成功" class="headerlink" title="2** 成功"></a>2** 成功</h2><p>操作被成功接收并处理。</p>
<p>服务器：老客啊，不愧是cp，你看这次咱俩配合的多默契。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态码英文名称</th>
<th>中文描述</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>OK</td>
<td>请求成功。一般用于GET与POST请求</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>已创建。成功请求并创建了新的资源</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td>已接受。已经接受请求，但未处理完成</td>
</tr>
<tr>
<td>203</td>
<td>Non-Authoritative Information</td>
<td>非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td>
</tr>
<tr>
<td>204</td>
<td>No Content</td>
<td>无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td>
</tr>
<tr>
<td>205</td>
<td>Reset Content</td>
<td>重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td>
</tr>
<tr>
<td>206</td>
<td>Partial Content</td>
<td>部分内容。服务器成功处理了部分GET请求</td>
</tr>
</tbody></table>
<h2 id="3-重定向"><a href="#3-重定向" class="headerlink" title="3**  重定向"></a>3**  重定向</h2><p>需要进一步的操作以完成请求。</p>
<p>服务器：老客啊，你要的东西不在这，你换个地方去拿。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态码英文名称</th>
<th>中文描述</th>
</tr>
</thead>
<tbody><tr>
<td>300</td>
<td>Multiple Choices</td>
<td>多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td>
</tr>
<tr>
<td>301</td>
<td>Moved Permanently</td>
<td>永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td>
</tr>
<tr>
<td>303</td>
<td>See Other</td>
<td>查看其它地址。与301类似。使用GET和POST请求查看</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td>
</tr>
<tr>
<td>305</td>
<td>Use Proxy</td>
<td>使用代理。所请求的资源必须通过代理访问</td>
</tr>
<tr>
<td>306</td>
<td>Unused</td>
<td>已经被废弃的HTTP状态码</td>
</tr>
<tr>
<td>307</td>
<td>Temporary Redirect</td>
<td>临时重定向。与302类似。使用GET请求重定向</td>
</tr>
</tbody></table>
<h2 id="4-客户端错误"><a href="#4-客户端错误" class="headerlink" title="4** 客户端错误"></a>4** 客户端错误</h2><p>请求包含语法错误或无法完成请求。</p>
<p>服务器：老客啊，这是你的错，不怨我。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态码英文名称</th>
<th>中文描述</th>
</tr>
</thead>
<tbody><tr>
<td>400</td>
<td>Bad Request</td>
<td>客户端请求的语法错误，服务器无法理解</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>请求要求用户的身份认证</td>
</tr>
<tr>
<td>402</td>
<td>Payment Required</td>
<td>保留，将来使用</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>服务器理解请求客户端的请求，但是拒绝执行此请求</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td>
</tr>
<tr>
<td>405</td>
<td>Method Not Allowed</td>
<td>客户端请求中的方法被禁止</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>服务器无法根据客户端请求的内容特性完成请求</td>
</tr>
<tr>
<td>407</td>
<td>Proxy Authentication Required</td>
<td>请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td>
</tr>
<tr>
<td>408</td>
<td>Request Time-out</td>
<td>服务器等待客户端发送的请求时间过长，超时</td>
</tr>
<tr>
<td>409</td>
<td>Conflict</td>
<td>服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td>
</tr>
<tr>
<td>410</td>
<td>Gone</td>
<td>客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td>
</tr>
<tr>
<td>411</td>
<td>Length Required</td>
<td>服务器无法处理客户端发送的不带Content-Length的请求信息</td>
</tr>
<tr>
<td>412</td>
<td>Precondition Failed</td>
<td>客户端请求信息的先决条件错误</td>
</tr>
<tr>
<td>413</td>
<td>Request Entity Too Large</td>
<td>由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td>
</tr>
<tr>
<td>414</td>
<td>Request-URI Too Large</td>
<td>请求的URI过长（URI通常为网址），服务器无法处理</td>
</tr>
<tr>
<td>415</td>
<td>Unsupported Media Type</td>
<td>服务器无法处理请求附带的媒体格式</td>
</tr>
<tr>
<td>416</td>
<td>Requested range not satisfiable</td>
<td>客户端请求的范围无效</td>
</tr>
<tr>
<td>417</td>
<td>Expectation Failed</td>
<td>服务器无法满足Expect的请求头信息</td>
</tr>
</tbody></table>
<h2 id="5-服务器错误"><a href="#5-服务器错误" class="headerlink" title="5**  服务器错误"></a>5**  服务器错误</h2><p>服务器在处理请求的过程中发生了错误。</p>
<p>服务器：嗯。这次是我的错误。</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态码英文名称</th>
<th>中文描述</th>
</tr>
</thead>
<tbody><tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器内部错误，无法完成请求</td>
</tr>
<tr>
<td>501</td>
<td>Not Implemented</td>
<td>服务器不支持请求的功能，无法完成请求</td>
</tr>
<tr>
<td>502</td>
<td>Bad Gateway</td>
<td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td>
</tr>
<tr>
<td>503</td>
<td>Service Unavailable</td>
<td>由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td>
</tr>
<tr>
<td>504</td>
<td>Gateway Time-out</td>
<td>充当网关或代理的服务器，未及时从远端服务器获取请求</td>
</tr>
<tr>
<td>505</td>
<td>HTTP Version not supported</td>
<td>服务器不支持请求的HTTP协议的版本，无法完成处理</td>
</tr>
</tbody></table>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.runoob.com/http/http-status-codes.html" target="_blank" rel="noopener">菜鸟联盟大佬</a></p>
<p><a href="https://baike.baidu.com/item/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/5053660" target="_blank" rel="noopener">度娘</a></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHubReadme</title>
    <url>/2000/03/13/README/</url>
    <content><![CDATA[<p>用hexo开始写博客，辛辛苦苦写的文章放在这个仓备份一下吧。</p>
<p>如果你对我的博客感兴趣欢迎来访问。</p>
<p>GitHub：<a href="https://lesvay.github.io/">https://lesvay.github.io/</a></p>
<p>Gitee：<a href="https://lesvay.gitee.io/" target="_blank" rel="noopener">https://lesvay.gitee.io/</a></p>
]]></content>
  </entry>
</search>
